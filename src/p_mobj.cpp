// Emacs style mode select	 -*- C++ -*-
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//		Moving object handling. Spawn functions.
//
//-----------------------------------------------------------------------------

// HEADER FILES ------------------------------------------------------------

#include "templates.h"
#include "m_alloc.h"
#include "i_system.h"
#include "m_random.h"
#include "doomdef.h"
#include "p_local.h"
#include "p_lnspec.h"
#include "p_effect.h"
#include "p_terrain.h"
#include "st_stuff.h"
#include "hu_stuff.h"
#include "s_sound.h"
#include "doomstat.h"
#include "v_video.h"
#include "c_cvars.h"
#include "b_bot.h"	//Added by MC:
#include "stats.h"
#include "a_doomglobal.h"
#include "a_hexenglobal.h"
#include "a_sharedglobal.h"
#include "gi.h"
#include "sbar.h"
#include "p_acs.h"
#include "cmdlib.h"
#include "decallib.h"
#include "ravenshared.h"
#include "a_action.h"
#include "a_keys.h"
#include "p_conversation.h"
#include "thingdef/thingdef.h"
#include "g_game.h"

#include "gl/gl_functions.h"
#define __DEFINE_INTERFACE
#include "fragglescript/t_script.h"

//ghk new artifact/extra health spawning code fo addonapack
static FRandom pr_gkspawnchance2("gkchance2"); //ghk
extern int rndindexA;
extern int arrArtifacts[1000];
CVAR (Bool, sd_artifacts, true,CVAR_ARCHIVE) //ghk
CVAR (Bool, sd_custom_replacements, true,CVAR_ARCHIVE) //ghk
CVAR (Bool, sd_acs_level_custom_monster_override, true,CVAR_ARCHIVE)
CVAR (Int, sd_noinfight, 0,CVAR_ARCHIVE) //ghk
CVAR (Int, sd_pistolstart, 0,CVAR_ARCHIVE) //ghk
CVAR (Bool, sd_bossrush,true,CVAR_ARCHIVE) //ghk, no need to check in TICK for online scoring
//since having it off will hurt the score anyways!
CVAR (Bool, sd_bossrush2,true,CVAR_ARCHIVE) //ghk

CVAR (Bool, sd_defaultmonstermaps_replace_all,true,CVAR_ARCHIVE) //ghk, no need to check in TICK for online scoring
//since having it off will hurt the score anyways!
CVAR (Bool, sd_defaultmonstermaps_replace_all2,true,CVAR_ARCHIVE) //ghk

CUSTOM_CVAR (Int, sd_extrahealth_chance, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk was 35
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}


CUSTOM_CVAR (Int, sd_artifact_chance, 7,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk WAS 10
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}

CUSTOM_CVAR (Int, sd_kill_extrahealth_chance, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL)
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}


CUSTOM_CVAR (Int, sd_kill_artifact_chance, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL)
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}



CUSTOM_CVAR (Int, sd_rep_arachnotron_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_explosivebarrel_chance, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_burningbarrel_chance, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_archvile_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_baronofhell_chance, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_hellknight_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_cacodemon_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_cyberdemon_chance, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_demon_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_spectre_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_chaingunguy_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_doomimp_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_fatso_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_lostsoul_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_painelemental_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_revenant_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_shotgunguy_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_spidermastermind_chance, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_wolfensteinss_chance, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_zombieman_chance, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

//////////////////////used for sdcustom.ini overrides:

CUSTOM_CVAR (Int, sd_extrahealth_chance2, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk was 35
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}


CUSTOM_CVAR (Int, sd_artifact_chance2, 7,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk WAS 10
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}

CUSTOM_CVAR (Int, sd_kill_extrahealth_chance2, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL)
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}


CUSTOM_CVAR (Int, sd_kill_artifact_chance2, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL)
{
	if (self<0){
		self=0;
	}else if(self > 255){
		self=255;
	}

}


CUSTOM_CVAR (Int, sd_rep_arachnotron_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_explosivebarrel_chance2, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_burningbarrel_chance2, 25,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_archvile_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_baronofhell_chance2, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_hellknight_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_cacodemon_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_cyberdemon_chance2, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_demon_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_spectre_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_chaingunguy_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_doomimp_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_fatso_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_lostsoul_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

CUSTOM_CVAR (Int, sd_rep_painelemental_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_revenant_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_shotgunguy_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_spidermastermind_chance2, 100,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_wolfensteinss_chance2, 0,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}
CUSTOM_CVAR (Int, sd_rep_zombieman_chance2, 60,CVAR_ARCHIVE|CVAR_SDSPECIAL) //ghk
{
	if (self<0){
		self=0;
	}else if(self > 100){
		self=100;
	}

}

///////////////////



static const unsigned char rndtable2[4096]= {75, 174, 231, 176, 184, 183, 139, 129, 216, 173, 11, 116, 171, 249, 214, 146, 95, 223, 97, 41, 101, 12, 183, 38, 239, 40, 7, 89, 178, 224, 123, 95, 253, 86, 235, 199, 94, 242, 44, 82, 239, 144, 203, 4, 133, 249, 34, 137, 117, 66, 75, 151, 202, 206, 181, 240, 9, 159, 97, 59, 80, 48, 193, 63, 52, 47, 131, 196, 187, 122, 32, 46, 123, 254, 62, 206, 198, 143, 89, 28, 253, 96, 30, 69, 22, 116, 23, 223, 60, 89, 38, 80, 77, 107, 52, 244, 144, 47, 52, 82, 165, 151, 98, 75, 64, 164, 5, 233, 129, 87, 199, 76, 66, 227, 195, 50, 182, 250, 13, 238, 11, 38, 83, 181, 144, 129, 188, 245, 20, 140, 190, 198, 198, 109, 240, 160, 226, 191, 122, 45, 227, 241, 160, 106, 185, 80, 105, 111, 211, 7, 37, 175, 74, 231, 199, 24, 165, 24, 177, 68, 16, 190, 122, 182, 176, 99, 212, 96, 31, 239, 89, 150, 152, 65, 89, 102, 148, 158, 123, 76, 253, 233, 246, 99, 251, 253, 151, 173, 193, 101, 200, 90, 72, 183, 248, 201, 46, 196, 109, 177, 68, 66, 175, 232, 110, 213, 58, 81, 138, 26, 232, 200, 34, 228, 8, 86, 108, 244, 150, 128, 5, 68, 86, 86, 103, 100, 227, 196, 218, 171, 239, 169, 242, 127, 13, 144, 54, 169, 62, 45, 223, 128, 155, 71, 189, 176, 241, 116, 141, 116, 42, 228, 251, 136, 189, 95, 161, 104, 26, 225, 242, 33, 53, 131, 19, 182, 239, 192, 236, 16, 32, 241, 181, 91, 65, 123, 81, 64, 205, 39, 143, 105, 89, 69, 105, 149, 43, 79, 166, 27, 19, 93, 103, 132, 189, 29, 22, 15, 122, 215, 25, 240, 187, 214, 148, 158, 65, 157, 19, 202, 214, 108, 191, 116, 26, 28, 66, 51, 140, 159, 200, 197, 122, 72, 49, 49, 252, 170, 106, 206, 91, 252, 112, 57, 157, 224, 53, 135, 2, 221, 226, 9, 85, 47, 160, 153, 224, 57, 244, 161, 197, 143, 108, 31, 15, 154, 228, 100, 216, 180, 62, 176, 1, 7, 185, 147, 223, 163, 142, 183, 103, 16, 127, 194, 195, 228, 71, 41, 113, 63, 234, 241, 41, 140, 173, 12, 199, 131, 134, 95, 120, 81, 117, 104, 6, 152, 242, 91, 59, 82, 32, 147, 142, 161, 244, 144, 55, 95, 246, 241, 234, 106, 77, 150, 47, 223, 79, 153, 43, 249, 152, 208, 72, 152, 230, 119, 228, 131, 177, 208, 101, 3, 122, 223, 208, 201, 85, 221, 5, 237, 247, 168, 28, 138, 9, 62, 111, 146, 229, 57, 242, 144, 119, 117, 66, 100, 214, 53, 226, 105, 199, 147, 163, 62, 15, 158, 1, 247, 167, 51, 170, 177, 186, 154, 12, 75, 13, 227, 209, 153, 67, 67, 235, 130, 227, 3, 114, 67, 179, 31, 63, 158, 38, 81, 161, 193, 58, 42, 235, 137, 29, 186, 246, 55, 42, 151, 208, 177, 212, 38, 13, 63, 30, 174, 18, 9, 220, 72, 193, 183, 16, 99, 166, 74, 254, 191, 140, 140, 138, 150, 23, 183, 134, 3, 111, 82, 78, 34, 152, 220, 36, 222, 90, 203, 2, 18, 242, 235, 173, 148, 251, 172, 221, 176, 221, 196, 45, 207, 102, 42, 83, 75, 189, 203, 1, 4, 246, 52, 35, 216, 250, 10, 17, 242, 106, 110, 121, 222, 76, 79, 70, 92, 23, 49, 235, 66, 180, 61, 207, 34, 160, 56, 111, 226, 23, 139, 239, 105, 182, 200, 181, 37, 138, 212, 66, 110, 162, 102, 118, 222, 231, 200, 200, 31, 182, 112, 155, 46, 50, 155, 55, 191, 238, 50, 83, 70, 202, 238, 46, 18, 67, 74, 126, 44, 159, 180, 116, 210, 142, 110, 1, 240, 191, 176, 100, 142, 252, 236, 225, 240, 6, 155, 254, 12, 99, 122, 85, 12, 185, 17, 126, 214, 8, 31, 253, 245, 107, 195, 63, 177, 155, 97, 31, 10, 91, 175, 95, 238, 133, 247, 130, 58, 54, 53, 120, 250, 195, 161, 56, 19, 249, 95, 67, 146, 232, 241, 149, 222, 69, 190, 20, 127, 12, 40, 5, 108, 108, 146, 113, 192, 183, 105, 132, 253, 15, 55, 71, 133, 31, 241, 248, 98, 20, 11, 110, 100, 45, 9, 166, 68, 59, 67, 133, 168, 50, 224, 123, 42, 178, 93, 85, 162, 69, 158, 246, 189, 82, 47, 76, 96, 167, 55, 215, 69, 131, 187, 182, 54, 166, 227, 231, 110, 223, 82, 198, 230, 228, 72, 140, 222, 23, 151, 153, 121, 248, 173, 227, 23, 168, 132, 192, 242, 198, 202, 164, 167, 119, 129, 8, 128, 24, 14, 8, 195, 90, 21, 115, 216, 57, 99, 112, 174, 15, 226, 182, 212, 181, 223, 145, 145, 75, 222, 161, 133, 120, 214, 73, 181, 210, 0,60, 81, 218, 62, 129, 50, 180, 216, 143, 211, 118, 104, 182, 131, 55, 199, 97, 147, 199, 110, 247, 171, 249, 195, 75, 192, 224, 230, 149, 182, 101, 234, 7, 145, 200, 174, 188, 217, 109, 84, 203, 250, 80, 230, 177, 138, 53, 202, 28, 200, 97, 120, 131, 39, 36, 121, 98, 88, 32, 170, 75, 42, 114, 171, 47, 137, 100, 176, 100, 2, 68, 37, 7, 149, 94, 51, 35, 239, 216, 185, 13, 225, 107, 60, 8, 151, 94, 39, 243, 8, 111, 5, 104, 41, 107, 89, 254, 164, 59, 141, 7, 63, 74, 149, 22, 159, 206, 15, 40, 219, 119, 65, 18, 11, 132, 147, 3, 46, 11, 58, 216, 198, 116, 79, 175, 253, 241, 232, 249, 121, 145, 156, 238, 225, 49, 153, 192, 165, 99, 145, 97, 178, 140, 186, 13, 215, 80, 167, 19, 200, 77, 254, 92, 58, 216, 232, 123, 4, 21, 156, 203, 15, 72, 154, 62, 168, 219, 20, 11, 213, 164, 81, 94, 144, 153, 61, 129, 34, 245, 238, 179, 63, 59, 139, 27, 109, 35, 251, 190, 197, 208, 182, 127, 94, 4, 69, 72, 165, 42, 83, 180, 84, 93, 205, 78, 6, 70, 243, 96, 52, 239, 102, 56, 236, 69, 217, 39, 197, 205, 134, 90, 90, 205, 107, 239, 28, 147, 52, 47, 115, 12, 215, 252, 212, 76, 24, 226, 22, 188, 167, 28, 44, 14, 7, 9, 130, 235, 46, 110, 55, 155, 167, 160, 254, 97, 17, 126, 186, 152, 242, 192, 155, 206, 80, 166, 108, 31, 188, 132, 113, 75, 149, 254, 163, 189, 130, 29, 16, 174, 180, 91, 189, 50, 36, 38, 249, 203, 144, 4, 176, 111, 87, 140, 73, 172, 221, 59, 166, 169, 238, 179, 247, 68, 129, 188, 145, 144, 59, 181, 86, 53, 100, 181, 12, 241, 51, 200, 178, 182, 23, 1, 254, 83, 29, 66, 52, 156, 149, 142, 220, 91, 234, 191, 113, 26, 255, 68, 112, 7, 125, 88, 79, 199, 31, 204, 134, 7, 133, 251, 17, 245, 9, 25, 244, 199, 191, 78, 202, 94, 64, 128, 202, 247, 167, 166, 142, 192, 15, 212, 164, 147, 247, 14, 251, 246, 20, 212, 115, 201, 145, 88, 28, 134, 51, 189, 53, 65, 145, 177, 166, 207, 92, 1, 98, 141, 186, 71, 35, 78, 228, 81, 34, 226, 119, 215, 118, 141, 97, 137, 119, 77, 23, 94, 212, 205, 55, 37, 251, 8, 22, 33, 52, 119, 93, 84, 225, 174, 132, 204, 165, 214, 254, 210, 78, 102, 220, 113, 57, 192, 243, 23, 66, 63, 237, 138, 85, 23, 68, 128, 164, 101, 155, 91, 160, 84, 51, 149, 44, 228, 150, 84, 233, 142, 119, 123, 42, 21, 90, 71, 176, 159, 168, 56, 137, 244, 15, 154, 45, 86, 2, 105, 109, 4, 20, 201, 9, 236, 2, 120, 86, 107, 95, 223, 34, 38, 146, 138, 180, 123, 231, 180, 5, 189, 176, 157, 60, 204, 215, 27, 253, 35, 197, 152, 125, 158, 47, 88, 229, 163, 43, 80, 134, 39, 18, 123, 24, 110, 144, 175, 142, 248, 2, 124, 43, 42, 45, 138, 248, 190, 154, 51, 89, 252, 1, 216, 42, 224, 175, 143, 185, 61, 140, 79, 0,217, 207, 170, 172, 51, 193, 157, 225, 79, 155, 134, 46, 151, 23, 192, 192, 54, 100, 174, 223, 196, 245, 57, 125, 145, 11, 245, 252, 182, 255, 11, 129, 157, 20, 19, 148, 91, 213, 219, 137, 102, 95, 218, 191, 207, 90, 157, 240, 39, 6, 72, 155, 128, 164, 130, 248, 249, 62, 162, 76, 81, 29, 65, 208, 152, 88, 105, 87, 75, 106, 223, 111, 81, 36, 218, 2, 97, 58, 126, 114, 107, 93, 57, 156, 88, 0,229, 155, 141, 231, 32, 213, 229, 59, 216, 153, 248, 1, 155, 136, 129, 226, 88, 57, 155, 167, 190, 154, 143, 243, 100, 52, 80, 223, 253, 218, 216, 92, 246, 41, 205, 162, 132, 6, 109, 180, 39, 122, 38, 134, 58, 73, 116, 114, 196, 41, 203, 133, 79, 246, 128, 155, 217, 220, 117, 99, 104, 79, 109, 35, 216, 171, 118, 155, 202, 115, 214, 98, 114, 95, 61, 221, 41, 1, 180, 114, 75, 69, 41, 116, 226, 227, 173, 67, 17, 194, 226, 38, 228, 82, 34, 192, 180, 62, 223, 112, 113, 16, 18, 99, 180, 22, 196, 35, 130, 97, 75, 240, 196, 186, 199, 189, 150, 83, 144, 85, 76, 31, 94, 26, 10, 58, 163, 216, 107, 11, 172, 66, 83, 145, 97, 26, 157, 33, 165, 126, 201, 155, 89, 131, 23, 134, 207, 243, 202, 106, 152, 59, 123, 130, 1, 108, 98, 53, 127, 183, 138, 150, 167, 22, 197, 34, 230, 110, 216, 205, 99, 83, 82, 227, 244, 87, 196, 84, 253, 239, 222, 210, 81, 62, 39, 143, 19, 78, 117, 106, 157, 1, 126, 67, 244, 102, 238, 77, 118, 79, 144, 141, 144, 165, 238, 43, 76, 132, 191, 172, 114, 9, 41, 67, 214, 164, 138, 231, 34, 2, 23, 85, 6, 162, 5, 21, 113, 5, 103, 42, 161, 117, 47, 132, 136, 197, 213, 30, 0,155, 126, 82, 180, 140, 56, 82, 134, 22, 253, 105, 85, 31, 239, 99, 222, 6, 224, 184, 96, 42, 17, 204, 11, 98, 98, 100, 101, 55, 211, 97, 199, 121, 78, 235, 250, 121, 71, 124, 234, 62, 152, 157, 6, 30, 74, 208, 168, 128, 207, 199, 77, 215, 49, 241, 241, 160, 97, 124, 55, 216, 177, 16, 78, 90, 231, 230, 175, 120, 255, 119, 233, 170, 16, 113, 152, 34, 27, 196, 189, 6, 185, 76, 53, 108, 207, 233, 1, 74, 107, 21, 123, 84, 229, 119, 80, 37, 65, 159, 62, 19, 111, 188, 58, 237, 224, 44, 147, 3, 79, 177, 22, 25, 38, 140, 240, 125, 82, 201, 98, 194, 144, 255, 213, 192, 119, 22, 254, 3, 159, 193, 20, 51, 70, 86, 11, 0,172, 159, 244, 146, 86, 241, 67, 251, 238, 8, 212, 242, 83, 214, 10, 191, 175, 110, 5, 143, 46, 213, 153, 45, 237, 243, 234, 211, 82, 238, 249, 225, 226, 161, 200, 42, 236, 159, 172, 36, 51, 192, 162, 93, 191, 50, 70, 132, 190, 10, 27, 178, 1, 140, 83, 255, 77, 183, 80, 3, 56, 28, 59, 123, 158, 194, 5, 114, 42, 187, 22, 230, 140, 194, 165, 146, 52, 200, 146, 101, 73, 67, 244, 10, 184, 184, 110, 72, 233, 144, 107, 18, 113, 234, 17, 189, 204, 61, 155, 106, 199, 128, 88, 111, 127, 226, 34, 131, 149, 125, 161, 137, 54, 236, 240, 9, 227, 125, 154, 219, 15, 106, 6, 24, 132, 177, 116, 7, 145, 48, 214, 180, 175, 8, 99, 239, 47, 203, 248, 87, 236, 155, 172, 236, 203, 15, 230, 162, 249, 223, 153, 99, 119, 60, 209, 164, 132, 26, 7, 190, 227, 18, 232, 31, 199, 35, 127, 13, 83, 61, 143, 195, 130, 126, 10, 158, 240, 252, 95, 112, 208, 67, 23, 110, 225, 240, 241, 186, 198, 109, 65, 59, 123, 101, 204, 104, 249, 120, 199, 149, 105, 147, 246, 168, 59, 128, 243, 67, 177, 166, 10, 29, 59, 44, 206, 197, 228, 136, 190, 11, 227, 35, 227, 227, 233, 176, 85, 80, 130, 229, 237, 113, 38, 140, 83, 230, 47, 43, 153, 216, 1, 52, 116, 12, 1, 53, 229, 252, 4, 127, 209, 107, 237, 176, 165, 138, 6, 176, 137, 219, 122, 21, 52, 210, 45, 77, 130, 120, 138, 160, 116, 180, 191, 214, 4, 69, 254, 81, 143, 65, 254, 117, 72, 147, 238, 144, 33, 24, 135, 208, 58, 222, 161, 98, 179, 166, 255, 168, 4, 205, 164, 74, 206, 196, 249, 223, 42, 156, 155, 74, 232, 107, 101, 15, 78, 19, 163, 150, 6, 100, 242, 220, 216, 198, 108, 241, 214, 70, 51, 160, 33, 100, 93, 198, 152, 22, 110, 20, 221, 28, 107, 121, 24, 82, 110, 31, 226, 136, 117, 120, 136, 91, 179, 249, 141, 164, 76, 17, 23, 106, 227, 46, 83, 158, 182, 22, 117, 140, 84, 67, 80, 172, 31, 198, 173, 91, 7, 7, 225, 35, 182, 154, 15, 94, 134, 214, 146, 115, 60, 212, 4, 89, 100, 72, 232, 224, 178, 8, 11, 237, 85, 28, 231, 254, 175, 233, 65, 76, 40, 97, 74, 82, 30, 34, 35, 228, 26, 38, 199, 164, 140, 243, 119, 92, 56, 36, 241, 231, 106, 231, 146, 29, 218, 65, 116, 181, 198, 224, 84, 90, 105, 227, 194, 196, 128, 62, 159, 94, 240, 83, 137, 229, 237, 228, 31, 107, 64, 191, 97, 98, 110, 106, 163, 157, 139, 161, 166, 205, 110, 178, 110, 128, 209, 130, 103, 160, 205, 181, 31, 81, 134, 114, 202, 45, 186, 61, 52, 35, 48, 163, 121, 202, 93, 219, 73, 82, 17, 8, 200, 72, 245, 105, 124, 9, 240, 220, 200, 251, 77, 179, 173, 192, 177, 123, 107, 2, 133, 75, 127, 244, 68, 233, 110, 128, 194, 141, 75, 131, 24, 244, 181, 20, 37, 81, 113, 102, 42, 216, 57, 150, 20, 216, 181, 200, 72, 188, 206, 3, 226, 247, 150, 150, 48, 129, 83, 35, 48, 128, 194, 27, 151, 177, 14, 52, 158, 116, 37, 64, 79, 145, 84, 210, 197, 132, 50, 129, 3, 146, 177, 181, 114, 222, 92, 181, 86, 183, 57, 38, 152, 84, 229, 42, 83, 168, 178, 47, 147, 88, 115, 196, 111, 116, 191, 237, 140, 99, 24, 35, 159, 86, 69, 136, 45, 175, 188, 229, 56, 247, 160, 175, 235, 118, 24, 165, 155, 244, 121, 177, 168, 254, 155, 59, 235, 172, 58, 124, 87, 58, 13, 98, 67, 156, 130, 33, 239, 201, 177, 214, 43, 211, 23, 175, 243, 138, 58, 107, 84, 61, 36, 122, 36, 28, 222, 212, 203, 197, 221, 32, 78, 249, 80, 23, 33, 162, 195, 227, 70, 25, 123, 191, 74, 73, 36, 57, 108, 29, 57, 130, 54, 198, 156, 134, 90, 153, 96, 190, 75, 143, 169, 131, 152, 6, 238, 22, 89, 9, 155, 189, 118, 53, 40, 22, 173, 69, 112, 27, 96, 140, 218, 154, 84, 199, 99, 116, 84, 83, 68, 113, 182, 71, 70, 145, 77, 195, 48, 90, 31, 197, 235, 43, 201, 186, 75, 123, 213, 108, 41, 186, 197, 57, 210, 208, 218, 2, 79, 50, 192, 18, 16, 67, 118, 247, 18, 238, 181, 104, 68, 98, 29, 90, 59, 133, 29, 236, 1, 238, 104, 28, 171, 44, 87, 240, 13, 172, 24, 149, 128, 228, 27, 200, 70, 57, 100, 36, 99, 180, 196, 7, 53, 209, 20, 72, 80, 136, 165, 144, 44, 63, 27, 179, 105, 139, 175, 157, 60, 100, 187, 21, 152, 17, 24, 21, 75, 25, 98, 168, 17, 104, 212, 217, 22, 81, 194, 202, 6, 29, 2, 10, 247, 189, 237, 23, 19, 148, 165, 50, 174, 94, 91, 220, 48, 8, 83, 248, 126, 184, 40, 225, 59, 53, 161, 213, 113, 177, 6, 194, 98, 98, 131, 185, 147, 43, 151, 116, 248, 129, 231, 211, 87, 237, 52, 166, 145, 138, 52, 219, 157, 147, 91, 18, 82, 103, 129, 114, 248, 79, 63, 247, 239, 248, 183, 154, 50, 236, 62, 75, 187, 29, 215, 80, 35, 93, 51, 94, 172, 183, 32, 194, 99, 148, 222, 6, 92, 33, 229, 185, 116, 172, 242, 131, 83, 135, 53, 30, 77, 124, 105, 174, 43, 33, 161, 193, 128, 36, 48, 58, 82, 51, 227, 210, 103, 47, 105, 249, 126, 87, 17, 147, 241, 89, 177, 138, 36, 137, 165, 73, 32, 26, 50, 205, 114, 204, 157, 129, 55, 113, 121, 14, 165, 142, 90, 10, 56, 172, 86, 191, 193, 11, 22, 83, 51, 20, 54, 52, 2, 82, 21, 21, 104, 187, 186, 182, 124, 190, 230, 82, 112, 232, 144, 223, 215, 244, 95, 63, 195, 187, 185, 35, 31, 192, 14, 138, 94, 37, 203, 220, 238, 93, 117, 6, 103, 64, 223, 91, 156, 16, 56, 209, 11, 162, 52, 189, 32, 19, 242, 96, 237, 71, 181, 143, 191, 57, 155, 11, 236, 7, 239, 137, 224, 209, 115, 15, 31, 222, 42, 218, 119, 169, 6, 32, 40, 114, 154, 211, 237, 62, 172, 235, 115, 130, 8, 244, 137, 110, 157, 63, 220, 68, 56, 162, 160, 79, 122, 172, 206, 218, 5, 255, 38, 226, 218, 209, 249, 98, 253, 192, 101, 224, 95, 176, 11, 59, 228, 237, 228, 201, 49, 177, 25, 151, 113, 226, 218, 243, 0,63, 186, 116, 47, 13, 161, 85, 242, 26, 213, 119, 89, 44, 19, 33, 9, 202, 192, 110, 3, 37, 195, 155, 231, 217, 51, 81, 6, 146, 123, 170, 21, 173, 32, 22, 111, 188, 103, 248, 23, 58, 129, 178, 109, 154, 229, 204, 253, 225, 152, 19, 243, 246, 232, 217, 71, 45, 74, 242, 159, 246, 65, 172, 43, 62, 127, 202, 134, 138, 96, 124, 182, 45, 192, 80, 7, 129, 101, 127, 80, 164, 107, 51, 182, 92, 112, 20, 129, 104, 59, 21, 11, 14, 151, 83, 34, 182, 20, 237, 99, 52, 11, 224, 69, 150, 41, 77, 125, 159, 38, 16, 128, 132, 7, 54, 135, 13, 146, 176, 112, 31, 22, 134, 93, 123, 174, 28, 147, 182, 149, 25, 150, 132, 223, 79, 210, 236, 46, 35, 119, 144, 134, 53, 99, 184, 142, 120, 245, 228, 176, 98, 210, 136, 197, 175, 82, 198, 206, 240, 93, 89, 56, 92, 4, 80, 249, 52, 233, 233, 109, 206, 242, 161, 161, 112, 82, 116, 23, 21, 57, 134, 155, 228, 197, 140, 3, 47, 244, 201, 242, 182, 108, 13, 235, 166, 216, 197, 253, 150, 169, 56, 71, 12, 127, 232, 135, 57, 146, 107, 136, 254, 191, 72, 21, 244, 127, 17, 131, 191, 127, 106, 158, 18, 201, 181, 217, 127, 187, 231, 65, 182, 32, 92, 164, 220, 200, 151, 181, 101, 3, 135, 190, 76, 5, 81, 158, 135, 78, 135, 104, 88, 126, 141, 246, 114, 228, 6, 37, 240, 66, 93, 49, 222, 231, 230, 10, 67, 88, 145, 204, 207, 6, 235, 228, 201, 166, 3, 124, 69, 205, 184, 238, 139, 56, 73, 23, 88, 30, 30, 233, 191, 163, 107, 249, 132, 0,221, 230, 75, 150, 67, 137, 67, 171, 48, 24, 205, 177, 157, 251, 70, 106, 211, 93, 43, 72, 99, 169, 228, 145, 108, 124, 214, 171, 69, 111, 157, 235, 107, 37, 70, 16, 178, 248, 166, 34, 219, 66, 69, 61, 35, 1, 4, 18, 187, 52, 39, 139, 252, 190, 157, 38, 195, 231, 251, 236, 137, 49, 57, 8, 205, 247, 75, 246, 217, 244, 96, 88, 39, 64, 11, 53, 130, 195, 153, 58, 145, 156, 178, 61, 139, 226, 119, 211, 191, 175, 190, 54, 12, 22, 91, 45, 128, 233, 253, 231, 57, 212, 6, 242, 246, 58, 112, 119, 244, 223, 59, 18, 135, 23, 159, 92, 15, 121, 31, 49, 92, 202, 171, 70, 215, 207, 21, 131, 170, 46, 139, 238, 174, 105, 64, 112, 23, 71, 25, 31, 170, 152, 236, 4, 229, 109, 5, 79, 135, 79, 131, 64, 213, 230, 190, 185, 120, 212, 220, 164, 204, 47, 235, 197, 135, 52, 246, 149, 187, 75, 4, 27, 170, 96, 124, 110, 96, 220, 30, 198, 167, 116, 160, 117, 199, 228, 14, 70, 122, 133, 40, 242, 174, 92, 100, 91, 217, 217, 184, 27, 60, 21, 222, 0,249, 158, 190, 158, 159, 139, 107, 223, 203, 85, 132, 9, 133, 154, 196, 39, 54, 147, 70, 54, 140, 59, 73, 149, 21, 225, 102, 152, 19, 191, 154, 30, 2, 187, 4, 14, 13, 51, 20, 137, 47, 13, 154, 122, 188, 207, 76, 211, 207, 170, 120, 117, 130, 182, 254, 83, 219, 163, 27, 172, 23, 80, 54, 209, 51, 96, 209, 217, 226, 17, 137, 36, 95, 0,54, 100, 79, 126, 192, 241, 125, 88, 72, 21, 59, 170, 58, 177, 24, 133, 83, 109, 250, 149, 215, 23, 238, 6, 225, 129, 120, 24, 100, 107, 245, 180, 92, 128, 111, 82, 162, 138, 17, 48, 41, 47, 221, 186, 127, 143, 78, 114, 91, 12, 11, 71, 23, 95, 165, 181, 81, 225, 205, 92, 135, 145, 137, 230, 199, 245, 2, 104, 199, 122, 183, 52, 70, 48, 58, 89, 233, 79, 51, 141, 243, 201, 41, 101, 146, 160, 67, 21, 36, 109, 93, 196, 132, 167, 226, 223, 55, 229, 55, 74, 139, 39, 2, 126, 165, 178, 52, 28, 40, 217, 130, 45, 60, 26, 11, 216, 191, 172, 207, 171, 246, 171, 37, 247, 55, 64, 117, 17, 247, 53, 104, 53, 64, 113, 42, 38, 123, 150, 117, 72, 189, 225, 21, 19, 219, 19, 182, 78, 250, 192, 85, 106, 252, 241, 241, 143, 170, 82, 19, 231, 168, 150, 56, 145, 226, 235, 149, 103, 198, 101, 87, 165, 134, 107, 49, 221, 111, 25, 65, 91, 220, 93, 8, 112, 54, 94, 244, 131, 60, 90, 222, 228, 71, 214, 235, 182, 8, 70, 156, 8, 41, 225, 18, 138, 116, 134, 39, 198, 42, 197, 200, 216, 196, 85, 168, 23, 233, 19, 136, 218, 245, 193, 135, 245, 123, 105, 12, 232, 18, 11, 146, 4, 253, 237, 39, 41, 150, 91, 31, 148, 196, 24, 181, 133, 177, 34, 41, 53, 97, 180, 66, 155, 56, 126, 183, 11, 26, 51, 63, 151, 157, 137, 4, 113, 183, 156, 17, 38, 83, 104, 50, 212, 168, 218, 54, 226, 75, 119, 148, 169, 222, 33, 60, 247, 146, 247, 204, 235, 245, 146, 104, 222, 54, 14, 67, 166, 119, 149, 49, 96, 239, 7, 193, 84, 80, 86, 249, 85, 61, 24, 52, 29, 213, 108, 168, 192, 236, 41, 205, 84, 226, 175, 5, 68, 71, 85, 39, 164, 228, 170, 249, 4, 76, 45, 8, 208, 250, 52, 48, 131, 189, 229, 240, 17, 106, 29, 152, 18, 226, 5, 159, 72, 0,4, 199, 182, 73, 61, 22, 186, 72, 181, 94, 215, 233, 116, 239, 248, 142, 176, 201, 247, 102, 56, 253, 31, 32, 167, 12, 67, 104, 28, 119, 169, 71, 38, 121, 209, 58, 185, 71, 113, 229, 178, 128, 207, 38, 88, 41, 154, 197, 1, 235, 249, 66, 108, 184, 134, 223, 38, 63, 21, 169, 120, 150, 19, 75, 215, 18, 84, 72, 8, 74, 175, 148, 27, 155, 215, 195, 190, 128, 32, 146, 3, 185, 179, 33, 186, 209, 240, 37, 90, 55, 36, 43, 200, 57, 236, 77, 78, 25, 232, 196, 32, 201, 35, 149, 130, 49, 231, 164, 182, 111, 70, 209, 38, 72, 141, 37, 75, 178, 119, 127, 223, 145, 149, 47, 190, 205, 195, 122, 187, 67, 30, 90, 107, 148, 227, 179, 113, 122, 76, 206, 126, 247, 17, 41, 150, 223, 206, 152, 132, 31, 238, 73, 175, 141, 5, 82, 181, 107, 226, 126, 34, 74, 170, 117, 181, 223, 98, 151, 125, 19, 62, 175, 196, 180, 7, 57, 169, 119, 123, 249, 161, 30, 105, 159, 213, 92, 183, 109, 145, 134, 39, 72, 84, 19, 234, 253, 94, 203, 136, 96, 169, 227, 169, 151, 47, 48, 163, 2 };

int M_Random3 ()
{
	/*const unsigned char rndtable[256]= {
0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,
    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,
    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,
    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,
    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,
    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,
    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,
    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,
    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,
    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,
    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,
    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,
    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,
    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,
    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,
    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,
    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,
    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,
    120, 163, 236, 249 };
	*/

    //rndindexA = (rndindexA+1)&0xff;
	rndindexA = (rndindexA+1)&0xfff;
	//if (debugfile) fprintf (debugfile, "MRandom3%d",rndindexA);
	//Printf("rndINDEXa: %d",rndindexA);

    return rndtable2[rndindexA];
}


//-----------
// MACROS ------------------------------------------------------------------

#define WATER_SINK_FACTOR		3
#define WATER_SINK_SMALL_FACTOR	4
#define WATER_SINK_SPEED		(FRACUNIT/2)
#define WATER_JUMP_SPEED		(FRACUNIT*7/2)

// EXTERNAL FUNCTION PROTOTYPES --------------------------------------------

void G_PlayerReborn (int player);

// PRIVATE FUNCTION PROTOTYPES ---------------------------------------------

static void PlayerLandedOnThing (AActor *mo, AActor *onmobj);

// EXTERNAL DATA DECLARATIONS ----------------------------------------------

extern cycle_t BotSupportCycles;
extern cycle_t BotWTG;
extern fixed_t attackrange;
extern int tmfloorpic;
extern sector_t *tmfloorsector;
EXTERN_CVAR (Bool, r_drawfuzz);
extern int rndindex; //ghk
EXTERN_CVAR (Int, sv_smartaim) //ghk
EXTERN_CVAR (Bool, cl_run) //ghk
EXTERN_CVAR (Int, sd_global_hiscores) //ghk
EXTERN_CVAR (Bool, sv_cheats) //ghk
EXTERN_CVAR (Int, sv_fastweapons) //ghk




// PRIVATE DATA DEFINITIONS ------------------------------------------------

static bool SpawningMapThing;
static FRandom pr_explodemissile ("ExplodeMissile");
static FRandom pr_bounce ("Bounce");
static FRandom pr_reflect ("Reflect");
static FRandom pr_nightmarerespawn ("NightmareRespawn");
static FRandom pr_botspawnmobj ("BotSpawnActor");
static FRandom pr_spawnmapthing ("SpawnMapThing");
static FRandom pr_spawnpuff ("SpawnPuff");
static FRandom pr_spawnblood ("SpawnBlood");
static FRandom pr_splatter ("BloodSplatter");
static FRandom pr_takedamage ("TakeDamage");
static FRandom pr_splat ("FAxeSplatter");
static FRandom pr_ripperblood ("RipperBlood");
static FRandom pr_chunk ("Chunk");
static FRandom pr_checkmissilespawn ("CheckMissileSpawn");
static FRandom pr_spawnmissile ("SpawnMissile");
static FRandom pr_missiledamage ("MissileDamage");
 FRandom pr_slam ("SkullSlam");
static FRandom pr_multiclasschoice ("MultiClassChoice");
static FRandom pr_rockettrail("RocketTrail");

//GHK new seed for spawning
static FRandom pr_gkspawnchance("gkchance");
//ghk COMMENT OUT FOR NOW
/*static const unsigned char rndtable[256]= {
0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,
    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,
    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,
    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,
    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,
    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,
    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,
    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,
    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,
    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,
    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,
    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,
    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,
    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,
    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,
    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,
    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,
    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,
    120, 163, 236, 249 };
*/

static const unsigned char rndtable[4096]= {75, 174, 231, 176, 184, 183, 139, 129, 216, 173, 11, 116, 171, 249, 214, 146, 95, 223, 97, 41, 101, 12, 183, 38, 239, 40, 7, 89, 178, 224, 123, 95, 253, 86, 235, 199, 94, 242, 44, 82, 239, 144, 203, 4, 133, 249, 34, 137, 117, 66, 75, 151, 202, 206, 181, 240, 9, 159, 97, 59, 80, 48, 193, 63, 52, 47, 131, 196, 187, 122, 32, 46, 123, 254, 62, 206, 198, 143, 89, 28, 253, 96, 30, 69, 22, 116, 23, 223, 60, 89, 38, 80, 77, 107, 52, 244, 144, 47, 52, 82, 165, 151, 98, 75, 64, 164, 5, 233, 129, 87, 199, 76, 66, 227, 195, 50, 182, 250, 13, 238, 11, 38, 83, 181, 144, 129, 188, 245, 20, 140, 190, 198, 198, 109, 240, 160, 226, 191, 122, 45, 227, 241, 160, 106, 185, 80, 105, 111, 211, 7, 37, 175, 74, 231, 199, 24, 165, 24, 177, 68, 16, 190, 122, 182, 176, 99, 212, 96, 31, 239, 89, 150, 152, 65, 89, 102, 148, 158, 123, 76, 253, 233, 246, 99, 251, 253, 151, 173, 193, 101, 200, 90, 72, 183, 248, 201, 46, 196, 109, 177, 68, 66, 175, 232, 110, 213, 58, 81, 138, 26, 232, 200, 34, 228, 8, 86, 108, 244, 150, 128, 5, 68, 86, 86, 103, 100, 227, 196, 218, 171, 239, 169, 242, 127, 13, 144, 54, 169, 62, 45, 223, 128, 155, 71, 189, 176, 241, 116, 141, 116, 42, 228, 251, 136, 189, 95, 161, 104, 26, 225, 242, 33, 53, 131, 19, 182, 239, 192, 236, 16, 32, 241, 181, 91, 65, 123, 81, 64, 205, 39, 143, 105, 89, 69, 105, 149, 43, 79, 166, 27, 19, 93, 103, 132, 189, 29, 22, 15, 122, 215, 25, 240, 187, 214, 148, 158, 65, 157, 19, 202, 214, 108, 191, 116, 26, 28, 66, 51, 140, 159, 200, 197, 122, 72, 49, 49, 252, 170, 106, 206, 91, 252, 112, 57, 157, 224, 53, 135, 2, 221, 226, 9, 85, 47, 160, 153, 224, 57, 244, 161, 197, 143, 108, 31, 15, 154, 228, 100, 216, 180, 62, 176, 1, 7, 185, 147, 223, 163, 142, 183, 103, 16, 127, 194, 195, 228, 71, 41, 113, 63, 234, 241, 41, 140, 173, 12, 199, 131, 134, 95, 120, 81, 117, 104, 6, 152, 242, 91, 59, 82, 32, 147, 142, 161, 244, 144, 55, 95, 246, 241, 234, 106, 77, 150, 47, 223, 79, 153, 43, 249, 152, 208, 72, 152, 230, 119, 228, 131, 177, 208, 101, 3, 122, 223, 208, 201, 85, 221, 5, 237, 247, 168, 28, 138, 9, 62, 111, 146, 229, 57, 242, 144, 119, 117, 66, 100, 214, 53, 226, 105, 199, 147, 163, 62, 15, 158, 1, 247, 167, 51, 170, 177, 186, 154, 12, 75, 13, 227, 209, 153, 67, 67, 235, 130, 227, 3, 114, 67, 179, 31, 63, 158, 38, 81, 161, 193, 58, 42, 235, 137, 29, 186, 246, 55, 42, 151, 208, 177, 212, 38, 13, 63, 30, 174, 18, 9, 220, 72, 193, 183, 16, 99, 166, 74, 254, 191, 140, 140, 138, 150, 23, 183, 134, 3, 111, 82, 78, 34, 152, 220, 36, 222, 90, 203, 2, 18, 242, 235, 173, 148, 251, 172, 221, 176, 221, 196, 45, 207, 102, 42, 83, 75, 189, 203, 1, 4, 246, 52, 35, 216, 250, 10, 17, 242, 106, 110, 121, 222, 76, 79, 70, 92, 23, 49, 235, 66, 180, 61, 207, 34, 160, 56, 111, 226, 23, 139, 239, 105, 182, 200, 181, 37, 138, 212, 66, 110, 162, 102, 118, 222, 231, 200, 200, 31, 182, 112, 155, 46, 50, 155, 55, 191, 238, 50, 83, 70, 202, 238, 46, 18, 67, 74, 126, 44, 159, 180, 116, 210, 142, 110, 1, 240, 191, 176, 100, 142, 252, 236, 225, 240, 6, 155, 254, 12, 99, 122, 85, 12, 185, 17, 126, 214, 8, 31, 253, 245, 107, 195, 63, 177, 155, 97, 31, 10, 91, 175, 95, 238, 133, 247, 130, 58, 54, 53, 120, 250, 195, 161, 56, 19, 249, 95, 67, 146, 232, 241, 149, 222, 69, 190, 20, 127, 12, 40, 5, 108, 108, 146, 113, 192, 183, 105, 132, 253, 15, 55, 71, 133, 31, 241, 248, 98, 20, 11, 110, 100, 45, 9, 166, 68, 59, 67, 133, 168, 50, 224, 123, 42, 178, 93, 85, 162, 69, 158, 246, 189, 82, 47, 76, 96, 167, 55, 215, 69, 131, 187, 182, 54, 166, 227, 231, 110, 223, 82, 198, 230, 228, 72, 140, 222, 23, 151, 153, 121, 248, 173, 227, 23, 168, 132, 192, 242, 198, 202, 164, 167, 119, 129, 8, 128, 24, 14, 8, 195, 90, 21, 115, 216, 57, 99, 112, 174, 15, 226, 182, 212, 181, 223, 145, 145, 75, 222, 161, 133, 120, 214, 73, 181, 210, 0,60, 81, 218, 62, 129, 50, 180, 216, 143, 211, 118, 104, 182, 131, 55, 199, 97, 147, 199, 110, 247, 171, 249, 195, 75, 192, 224, 230, 149, 182, 101, 234, 7, 145, 200, 174, 188, 217, 109, 84, 203, 250, 80, 230, 177, 138, 53, 202, 28, 200, 97, 120, 131, 39, 36, 121, 98, 88, 32, 170, 75, 42, 114, 171, 47, 137, 100, 176, 100, 2, 68, 37, 7, 149, 94, 51, 35, 239, 216, 185, 13, 225, 107, 60, 8, 151, 94, 39, 243, 8, 111, 5, 104, 41, 107, 89, 254, 164, 59, 141, 7, 63, 74, 149, 22, 159, 206, 15, 40, 219, 119, 65, 18, 11, 132, 147, 3, 46, 11, 58, 216, 198, 116, 79, 175, 253, 241, 232, 249, 121, 145, 156, 238, 225, 49, 153, 192, 165, 99, 145, 97, 178, 140, 186, 13, 215, 80, 167, 19, 200, 77, 254, 92, 58, 216, 232, 123, 4, 21, 156, 203, 15, 72, 154, 62, 168, 219, 20, 11, 213, 164, 81, 94, 144, 153, 61, 129, 34, 245, 238, 179, 63, 59, 139, 27, 109, 35, 251, 190, 197, 208, 182, 127, 94, 4, 69, 72, 165, 42, 83, 180, 84, 93, 205, 78, 6, 70, 243, 96, 52, 239, 102, 56, 236, 69, 217, 39, 197, 205, 134, 90, 90, 205, 107, 239, 28, 147, 52, 47, 115, 12, 215, 252, 212, 76, 24, 226, 22, 188, 167, 28, 44, 14, 7, 9, 130, 235, 46, 110, 55, 155, 167, 160, 254, 97, 17, 126, 186, 152, 242, 192, 155, 206, 80, 166, 108, 31, 188, 132, 113, 75, 149, 254, 163, 189, 130, 29, 16, 174, 180, 91, 189, 50, 36, 38, 249, 203, 144, 4, 176, 111, 87, 140, 73, 172, 221, 59, 166, 169, 238, 179, 247, 68, 129, 188, 145, 144, 59, 181, 86, 53, 100, 181, 12, 241, 51, 200, 178, 182, 23, 1, 254, 83, 29, 66, 52, 156, 149, 142, 220, 91, 234, 191, 113, 26, 255, 68, 112, 7, 125, 88, 79, 199, 31, 204, 134, 7, 133, 251, 17, 245, 9, 25, 244, 199, 191, 78, 202, 94, 64, 128, 202, 247, 167, 166, 142, 192, 15, 212, 164, 147, 247, 14, 251, 246, 20, 212, 115, 201, 145, 88, 28, 134, 51, 189, 53, 65, 145, 177, 166, 207, 92, 1, 98, 141, 186, 71, 35, 78, 228, 81, 34, 226, 119, 215, 118, 141, 97, 137, 119, 77, 23, 94, 212, 205, 55, 37, 251, 8, 22, 33, 52, 119, 93, 84, 225, 174, 132, 204, 165, 214, 254, 210, 78, 102, 220, 113, 57, 192, 243, 23, 66, 63, 237, 138, 85, 23, 68, 128, 164, 101, 155, 91, 160, 84, 51, 149, 44, 228, 150, 84, 233, 142, 119, 123, 42, 21, 90, 71, 176, 159, 168, 56, 137, 244, 15, 154, 45, 86, 2, 105, 109, 4, 20, 201, 9, 236, 2, 120, 86, 107, 95, 223, 34, 38, 146, 138, 180, 123, 231, 180, 5, 189, 176, 157, 60, 204, 215, 27, 253, 35, 197, 152, 125, 158, 47, 88, 229, 163, 43, 80, 134, 39, 18, 123, 24, 110, 144, 175, 142, 248, 2, 124, 43, 42, 45, 138, 248, 190, 154, 51, 89, 252, 1, 216, 42, 224, 175, 143, 185, 61, 140, 79, 0,217, 207, 170, 172, 51, 193, 157, 225, 79, 155, 134, 46, 151, 23, 192, 192, 54, 100, 174, 223, 196, 245, 57, 125, 145, 11, 245, 252, 182, 255, 11, 129, 157, 20, 19, 148, 91, 213, 219, 137, 102, 95, 218, 191, 207, 90, 157, 240, 39, 6, 72, 155, 128, 164, 130, 248, 249, 62, 162, 76, 81, 29, 65, 208, 152, 88, 105, 87, 75, 106, 223, 111, 81, 36, 218, 2, 97, 58, 126, 114, 107, 93, 57, 156, 88, 0,229, 155, 141, 231, 32, 213, 229, 59, 216, 153, 248, 1, 155, 136, 129, 226, 88, 57, 155, 167, 190, 154, 143, 243, 100, 52, 80, 223, 253, 218, 216, 92, 246, 41, 205, 162, 132, 6, 109, 180, 39, 122, 38, 134, 58, 73, 116, 114, 196, 41, 203, 133, 79, 246, 128, 155, 217, 220, 117, 99, 104, 79, 109, 35, 216, 171, 118, 155, 202, 115, 214, 98, 114, 95, 61, 221, 41, 1, 180, 114, 75, 69, 41, 116, 226, 227, 173, 67, 17, 194, 226, 38, 228, 82, 34, 192, 180, 62, 223, 112, 113, 16, 18, 99, 180, 22, 196, 35, 130, 97, 75, 240, 196, 186, 199, 189, 150, 83, 144, 85, 76, 31, 94, 26, 10, 58, 163, 216, 107, 11, 172, 66, 83, 145, 97, 26, 157, 33, 165, 126, 201, 155, 89, 131, 23, 134, 207, 243, 202, 106, 152, 59, 123, 130, 1, 108, 98, 53, 127, 183, 138, 150, 167, 22, 197, 34, 230, 110, 216, 205, 99, 83, 82, 227, 244, 87, 196, 84, 253, 239, 222, 210, 81, 62, 39, 143, 19, 78, 117, 106, 157, 1, 126, 67, 244, 102, 238, 77, 118, 79, 144, 141, 144, 165, 238, 43, 76, 132, 191, 172, 114, 9, 41, 67, 214, 164, 138, 231, 34, 2, 23, 85, 6, 162, 5, 21, 113, 5, 103, 42, 161, 117, 47, 132, 136, 197, 213, 30, 0,155, 126, 82, 180, 140, 56, 82, 134, 22, 253, 105, 85, 31, 239, 99, 222, 6, 224, 184, 96, 42, 17, 204, 11, 98, 98, 100, 101, 55, 211, 97, 199, 121, 78, 235, 250, 121, 71, 124, 234, 62, 152, 157, 6, 30, 74, 208, 168, 128, 207, 199, 77, 215, 49, 241, 241, 160, 97, 124, 55, 216, 177, 16, 78, 90, 231, 230, 175, 120, 255, 119, 233, 170, 16, 113, 152, 34, 27, 196, 189, 6, 185, 76, 53, 108, 207, 233, 1, 74, 107, 21, 123, 84, 229, 119, 80, 37, 65, 159, 62, 19, 111, 188, 58, 237, 224, 44, 147, 3, 79, 177, 22, 25, 38, 140, 240, 125, 82, 201, 98, 194, 144, 255, 213, 192, 119, 22, 254, 3, 159, 193, 20, 51, 70, 86, 11, 0,172, 159, 244, 146, 86, 241, 67, 251, 238, 8, 212, 242, 83, 214, 10, 191, 175, 110, 5, 143, 46, 213, 153, 45, 237, 243, 234, 211, 82, 238, 249, 225, 226, 161, 200, 42, 236, 159, 172, 36, 51, 192, 162, 93, 191, 50, 70, 132, 190, 10, 27, 178, 1, 140, 83, 255, 77, 183, 80, 3, 56, 28, 59, 123, 158, 194, 5, 114, 42, 187, 22, 230, 140, 194, 165, 146, 52, 200, 146, 101, 73, 67, 244, 10, 184, 184, 110, 72, 233, 144, 107, 18, 113, 234, 17, 189, 204, 61, 155, 106, 199, 128, 88, 111, 127, 226, 34, 131, 149, 125, 161, 137, 54, 236, 240, 9, 227, 125, 154, 219, 15, 106, 6, 24, 132, 177, 116, 7, 145, 48, 214, 180, 175, 8, 99, 239, 47, 203, 248, 87, 236, 155, 172, 236, 203, 15, 230, 162, 249, 223, 153, 99, 119, 60, 209, 164, 132, 26, 7, 190, 227, 18, 232, 31, 199, 35, 127, 13, 83, 61, 143, 195, 130, 126, 10, 158, 240, 252, 95, 112, 208, 67, 23, 110, 225, 240, 241, 186, 198, 109, 65, 59, 123, 101, 204, 104, 249, 120, 199, 149, 105, 147, 246, 168, 59, 128, 243, 67, 177, 166, 10, 29, 59, 44, 206, 197, 228, 136, 190, 11, 227, 35, 227, 227, 233, 176, 85, 80, 130, 229, 237, 113, 38, 140, 83, 230, 47, 43, 153, 216, 1, 52, 116, 12, 1, 53, 229, 252, 4, 127, 209, 107, 237, 176, 165, 138, 6, 176, 137, 219, 122, 21, 52, 210, 45, 77, 130, 120, 138, 160, 116, 180, 191, 214, 4, 69, 254, 81, 143, 65, 254, 117, 72, 147, 238, 144, 33, 24, 135, 208, 58, 222, 161, 98, 179, 166, 255, 168, 4, 205, 164, 74, 206, 196, 249, 223, 42, 156, 155, 74, 232, 107, 101, 15, 78, 19, 163, 150, 6, 100, 242, 220, 216, 198, 108, 241, 214, 70, 51, 160, 33, 100, 93, 198, 152, 22, 110, 20, 221, 28, 107, 121, 24, 82, 110, 31, 226, 136, 117, 120, 136, 91, 179, 249, 141, 164, 76, 17, 23, 106, 227, 46, 83, 158, 182, 22, 117, 140, 84, 67, 80, 172, 31, 198, 173, 91, 7, 7, 225, 35, 182, 154, 15, 94, 134, 214, 146, 115, 60, 212, 4, 89, 100, 72, 232, 224, 178, 8, 11, 237, 85, 28, 231, 254, 175, 233, 65, 76, 40, 97, 74, 82, 30, 34, 35, 228, 26, 38, 199, 164, 140, 243, 119, 92, 56, 36, 241, 231, 106, 231, 146, 29, 218, 65, 116, 181, 198, 224, 84, 90, 105, 227, 194, 196, 128, 62, 159, 94, 240, 83, 137, 229, 237, 228, 31, 107, 64, 191, 97, 98, 110, 106, 163, 157, 139, 161, 166, 205, 110, 178, 110, 128, 209, 130, 103, 160, 205, 181, 31, 81, 134, 114, 202, 45, 186, 61, 52, 35, 48, 163, 121, 202, 93, 219, 73, 82, 17, 8, 200, 72, 245, 105, 124, 9, 240, 220, 200, 251, 77, 179, 173, 192, 177, 123, 107, 2, 133, 75, 127, 244, 68, 233, 110, 128, 194, 141, 75, 131, 24, 244, 181, 20, 37, 81, 113, 102, 42, 216, 57, 150, 20, 216, 181, 200, 72, 188, 206, 3, 226, 247, 150, 150, 48, 129, 83, 35, 48, 128, 194, 27, 151, 177, 14, 52, 158, 116, 37, 64, 79, 145, 84, 210, 197, 132, 50, 129, 3, 146, 177, 181, 114, 222, 92, 181, 86, 183, 57, 38, 152, 84, 229, 42, 83, 168, 178, 47, 147, 88, 115, 196, 111, 116, 191, 237, 140, 99, 24, 35, 159, 86, 69, 136, 45, 175, 188, 229, 56, 247, 160, 175, 235, 118, 24, 165, 155, 244, 121, 177, 168, 254, 155, 59, 235, 172, 58, 124, 87, 58, 13, 98, 67, 156, 130, 33, 239, 201, 177, 214, 43, 211, 23, 175, 243, 138, 58, 107, 84, 61, 36, 122, 36, 28, 222, 212, 203, 197, 221, 32, 78, 249, 80, 23, 33, 162, 195, 227, 70, 25, 123, 191, 74, 73, 36, 57, 108, 29, 57, 130, 54, 198, 156, 134, 90, 153, 96, 190, 75, 143, 169, 131, 152, 6, 238, 22, 89, 9, 155, 189, 118, 53, 40, 22, 173, 69, 112, 27, 96, 140, 218, 154, 84, 199, 99, 116, 84, 83, 68, 113, 182, 71, 70, 145, 77, 195, 48, 90, 31, 197, 235, 43, 201, 186, 75, 123, 213, 108, 41, 186, 197, 57, 210, 208, 218, 2, 79, 50, 192, 18, 16, 67, 118, 247, 18, 238, 181, 104, 68, 98, 29, 90, 59, 133, 29, 236, 1, 238, 104, 28, 171, 44, 87, 240, 13, 172, 24, 149, 128, 228, 27, 200, 70, 57, 100, 36, 99, 180, 196, 7, 53, 209, 20, 72, 80, 136, 165, 144, 44, 63, 27, 179, 105, 139, 175, 157, 60, 100, 187, 21, 152, 17, 24, 21, 75, 25, 98, 168, 17, 104, 212, 217, 22, 81, 194, 202, 6, 29, 2, 10, 247, 189, 237, 23, 19, 148, 165, 50, 174, 94, 91, 220, 48, 8, 83, 248, 126, 184, 40, 225, 59, 53, 161, 213, 113, 177, 6, 194, 98, 98, 131, 185, 147, 43, 151, 116, 248, 129, 231, 211, 87, 237, 52, 166, 145, 138, 52, 219, 157, 147, 91, 18, 82, 103, 129, 114, 248, 79, 63, 247, 239, 248, 183, 154, 50, 236, 62, 75, 187, 29, 215, 80, 35, 93, 51, 94, 172, 183, 32, 194, 99, 148, 222, 6, 92, 33, 229, 185, 116, 172, 242, 131, 83, 135, 53, 30, 77, 124, 105, 174, 43, 33, 161, 193, 128, 36, 48, 58, 82, 51, 227, 210, 103, 47, 105, 249, 126, 87, 17, 147, 241, 89, 177, 138, 36, 137, 165, 73, 32, 26, 50, 205, 114, 204, 157, 129, 55, 113, 121, 14, 165, 142, 90, 10, 56, 172, 86, 191, 193, 11, 22, 83, 51, 20, 54, 52, 2, 82, 21, 21, 104, 187, 186, 182, 124, 190, 230, 82, 112, 232, 144, 223, 215, 244, 95, 63, 195, 187, 185, 35, 31, 192, 14, 138, 94, 37, 203, 220, 238, 93, 117, 6, 103, 64, 223, 91, 156, 16, 56, 209, 11, 162, 52, 189, 32, 19, 242, 96, 237, 71, 181, 143, 191, 57, 155, 11, 236, 7, 239, 137, 224, 209, 115, 15, 31, 222, 42, 218, 119, 169, 6, 32, 40, 114, 154, 211, 237, 62, 172, 235, 115, 130, 8, 244, 137, 110, 157, 63, 220, 68, 56, 162, 160, 79, 122, 172, 206, 218, 5, 255, 38, 226, 218, 209, 249, 98, 253, 192, 101, 224, 95, 176, 11, 59, 228, 237, 228, 201, 49, 177, 25, 151, 113, 226, 218, 243, 0,63, 186, 116, 47, 13, 161, 85, 242, 26, 213, 119, 89, 44, 19, 33, 9, 202, 192, 110, 3, 37, 195, 155, 231, 217, 51, 81, 6, 146, 123, 170, 21, 173, 32, 22, 111, 188, 103, 248, 23, 58, 129, 178, 109, 154, 229, 204, 253, 225, 152, 19, 243, 246, 232, 217, 71, 45, 74, 242, 159, 246, 65, 172, 43, 62, 127, 202, 134, 138, 96, 124, 182, 45, 192, 80, 7, 129, 101, 127, 80, 164, 107, 51, 182, 92, 112, 20, 129, 104, 59, 21, 11, 14, 151, 83, 34, 182, 20, 237, 99, 52, 11, 224, 69, 150, 41, 77, 125, 159, 38, 16, 128, 132, 7, 54, 135, 13, 146, 176, 112, 31, 22, 134, 93, 123, 174, 28, 147, 182, 149, 25, 150, 132, 223, 79, 210, 236, 46, 35, 119, 144, 134, 53, 99, 184, 142, 120, 245, 228, 176, 98, 210, 136, 197, 175, 82, 198, 206, 240, 93, 89, 56, 92, 4, 80, 249, 52, 233, 233, 109, 206, 242, 161, 161, 112, 82, 116, 23, 21, 57, 134, 155, 228, 197, 140, 3, 47, 244, 201, 242, 182, 108, 13, 235, 166, 216, 197, 253, 150, 169, 56, 71, 12, 127, 232, 135, 57, 146, 107, 136, 254, 191, 72, 21, 244, 127, 17, 131, 191, 127, 106, 158, 18, 201, 181, 217, 127, 187, 231, 65, 182, 32, 92, 164, 220, 200, 151, 181, 101, 3, 135, 190, 76, 5, 81, 158, 135, 78, 135, 104, 88, 126, 141, 246, 114, 228, 6, 37, 240, 66, 93, 49, 222, 231, 230, 10, 67, 88, 145, 204, 207, 6, 235, 228, 201, 166, 3, 124, 69, 205, 184, 238, 139, 56, 73, 23, 88, 30, 30, 233, 191, 163, 107, 249, 132, 0,221, 230, 75, 150, 67, 137, 67, 171, 48, 24, 205, 177, 157, 251, 70, 106, 211, 93, 43, 72, 99, 169, 228, 145, 108, 124, 214, 171, 69, 111, 157, 235, 107, 37, 70, 16, 178, 248, 166, 34, 219, 66, 69, 61, 35, 1, 4, 18, 187, 52, 39, 139, 252, 190, 157, 38, 195, 231, 251, 236, 137, 49, 57, 8, 205, 247, 75, 246, 217, 244, 96, 88, 39, 64, 11, 53, 130, 195, 153, 58, 145, 156, 178, 61, 139, 226, 119, 211, 191, 175, 190, 54, 12, 22, 91, 45, 128, 233, 253, 231, 57, 212, 6, 242, 246, 58, 112, 119, 244, 223, 59, 18, 135, 23, 159, 92, 15, 121, 31, 49, 92, 202, 171, 70, 215, 207, 21, 131, 170, 46, 139, 238, 174, 105, 64, 112, 23, 71, 25, 31, 170, 152, 236, 4, 229, 109, 5, 79, 135, 79, 131, 64, 213, 230, 190, 185, 120, 212, 220, 164, 204, 47, 235, 197, 135, 52, 246, 149, 187, 75, 4, 27, 170, 96, 124, 110, 96, 220, 30, 198, 167, 116, 160, 117, 199, 228, 14, 70, 122, 133, 40, 242, 174, 92, 100, 91, 217, 217, 184, 27, 60, 21, 222, 0,249, 158, 190, 158, 159, 139, 107, 223, 203, 85, 132, 9, 133, 154, 196, 39, 54, 147, 70, 54, 140, 59, 73, 149, 21, 225, 102, 152, 19, 191, 154, 30, 2, 187, 4, 14, 13, 51, 20, 137, 47, 13, 154, 122, 188, 207, 76, 211, 207, 170, 120, 117, 130, 182, 254, 83, 219, 163, 27, 172, 23, 80, 54, 209, 51, 96, 209, 217, 226, 17, 137, 36, 95, 0,54, 100, 79, 126, 192, 241, 125, 88, 72, 21, 59, 170, 58, 177, 24, 133, 83, 109, 250, 149, 215, 23, 238, 6, 225, 129, 120, 24, 100, 107, 245, 180, 92, 128, 111, 82, 162, 138, 17, 48, 41, 47, 221, 186, 127, 143, 78, 114, 91, 12, 11, 71, 23, 95, 165, 181, 81, 225, 205, 92, 135, 145, 137, 230, 199, 245, 2, 104, 199, 122, 183, 52, 70, 48, 58, 89, 233, 79, 51, 141, 243, 201, 41, 101, 146, 160, 67, 21, 36, 109, 93, 196, 132, 167, 226, 223, 55, 229, 55, 74, 139, 39, 2, 126, 165, 178, 52, 28, 40, 217, 130, 45, 60, 26, 11, 216, 191, 172, 207, 171, 246, 171, 37, 247, 55, 64, 117, 17, 247, 53, 104, 53, 64, 113, 42, 38, 123, 150, 117, 72, 189, 225, 21, 19, 219, 19, 182, 78, 250, 192, 85, 106, 252, 241, 241, 143, 170, 82, 19, 231, 168, 150, 56, 145, 226, 235, 149, 103, 198, 101, 87, 165, 134, 107, 49, 221, 111, 25, 65, 91, 220, 93, 8, 112, 54, 94, 244, 131, 60, 90, 222, 228, 71, 214, 235, 182, 8, 70, 156, 8, 41, 225, 18, 138, 116, 134, 39, 198, 42, 197, 200, 216, 196, 85, 168, 23, 233, 19, 136, 218, 245, 193, 135, 245, 123, 105, 12, 232, 18, 11, 146, 4, 253, 237, 39, 41, 150, 91, 31, 148, 196, 24, 181, 133, 177, 34, 41, 53, 97, 180, 66, 155, 56, 126, 183, 11, 26, 51, 63, 151, 157, 137, 4, 113, 183, 156, 17, 38, 83, 104, 50, 212, 168, 218, 54, 226, 75, 119, 148, 169, 222, 33, 60, 247, 146, 247, 204, 235, 245, 146, 104, 222, 54, 14, 67, 166, 119, 149, 49, 96, 239, 7, 193, 84, 80, 86, 249, 85, 61, 24, 52, 29, 213, 108, 168, 192, 236, 41, 205, 84, 226, 175, 5, 68, 71, 85, 39, 164, 228, 170, 249, 4, 76, 45, 8, 208, 250, 52, 48, 131, 189, 229, 240, 17, 106, 29, 152, 18, 226, 5, 159, 72, 0,4, 199, 182, 73, 61, 22, 186, 72, 181, 94, 215, 233, 116, 239, 248, 142, 176, 201, 247, 102, 56, 253, 31, 32, 167, 12, 67, 104, 28, 119, 169, 71, 38, 121, 209, 58, 185, 71, 113, 229, 178, 128, 207, 38, 88, 41, 154, 197, 1, 235, 249, 66, 108, 184, 134, 223, 38, 63, 21, 169, 120, 150, 19, 75, 215, 18, 84, 72, 8, 74, 175, 148, 27, 155, 215, 195, 190, 128, 32, 146, 3, 185, 179, 33, 186, 209, 240, 37, 90, 55, 36, 43, 200, 57, 236, 77, 78, 25, 232, 196, 32, 201, 35, 149, 130, 49, 231, 164, 182, 111, 70, 209, 38, 72, 141, 37, 75, 178, 119, 127, 223, 145, 149, 47, 190, 205, 195, 122, 187, 67, 30, 90, 107, 148, 227, 179, 113, 122, 76, 206, 126, 247, 17, 41, 150, 223, 206, 152, 132, 31, 238, 73, 175, 141, 5, 82, 181, 107, 226, 126, 34, 74, 170, 117, 181, 223, 98, 151, 125, 19, 62, 175, 196, 180, 7, 57, 169, 119, 123, 249, 161, 30, 105, 159, 213, 92, 183, 109, 145, 134, 39, 72, 84, 19, 234, 253, 94, 203, 136, 96, 169, 227, 169, 151, 47, 48, 163, 2 };

// PUBLIC DATA DEFINITIONS -------------------------------------------------

FRandom pr_spawnmobj ("SpawnActor");

CUSTOM_CVAR (Float, sv_gravity, 800.f, CVAR_SERVERINFO|CVAR_NOSAVE)
{
	level.gravity = self;
}

CVAR (Bool, cl_missiledecals, true, CVAR_ARCHIVE)
CVAR (Bool, addrocketexplosion, false, CVAR_ARCHIVE)

CVAR (Bool, sp_random_custom_monsters, false, CVAR_ARCHIVE) //GHK: console var for displaying p_random or m_random custom monsters
											   //M_Random: used for hi scores (static distribution depending on difficulty, or
											   //P_Random: random distribution per play, not good for hi scores.

CVAR (Bool, sp_random_custom_monsters2, false, CVAR_ARCHIVE)

CVAR (Bool, sd_alt_con_scoring,true,CVAR_ARCHIVE)  //GHK: Double Shotty Fix console messages

fixed_t FloatBobOffsets[64] =
{
	0, 51389, 102283, 152192,
	200636, 247147, 291278, 332604,
	370727, 405280, 435929, 462380,
	484378, 501712, 514213, 521763,
	524287, 521763, 514213, 501712,
	484378, 462380, 435929, 405280,
	370727, 332604, 291278, 247147,
	200636, 152192, 102283, 51389,
	-1, -51390, -102284, -152193,
	-200637, -247148, -291279, -332605,
	-370728, -405281, -435930, -462381,
	-484380, -501713, -514215, -521764,
	-524288, -521764, -514214, -501713,
	-484379, -462381, -435930, -405280,
	-370728, -332605, -291279, -247148,
	-200637, -152193, -102284, -51389
};

fixed_t FloatBobDiffs[64] =
{
	51389, 51389, 50894, 49909, 48444,
	46511, 44131, 41326, 38123,
	34553, 30649, 26451, 21998,
	17334, 12501, 7550, 2524,
	-2524, -7550, -12501, -17334,
	-21998, -26451, -30649, -34553,
	-38123, -41326, -44131, -46511,
	-48444, -49909, -50894, -51390,
	-51389, -50894, -49909, -48444,
	-46511, -44131, -41326, -38123,
	-34553, -30649, -26451, -21999,
	-17333, -12502, -7549, -2524,
	2524, 7550, 12501, 17334,
	21998, 26451, 30650, 34552,
	38123, 41326, 44131, 46511,
	48444, 49909, 50895
};

CVAR (Int, cl_pufftype, 0, CVAR_ARCHIVE);
CVAR (Int, cl_bloodtype, 0, CVAR_ARCHIVE);

AActor *MissileActor;
AActor *PuffSpawned;

// CODE --------------------------------------------------------------------

//GHK
int M_Random2 ()
{
	//Printf (PRINT_MEDIUM, "%s%d\n","PMOBJ:",rndindex);
   // rndindex = (rndindex+1)&0xff;
	rndindex = (rndindex+1)&0xfff;
    return rndtable[rndindex];
}


IMPLEMENT_POINTY_CLASS (AActor)
 DECLARE_POINTER (target)
 DECLARE_POINTER (lastenemy)
 DECLARE_POINTER (tracer)
 DECLARE_POINTER (goal)
 DECLARE_POINTER (LastLook)	// This is actually a union
 DECLARE_POINTER (Inventory)
 DECLARE_POINTER (LastHeard)
 DECLARE_POINTER (master)
END_POINTERS

AActor::~AActor ()
{
	// Please avoid calling the destructor directly (or through delete)!
	// Use Destroy() instead.
}

void AActor::Serialize (FArchive &arc)
{
	Super::Serialize (arc);

	if (arc.IsStoring ())
	{
		arc.WriteSprite (sprite);
	}
	else
	{
		sprite = arc.ReadSprite ();
	}

	arc << x
		<< y
		<< z
		<< angle
		<< frame
		<< scaleX
		<< scaleY
		<< RenderStyle
		<< renderflags;
	if (arc.IsStoring ())
	{
		BYTE ff;
		if (picnum == 0xFFFF)
		{
			ff = 0xFF;
			arc << ff;
		}
		else
		{
			ff = 0;
			arc << ff;
			TexMan.WriteTexture (arc, picnum);
		}
		TexMan.WriteTexture (arc, floorpic);
		TexMan.WriteTexture (arc, ceilingpic);
	}
	else
	{
		BYTE ff;
		arc << ff;
		if (ff == 0xFF)
		{
			picnum = 0xFFFF;
		}
		else
		{
			picnum = TexMan.ReadTexture (arc);
		}
		floorpic = TexMan.ReadTexture (arc);
		ceilingpic = TexMan.ReadTexture (arc);
	}
	arc << TIDtoHate;
	if (TIDtoHate == 0)
	{
		arc << LastLook.PlayerNumber;
	}
	else
	{
		arc << LastLook.Actor;
	}
	arc << effects
		<< alpha
		<< alphacolor
		<< pitch
		<< roll
		<< Sector
		<< floorz
		<< ceilingz
		<< dropoffz
		<< floorsector
		<< ceilingsector
		<< radius
		<< height
		<< momx
		<< momy
		<< momz
		<< tics
		<< state
		<< Damage
		<< flags
		<< flags2
		<< flags3
		<< flags4
		<< flags5
		<< special1
		<< special2
		<< health
		<< movedir
		<< visdir
		<< movecount
		<< target
		<< lastenemy
		<< LastHeard
		<< reactiontime
		<< threshold
		<< player
		<< SpawnPoint[0] << SpawnPoint[1] << SpawnPoint[2]
		<< SpawnAngle
		<< tracer
		<< floorclip
		<< tid
		<< special
		<< args[0] << args[1] << args[2] << args[3] << args[4]
		<< goal
		<< waterlevel
		<< MinMissileChance
		<< SpawnFlags
		<< Inventory
		<< InventoryID
		<< id
		<< FloatBobPhase
		<< Translation
		<< AR_SOUNDW(SeeSound)
		<< AR_SOUNDW(AttackSound)
		<< AR_SOUNDW(PainSound)
		<< AR_SOUNDW(DeathSound)
		<< AR_SOUNDW(ActiveSound)
		<< AR_SOUNDW(UseSound)
		<< Speed
		<< FloatSpeed
		<< Mass
		<< PainChance
		<< SpawnState
		<< SeeState
		<< MeleeState
		<< MissileState
		<< MaxDropOffHeight
		<< MaxStepHeight
		<< bouncefactor
		<< bouncecount
		<< maxtargetrange
		<< meleethreshold
		<< meleerange
		<< DamageType
		<< gravity
		<< SDParentPClass<<origx<<origy<<origz; //ghk

	if (arc.IsStoring ())
	{
		int convnum = 0;
		unsigned int i;

		if (Conversation != NULL)
		{
			for (i = 0; i < StrifeDialogues.Size(); ++i)
			{
				if (StrifeDialogues[i] == GetDefault()->Conversation)
				{
					break;
				}
			}
			for (; i + convnum < StrifeDialogues.Size(); ++convnum)
			{
				if (StrifeDialogues[i + convnum] == Conversation)
				{
					break;
				}
			}
			if (i + convnum < StrifeDialogues.Size())
			{
				convnum++;
			}
			else
			{
				convnum = 0;
			}
		}
		arc.WriteCount (convnum);
	}
	else
	{
		int convnum;
		unsigned int i;

		convnum = arc.ReadCount();
		if (convnum == 0 || GetDefault()->Conversation == NULL)
		{
			Conversation = NULL;
		}
		else
		{
			for (i = 0; i < StrifeDialogues.Size(); ++i)
			{
				if (StrifeDialogues[i] == GetDefault()->Conversation)
				{
					break;
				}
			}
			if (i + convnum <= StrifeDialogues.Size())
			{
				Conversation = StrifeDialogues[i + convnum - 1];
			}
			else
			{
				Conversation = GetDefault()->Conversation;
			}
		}
	}

	if (arc.IsLoading ())
	{
		touching_sectorlist = NULL;
		LinkToWorld (Sector);
		AddToHash ();
		SetShade (alphacolor);
		if (player)
		{
			if (playeringame[player - players] &&
				player->cls != NULL &&
				state->sprite.index ==
				GetDefaultByType (player->cls)->SpawnState->sprite.index)
			{ // Give player back the skin
				sprite = skins[player->userinfo.skin].sprite;
				scaleX = scaleY = skins[player->userinfo.skin].Scale;
			}
			if (Speed == 0)
			{
				Speed = GetDefault()->Speed;
			}
		}
		PrevX = x;
		PrevY = y;
		PrevZ = z;
		UpdateWaterLevel(z, false);
	}
}

void MapThing::Serialize (FArchive &arc)
{
	arc << thingid << x << y << z << angle << type << flags << special
		<< args[0] << args[1] << args[2] << args[3] << args[4];
}

AActor::AActor () throw()
{
}

AActor::AActor (const AActor &other) throw()
{
	memcpy (&x, &other.x, (BYTE *)&this[1] - (BYTE *)&x);
}

AActor &AActor::operator= (const AActor &other)
{
	memcpy (&x, &other.x, (BYTE *)&this[1] - (BYTE *)&x);
	return *this;
}

//==========================================================================
//
// AActor::InStateSequence
//
// Checks whether the current state is in a contiguous sequence that
// starts with basestate
//
//==========================================================================

bool AActor::InStateSequence(FState * newstate, FState * basestate)
{
	if (basestate == NULL) return false;

	FState * thisstate = basestate;
	do
	{
		if (newstate == thisstate) return true;
		basestate = thisstate;
		thisstate = thisstate->GetNextState();
	}
	while (thisstate == basestate+1);
	return false;
}

//==========================================================================
//
// AActor::GetTics
//
// Get the actual duration of the next state
// This is a more generalized attempt to make the Demon faster in
// nightmare mode. Actually changing the states' durations has to
// be considered highly problematic.
//
//==========================================================================

int AActor::GetTics(FState * newstate)
{
	int tics = newstate->GetTics();

	if (isFast())
	{
		if (flags5 & MF5_FASTER)
		{
			if (InStateSequence(newstate, SeeState)) return tics - (tics>>1);
		}
		if (flags5 & MF5_FASTMELEE)
		{
			if (InStateSequence(newstate, MeleeState)) return tics - (tics>>1);
		}
	}
	return tics;
}

//==========================================================================
//
// AActor::SetState
//
// Returns true if the mobj is still present.
//
//==========================================================================

bool AActor::SetState (FState *newstate)
{
	if (debugfile && player && (player->cheats & CF_PREDICTING))
		fprintf (debugfile, "for pl %d: SetState while predicting!\n", player-players);
	do
	{
		if (newstate == NULL)
		{
			state = NULL;
			Destroy ();
			return false;
		}
		int prevsprite, newsprite;

		if (state != NULL)
		{
			prevsprite = state->sprite.index;
		}
		else
		{
			prevsprite = -1;
		}
		state = newstate;
		tics = GetTics(newstate);
		renderflags = (renderflags & ~RF_FULLBRIGHT) | newstate->GetFullbright();
		newsprite = newstate->sprite.index;
		if (newsprite != 1)
		{
			// Sprite 1 is ----, which means "do not change the sprite"
			frame = newstate->GetFrame();

			if (!(flags4 & MF4_NOSKIN) && newsprite == SpawnState->sprite.index)
			{ // [RH] If the new sprite is the same as the original sprite, and
			// this actor is attached to a player, use the player's skin's
			// sprite. If a player is not attached, do not change the sprite
			// unless it is different from the previous state's sprite; a
			// player may have been attached, died, and respawned elsewhere,
			// and we do not want to lose the skin on the body. If it wasn't
			// for Dehacked, I would move sprite changing out of the states
			// altogether, since actors rarely change their sprites after
			// spawning.
				if (player != NULL)
				{
					sprite = skins[player->userinfo.skin].sprite;
				}
				else if (newsprite != prevsprite)
				{
					sprite = newsprite;
				}
			}
			else
			{
				sprite = newsprite;
			}
		}
		if (newstate->GetAction())
		{
			// The parameterized action functions need access to the current state and
			// if a function is supposed to work with both actors and weapons
			// there is no real means to get to it reliably so I store it in a global variable here.
			// Yes, I know this is truly awful but it is the only method I can think of
			// that does not involve changing stuff throughout the code.
			// Of course this should be rewritten ASAP.

			CallingState = newstate;

			newstate->GetAction() (this);

			// Check whether the called action function resulted in destroying the actor
			if (ObjectFlags & OF_MassDestruction) return false;
		}
		newstate = newstate->GetNextState();
	} while (tics == 0);

	gl_SetActorLights(this);
	return true;
}

//----------------------------------------------------------------------------
//
// FUNC AActor::SetStateNF
//
// Same as SetState, but does not call the state function.
//
//----------------------------------------------------------------------------

bool AActor::SetStateNF (FState *newstate)
{
	do
	{
		if (newstate == NULL)
		{
			state = NULL;
			Destroy ();
			return false;
		}
		int prevsprite, newsprite;

		if (state != NULL)
		{
			prevsprite = state->sprite.index;
		}
		else
		{
			prevsprite = -1;
		}
		state = newstate;
		tics = GetTics(newstate);
		renderflags = (renderflags & ~RF_FULLBRIGHT) | newstate->GetFullbright();
		newsprite = newstate->sprite.index;
		if (newsprite != 1)
		{
			// Sprite 1 is ----, which means "do not change the sprite"

			frame = newstate->GetFrame();
			if (!(flags4 & MF4_NOSKIN) && newsprite == SpawnState->sprite.index)
			{
				if (player != NULL && gameinfo.gametype != GAME_Hexen)
				{
					sprite = skins[player->userinfo.skin].sprite;
				}
				else if (newsprite != prevsprite)
				{
					sprite = newsprite;
				}
			}
			else
			{
				sprite = newsprite;
			}
		}
		newstate = newstate->GetNextState();
	} while (tics == 0);

	gl_SetActorLights(this);
	return true;
}

//============================================================================
//
// AActor :: AddInventory
//
//============================================================================

void AActor::AddInventory (AInventory *item)
{
	// Check if it's already attached to an actor
	if (item->Owner != NULL)
	{
		// Is it attached to us?
		if (item->Owner == this)
			return;

		// No, then remove it from the other actor first
		item->Owner->RemoveInventory (item);
	}

	item->Owner = this;
	item->Inventory = Inventory;
	Inventory = item;

	// Each item receives an unique ID when added to an actor's inventory.
	// This is used by the DEM_INVUSE command to identify the item. Simply
	// using the item's position in the list won't work, because ticcmds get
	// run sometime in the future, so by the time it runs, the inventory
	// might not be in the same state as it was when DEM_INVUSE was sent.
	Inventory->InventoryID = InventoryID++;
}

//============================================================================
//
// AActor :: RemoveInventory
//
//============================================================================

void AActor::RemoveInventory (AInventory *item)
{
	AInventory *inv, **invp;

	invp = &item->Owner->Inventory;
	for (inv = *invp; inv != NULL; invp = &inv->Inventory, inv = *invp)
	{
		if (inv == item)
		{
			*invp = item->Inventory;
			item->DetachFromOwner ();
			item->Owner = NULL;
			break;
		}
	}
}

//============================================================================
//
// AActor :: DestroyAllInventory
//
//============================================================================

void AActor::DestroyAllInventory ()
{
	while (Inventory != NULL)
	{
		AInventory *item = Inventory;
		item->Destroy ();
		assert (item != Inventory);
	}
}

//============================================================================
//
// AActor :: FirstInv
//
// Returns the first item in this actor's inventory that has IF_INVBAR set.
//
//============================================================================

AInventory *AActor::FirstInv () const
{
	if (Inventory == NULL)
	{
		return NULL;
	}
	if (Inventory->ItemFlags & IF_INVBAR)
	{
		return Inventory;
	}
	return Inventory->NextInv ();
}

//============================================================================
//
// AActor :: UseInventory
//
// Attempts to use an item. If the use succeeds, one copy of the item is
// removed from the inventory. If all copies are removed, then the item is
// destroyed.
//
//============================================================================

bool AActor::UseInventory (AInventory *item)
{
	// No using items if you're dead.
	if (health <= 0)
	{
		return false;
	}
	// Don't use it if you don't actually have any of it.
	if (item->Amount <= 0)
	{
		return false;
	}
	if (!item->Use (false))
	{
		return false;
	}
	if (--item->Amount <= 0 && !(item->ItemFlags & IF_KEEPDEPLETED))
	{
		item->Destroy ();
	}
	return true;
}

//===========================================================================
//
// AActor :: DropInventory
//
// Removes a single copy of an item and throws it out in front of the actor.
//
//===========================================================================

AInventory *AActor::DropInventory (AInventory *item)
{
	fixed_t dropdist;
	angle_t an;
	AInventory *drop = item->CreateTossable ();

	if (drop == NULL)
	{
		return NULL;
	}
	an = angle >> ANGLETOFINESHIFT;
	/* 92682 = sqrt(2) * FRACUNIT */
	dropdist = FixedMul (92682, radius + 8*FRACUNIT + item->radius);
	drop->x = x;
	drop->y = y;
	drop->z = z + 10*FRACUNIT;
	P_TryMove (drop, x, y, true);
	drop->angle = angle;
	drop->momx = momx + 5 * finecosine[an];
	drop->momy = momy + 5 * finesine[an];
	drop->momz = momz + FRACUNIT;
	drop->flags &= ~MF_NOGRAVITY;	// Don't float
	return drop;
}

//============================================================================
//
// AActor :: FindInventory
//
//============================================================================

AInventory *AActor::FindInventory (const PClass *type) const
{
	AInventory *item;

	if (type == NULL) return NULL;

	assert (type->ActorInfo != NULL);
	for (item = Inventory; item != NULL; item = item->Inventory)
	{
		if (item->GetClass() == type)
		{
			break;
		}
	}
	return item;
}

AInventory *AActor::FindInventory (FName type) const
{
	return FindInventory(PClass::FindClass(type));
}

//============================================================================
//
// AActor :: GiveInventoryType
//
//============================================================================

AInventory *AActor::GiveInventoryType (const PClass *type)
{
	AInventory *item;

	item = static_cast<AInventory *>(Spawn (type, 0,0,0, NO_REPLACE));
	if (!item->TryPickup (this))
	{
		item->Destroy ();
		return NULL;
	}
	return item;
}

//============================================================================
//
// AActor :: GiveAmmo
//
// Returns true if the ammo was added, false if not.
//
//============================================================================

bool AActor::GiveAmmo (const PClass *type, int amount)
{
	if (type != NULL)
	{
		AInventory *item = static_cast<AInventory *>(Spawn (type, 0, 0, 0, NO_REPLACE));
		if (item)
		{
			item->Amount = amount;
			item->flags |= MF_DROPPED;
			if (!item->TryPickup (this))
			{
				item->Destroy ();
				return false;
			}
			return true;
		}
	}
	return false;
}

//============================================================================
//
// AActor :: CopyFriendliness
//
// Makes this actor hate (or like) the same things another actor does.
//
//============================================================================

void AActor::CopyFriendliness (const AActor *other, bool changeTarget)
{
	level.total_monsters -= CountsAsKill();
	TIDtoHate = other->TIDtoHate;
	LastLook = other->LastLook;
	flags  = (flags & ~MF_FRIENDLY) | (other->flags & MF_FRIENDLY);
	flags3 = (flags3 & ~(MF3_NOSIGHTCHECK | MF3_HUNTPLAYERS)) | (other->flags3 & (MF3_NOSIGHTCHECK | MF3_HUNTPLAYERS));
	flags4 = (flags4 & ~MF4_NOHATEPLAYERS) | (other->flags4 & MF4_NOHATEPLAYERS);
	FriendPlayer = other->FriendPlayer;
	if (changeTarget && other->target != NULL && !(other->target->flags3 & MF3_NOTARGET))
	{
		// LastHeard must be set as well so that A_Look can react to the new target if called
		LastHeard = target = other->target;
	}
	level.total_monsters += CountsAsKill();
}

//============================================================================
//
// AActor :: ObtainInventory
//
// Removes the items from the other actor and puts them in this actor's
// inventory. The actor receiving the inventory must not have any items.
//
//============================================================================

void AActor::ObtainInventory (AActor *other)
{
	assert (Inventory == NULL);

	Inventory = other->Inventory;
	InventoryID = other->InventoryID;
	other->Inventory = NULL;
	other->InventoryID = 0;

	if (other->IsKindOf(RUNTIME_CLASS(APlayerPawn)) && this->IsKindOf(RUNTIME_CLASS(APlayerPawn)))
	{
		APlayerPawn *you = static_cast<APlayerPawn *>(other);
		APlayerPawn *me = static_cast<APlayerPawn *>(this);
		me->InvFirst = you->InvFirst;
		me->InvSel = you->InvSel;
		you->InvFirst = NULL;
		you->InvSel = NULL;
	}

	AInventory *item = Inventory;
	while (item != NULL)
	{
		item->Owner = this;
		item = item->Inventory;
	}
}

//============================================================================
//
// AActor :: CheckLocalView
//
// Returns true if this actor is local for the player. Here, local means the
// player is either looking out this actor's eyes, or this actor is the player
// and the player is looking out the eyes of something non-"sentient."
//
//============================================================================

bool AActor::CheckLocalView (int playernum) const
{
	if (players[playernum].camera == this)
	{
		return true;
	}
	if (players[playernum].mo != this || players[playernum].camera == NULL)
	{
		return false;
	}
	if (players[playernum].camera->player == NULL &&
		!(players[playernum].camera->flags3 & MF3_ISMONSTER))
	{
		return true;
	}
	return false;
}

//============================================================================
//
// AActor :: ConversationAnimation
//
// Plays a conversation-related animation:
//	 0 = greeting
//   1 = "yes"
//   2 = "no"
//
//============================================================================

void AActor::ConversationAnimation (int animnum)
{
	FState * state = NULL;
	switch (animnum)
	{
	case 0:
		state = FindState(NAME_Greetings);
		break;
	case 1:
		state = FindState(NAME_Yes);
		break;
	case 2:
		state = FindState(NAME_No);
		break;
	}
	if (state != NULL) SetState(state);
}

//============================================================================
//
// AActor :: Touch
//
// Something just touched this actor. Normally used only for inventory items,
// but some Strife monsters also use it.
//
//============================================================================

void AActor::Touch (AActor *toucher)
{
}

//============================================================================
//
// AActor :: Massacre
//
// Called by the massacre cheat to kill monsters. Returns true if the monster
// was killed and false if it was already dead.
//============================================================================

bool AActor::Massacre ()
{
	int prevhealth;

	if (health > 0)
	{
		flags |= MF_SHOOTABLE;
		flags2 &= ~(MF2_DORMANT|MF2_INVULNERABLE);
		do
		{
			prevhealth = health;
			P_DamageMobj (this, NULL, NULL, 1000000, NAME_Massacre);
		}
		while (health != prevhealth && health > 0);	//abort if the actor wasn't hurt.
		return true;
	}
	return false;
}

//----------------------------------------------------------------------------
//
// PROC P_ExplodeMissile
//
//----------------------------------------------------------------------------

void P_ExplodeMissile (AActor *mo, line_t *line, AActor *target)
{
	if (mo->flags3 & MF3_EXPLOCOUNT)
	{
		if (++mo->special2 < mo->special1)
		{
			return;
		}
	}
	mo->momx = mo->momy = mo->momz = 0;
	mo->effects = 0;		// [RH]

	FState *nextstate=NULL;

	if (target != NULL && target->flags & (MF_SHOOTABLE|MF_CORPSE))
	{
		if (target->flags & MF_NOBLOOD) nextstate = mo->FindState(NAME_Crash);
		if (nextstate == NULL) nextstate = mo->FindState(NAME_Death, NAME_Extreme);
	}
	if (nextstate == NULL) nextstate = mo->FindState(NAME_Death);
	mo->SetState (nextstate);

	if (mo->ObjectFlags & OF_MassDestruction)
	{
		return;
	}

	if (line != NULL && line->special == Line_Horizon)
	{
		// [RH] Don't explode missiles on horizon lines.
		mo->Destroy ();
		return;
	}

	if (line != NULL && cl_missiledecals)
	{
		int side = P_PointOnLineSide (mo->x, mo->y, line);
		if (line->sidenum[side] == NO_SIDE)
			side ^= 1;
		if (line->sidenum[side] != NO_SIDE)
		{
			FDecalBase *base = mo->DecalGenerator;
			if (base != NULL)
			{
				// Find the nearest point on the line, and stick a decal there
				fixed_t x, y, z;
				SQWORD num, den;

				den = (SQWORD)line->dx*line->dx + (SQWORD)line->dy*line->dy;
				if (den != 0)
				{
					SDWORD frac;

					num = (SQWORD)(mo->x-line->v1->x)*line->dx+(SQWORD)(mo->y-line->v1->y)*line->dy;
					if (num <= 0)
					{
						frac = 0;
					}
					else if (num >= den)
					{
						frac = 1<<30;
					}
					else
					{
						frac = (SDWORD)(num / (den>>30));
					}

					x = line->v1->x + MulScale30 (line->dx, frac);
					y = line->v1->y + MulScale30 (line->dy, frac);
					z = mo->z;

					F3DFloor * ffloor=NULL;
					if (line->sidenum[side^1]!=NO_SIDE && sides[line->sidenum[side^1]].sector->e->ffloors.Size())
					{
						// find a 3D-floor to stick to
						sector_t * backsector=sides[line->sidenum[side^1]].sector;
						for(int i=0;i<backsector->e->ffloors.Size();i++)
						{
							F3DFloor * rover=backsector->e->ffloors[i];

							if ((rover->flags&(FF_EXISTS|FF_SOLID|FF_RENDERSIDES))==(FF_EXISTS|FF_SOLID|FF_RENDERSIDES))
							{
								if (z<=rover->top.plane->ZatPoint(x, y) && z>=rover->bottom.plane->ZatPoint( x, y))
								{
									ffloor=rover;
									break;
								}
							}
						}
					}

					DImpactDecal::StaticCreate (base->GetDecal (),
						x, y, z, sides + line->sidenum[side], ffloor);
				}
			}
		}
	}

	if (nextstate != NULL)
	{
		// [RH] Change render style of exploding rockets
		if (mo->flags5 & MF5_DEHEXPLOSION)
		{
			if (deh.ExplosionStyle == 255)
			{
				if (addrocketexplosion)
				{
					mo->RenderStyle = STYLE_Add;
					mo->alpha = FRACUNIT;
				}
				else
				{
					mo->RenderStyle = STYLE_Translucent;
					mo->alpha = FRACUNIT*2/3;
				}
			}
			else
			{
				mo->RenderStyle = deh.ExplosionStyle;
				mo->alpha = deh.ExplosionAlpha;
			}
		}

		if (mo->flags4 & MF4_RANDOMIZE)
		{
			mo->tics -= (pr_explodemissile() & 3) * TICRATE / 35;
			if (mo->tics < 1)
				mo->tics = 1;
		}

		mo->flags &= ~MF_MISSILE;

		if (mo->DeathSound)
		{
			S_SoundID (mo, CHAN_VOICE, mo->DeathSound, 1,
				(mo->flags3 & MF3_FULLVOLDEATH) ? ATTN_NONE : ATTN_NORM);
		}
	}
}

//----------------------------------------------------------------------------
//
// PROC P_FloorBounceMissile
//
// Returns true if the missile was destroyed
//----------------------------------------------------------------------------

bool AActor::FloorBounceMissile (secplane_t &plane)
{
	if (z <= floorz && P_HitFloor (this))
	{
		// Landed in some sort of liquid
		if (flags5 & MF5_EXPLODEONWATER)
		{
			P_ExplodeMissile(this, NULL, NULL);
			return true;
		}
		if (!(flags3 & MF3_CANBOUNCEWATER))
		{
			Destroy ();
			return true;
		}
	}

	// The amount of bounces is limited
	if (bouncecount>0 && --bouncecount==0)
	{
		P_ExplodeMissile(this, NULL, NULL);
		return true;
	}

	fixed_t dot = TMulScale16 (momx, plane.a, momy, plane.b, momz, plane.c);

	if ((flags2 & MF2_BOUNCETYPE) == MF2_HERETICBOUNCE)
	{
		momx -= MulScale15 (plane.a, dot);
		momy -= MulScale15 (plane.b, dot);
		momz -= MulScale15 (plane.c, dot);
		angle = R_PointToAngle2 (0, 0, momx, momy);
		flags |= MF_INBOUNCE;
		SetState (FindState(NAME_Death));
		flags &= ~MF_INBOUNCE;
		return false;
	}

	// The reflected velocity keeps only about 70% of its original speed
	long bouncescale = 0x4000 * bouncefactor;
	momx = MulScale30 (momx - MulScale15 (plane.a, dot), bouncescale);
	momy = MulScale30 (momy - MulScale15 (plane.b, dot), bouncescale);
	momz = MulScale30 (momz - MulScale15 (plane.c, dot), bouncescale);
	angle = R_PointToAngle2 (0, 0, momx, momy);

	if (SeeSound && !(flags4 & MF4_NOBOUNCESOUND))
	{
		S_SoundID (this, CHAN_VOICE, SeeSound, 1, ATTN_IDLE);
	}

	if ((flags2 & MF2_BOUNCETYPE) == MF2_DOOMBOUNCE)
	{
		if (!(flags & MF_NOGRAVITY) && (momz < 3*FRACUNIT))
		{
			flags2 &= ~MF2_BOUNCETYPE;
		}
	}
	return false;
}

//----------------------------------------------------------------------------
//
// PROC P_ThrustMobj
//
//----------------------------------------------------------------------------

void P_ThrustMobj (AActor *mo, angle_t angle, fixed_t move)
{
	angle >>= ANGLETOFINESHIFT;
	mo->momx += FixedMul (move, finecosine[angle]);
	mo->momy += FixedMul (move, finesine[angle]);
}

//----------------------------------------------------------------------------
//
// FUNC P_FaceMobj
//
// Returns 1 if 'source' needs to turn clockwise, or 0 if 'source' needs
// to turn counter clockwise.  'delta' is set to the amount 'source'
// needs to turn.
//
//----------------------------------------------------------------------------

int P_FaceMobj (AActor *source, AActor *target, angle_t *delta)
{
	angle_t diff;
	angle_t angle1;
	angle_t angle2;

	angle1 = source->angle;
	angle2 = R_PointToAngle2 (source->x, source->y, target->x, target->y);
	if (angle2 > angle1)
	{
		diff = angle2 - angle1;
		if (diff > ANGLE_180)
		{
			*delta = ANGLE_MAX - diff;
			return 0;
		}
		else
		{
			*delta = diff;
			return 1;
		}
	}
	else
	{
		diff = angle1 - angle2;
		if (diff > ANGLE_180)
		{
			*delta = ANGLE_MAX - diff;
			return 1;
		}
		else
		{
			*delta = diff;
			return 0;
		}
	}
}

//----------------------------------------------------------------------------
//
// FUNC P_SeekerMissile
//
// The missile's tracer field must be the target.  Returns true if
// target was tracked, false if not.
//
//----------------------------------------------------------------------------

bool P_SeekerMissile (AActor *actor, angle_t thresh, angle_t turnMax)
{
	int dir;
	int dist;
	angle_t delta;
	angle_t angle;
	AActor *target;

	target = actor->tracer;
	if (target == NULL || actor->Speed == 0)
	{
		return false;
	}
	if (!(target->flags & MF_SHOOTABLE))
	{ // Target died
		actor->tracer = NULL;
		return false;
	}
	dir = P_FaceMobj (actor, target, &delta);
	if (delta > thresh)
	{
		delta >>= 1;
		if (delta > turnMax)
		{
			delta = turnMax;
		}
	}
	if (dir)
	{ // Turn clockwise
		actor->angle += delta;
	}
	else
	{ // Turn counter clockwise
		actor->angle -= delta;
	}
	angle = actor->angle>>ANGLETOFINESHIFT;
	actor->momx = FixedMul (actor->Speed, finecosine[angle]);
	actor->momy = FixedMul (actor->Speed, finesine[angle]);
	if (actor->z + actor->height < target->z ||
		target->z + target->height < actor->z)
	{ // Need to seek vertically
		dist = P_AproxDistance (target->x - actor->x, target->y - actor->y);
		dist = dist / actor->Speed;
		if (dist < 1)
		{
			dist = 1;
		}
		actor->momz = ((target->z+target->height/2) - (actor->z+actor->height/2)) / dist;
	}
	return true;
}

//
// P_XYMovement
//
#define STOPSPEED			0x1000
#define FRICTION			0xe800
#define CARRYSTOPSPEED		(STOPSPEED*32/3)

void P_XYMovement (AActor *mo, fixed_t scrollx, fixed_t scrolly)
{
	bool bForceSlide = scrollx || scrolly;
	angle_t angle;
	fixed_t ptryx, ptryy;
	player_t *player;
	fixed_t xmove, ymove;
	const secplane_t * walkplane;
	static const int windTab[3] = {2048*5, 2048*10, 2048*25};
	int steps, step, totalsteps;
	fixed_t startx, starty;

	fixed_t maxmove = (mo->waterlevel < 1) || (mo->flags & MF_MISSILE) ||
					  (mo->player && mo->player->crouchoffset<-10*FRACUNIT) ? MAXMOVE : MAXMOVE/4;

	if (mo->flags2 & MF2_WINDTHRUST && mo->waterlevel < 2 && !(mo->flags & MF_NOCLIP))
	{
		int special = mo->Sector->special;
		switch (special)
		{
			case 40: case 41: case 42: // Wind_East
				P_ThrustMobj (mo, 0, windTab[special-40]);
				break;
			case 43: case 44: case 45: // Wind_North
				P_ThrustMobj (mo, ANG90, windTab[special-43]);
				break;
			case 46: case 47: case 48: // Wind_South
				P_ThrustMobj (mo, ANG270, windTab[special-46]);
				break;
			case 49: case 50: case 51: // Wind_West
				P_ThrustMobj (mo, ANG180, windTab[special-49]);
				break;
		}
	}

	// [RH] No need to clamp these now. However, wall running needs it so
	// that large thrusts can't propel an actor through a wall, because wall
	// running depends on the player's original movement continuing even after
	// it gets blocked.
	if (mo->player != NULL && (i_compatflags & COMPATF_WALLRUN) || (mo->waterlevel >= 1) ||
		(mo->player != NULL && mo->player->crouchfactor < FRACUNIT*3/4))
	{
		// preserve the direction instead of clamping x and y independently.
		xmove = clamp (mo->momx, -maxmove, maxmove);
		ymove = clamp (mo->momy, -maxmove, maxmove);

		fixed_t xfac = FixedDiv(xmove, mo->momx);
		fixed_t yfac = FixedDiv(ymove, mo->momy);
		fixed_t fac = MIN(xfac, yfac);

		xmove = mo->momx = FixedMul(mo->momx, fac);
		ymove = mo->momy = FixedMul(mo->momy, fac);
	}
	else
	{
		xmove = mo->momx;
		ymove = mo->momy;
	}
	// [RH] Carrying sectors didn't work with low speeds in BOOM. This is
	// because BOOM relied on the speed being fast enough to accumulate
	// despite friction. If the speed is too low, then its movement will get
	// cancelled, and it won't accumulate to the desired speed.
	if (abs(scrollx) > CARRYSTOPSPEED)
	{
		scrollx = FixedMul (scrollx, CARRYFACTOR);
		mo->momx += scrollx;
	}
	if (abs(scrolly) > CARRYSTOPSPEED)
	{
		scrolly = FixedMul (scrolly, CARRYFACTOR);
		mo->momy += scrolly;
	}
	xmove += scrollx;
	ymove += scrolly;

	if ((xmove | ymove) == 0)
	{
		if (mo->flags & MF_SKULLFLY)
		{
			// the skull slammed into something
			mo->flags &= ~MF_SKULLFLY;
			mo->momx = mo->momy = mo->momz = 0;
			if (!(mo->flags2 & MF2_DORMANT))
			{
				mo->SetState (mo->SeeState != NULL ? mo->SeeState : mo->SpawnState);
			}
			else
			{
				mo->SetState (mo->SpawnState);
				mo->tics = -1;
			}
		}
		return;
	}

	player = mo->player;

	// [RH] Adjust player movement on sloped floors
	fixed_t startxmove = xmove;
	fixed_t startymove = ymove;
	walkplane = P_CheckSlopeWalk (mo, xmove, ymove);

	// [RH] Take smaller steps when moving faster than the object's size permits.
	// Moving as fast as the object's "diameter" is bad because it could skip
	// some lines because the actor could land such that it is just touching the
	// line. For Doom to detect that the line is there, it needs to actually cut
	// through the actor.

	{
		maxmove = mo->radius - FRACUNIT;

		if (maxmove <= 0)
		{ // gibs can have radius 0, so don't divide by zero below!
			maxmove = MAXMOVE;
		}

		const fixed_t xspeed = abs (xmove);
		const fixed_t yspeed = abs (ymove);

		steps = 1;

		if (xspeed > yspeed)
		{
			if (xspeed > maxmove)
			{
				steps = 1 + xspeed / maxmove;
			}
		}
		else
		{
			if (yspeed > maxmove)
			{
				steps = 1 + yspeed / maxmove;
			}
		}
	}

	// P_SlideMove needs to know the step size before P_CheckSlopeWalk
	// because it also calls P_CheckSlopeWalk on its clipped steps.
	fixed_t onestepx = startxmove / steps;
	fixed_t onestepy = startymove / steps;

	startx = mo->x;
	starty = mo->y;
	step = 1;
	totalsteps = steps;

	// [RH] Instead of doing ripping damage each step, do it each tic.
	// This makes it compatible with Heretic and Hexen, which only did
	// one step for their missiles with ripping damage (excluding those
	// that don't use P_XYMovement). It's also more intuitive since it
	// makes the damage done dependant on the amount of time the projectile
	// spends inside a target rather than on the projectile's size. The
	// last actor ripped through is recorded so that if the projectile
	// passes through more than one actor this tic, each one takes damage
	// and not just the first one.

	if (mo->flags2 & MF2_RIP)
	{
		DoRipping = true;
		LastRipped = NULL;
	}

	do
	{
		ptryx = startx + Scale (xmove, step, steps);
		ptryy = starty + Scale (ymove, step, steps);

/*		if (mo->player)
		Printf ("%d,%d/%d: %d %d %d %d %d %d %d\n", level.time, step, steps, startxmove, Scale(xmove,step,steps), startymove, Scale(ymove,step,steps), mo->x, mo->y, mo->z);
*/
		// [RH] If walking on a slope, stay on the slope
		// killough 3/15/98: Allow objects to drop off
		if (!P_TryMove (mo, ptryx, ptryy, true, walkplane))
		{
			// blocked move

			if ((mo->flags2 & (MF2_SLIDE|MF2_BLASTED) || bForceSlide) && !(mo->flags&MF_MISSILE))
			{
				// try to slide along it
				if (BlockingMobj == NULL)
				{ // slide against wall
					if (BlockingLine != NULL &&
						mo->player && mo->waterlevel && mo->waterlevel < 3 &&
						(mo->player->cmd.ucmd.forwardmove | mo->player->cmd.ucmd.sidemove) &&
						BlockingLine->sidenum[1] != NO_SIDE)
					{
						mo->momz = WATER_JUMP_SPEED;
					}
					if (player && (i_compatflags & COMPATF_WALLRUN))
					{
					// [RH] Here is the key to wall running: The move is clipped using its full speed.
					// If the move is done a second time (because it was too fast for one move), it
					// is still clipped against the wall at its full speed, so you effectively
					// execute two moves in one tic.
						P_SlideMove (mo, mo->momx, mo->momy, 1);
					}
					else
					{
						P_SlideMove (mo, onestepx, onestepy, totalsteps);
					}
					if ((mo->momx | mo->momy) == 0)
					{
						steps = 0;
					}
					else
					{
						if (!player || !(i_compatflags & COMPATF_WALLRUN))
						{
							xmove = mo->momx;
							ymove = mo->momy;
							onestepx = xmove / steps;
							onestepy = ymove / steps;
							P_CheckSlopeWalk (mo, xmove, ymove);
						}
						startx = mo->x - Scale (xmove, step, steps);
						starty = mo->y - Scale (ymove, step, steps);
					}
				}
				else
				{ // slide against another actor
					fixed_t tx, ty;
					tx = 0, ty = onestepy;
					walkplane = P_CheckSlopeWalk (mo, tx, ty);
					if (P_TryMove (mo, mo->x + tx, mo->y + ty, true, walkplane))
					{
						mo->momx = 0;
					}
					else
					{
						tx = onestepx, ty = 0;
						walkplane = P_CheckSlopeWalk (mo, tx, ty);
						if (P_TryMove (mo, mo->x + tx, mo->y + ty, true, walkplane))
						{
							mo->momy = 0;
						}
						else
						{
							mo->momx = mo->momy = 0;
						}
					}
					if (player && player->mo == mo)
					{
						if (mo->momx == 0)
							player->momx = 0;
						if (mo->momy == 0)
							player->momy = 0;
					}
					steps = 0;
				}
			}
			else if (mo->flags & MF_MISSILE)
			{
				steps = 0;
				if (BlockingMobj)
				{
					if (mo->flags2 & MF2_BOUNCE2)
					{
						if (mo->flags5&MF5_BOUNCEONACTORS ||
							(BlockingMobj->flags2 & MF2_REFLECTIVE) ||
							((!BlockingMobj->player) &&
							 (!(BlockingMobj->flags3 & MF3_ISMONSTER))))
						{
							fixed_t speed;

							angle = R_PointToAngle2 (BlockingMobj->x,
								BlockingMobj->y, mo->x, mo->y)
								+ANGLE_1*((pr_bounce()%16)-8);
							speed = P_AproxDistance (mo->momx, mo->momy);
							speed = FixedMul (speed, (fixed_t)(0.75*FRACUNIT));
							mo->angle = angle;
							angle >>= ANGLETOFINESHIFT;
							mo->momx = FixedMul (speed, finecosine[angle]);
							mo->momy = FixedMul (speed, finesine[angle]);
							if (mo->SeeSound && !(mo->flags4&MF4_NOBOUNCESOUND))
							{
								S_SoundID (mo, CHAN_VOICE, mo->SeeSound, 1, ATTN_IDLE);
							}
							DoRipping = false;
							return;
						}
						else
						{ // Struck a player/creature
							P_ExplodeMissile (mo, NULL, BlockingMobj);
							DoRipping = false;
							return;
						}
					}
				}
				else
				{
					// Struck a wall
					if (P_BounceWall (mo))
					{
						if (mo->SeeSound && !(mo->flags3 & MF3_NOWALLBOUNCESND))
						{
							S_SoundID (mo, CHAN_VOICE, mo->SeeSound, 1, ATTN_IDLE);
						}
						DoRipping = false;
						return;
					}
				}
				if (BlockingMobj &&
					(BlockingMobj->flags2 & MF2_REFLECTIVE))
				{
					angle = R_PointToAngle2(BlockingMobj->x,
													BlockingMobj->y,
													mo->x, mo->y);

				// Change angle for deflection/reflection
					if (mo->AdjustReflectionAngle (BlockingMobj, angle))
					{
						goto explode;
					}

					// Reflect the missile along angle
					mo->angle = angle;
					angle >>= ANGLETOFINESHIFT;
					mo->momx = FixedMul (mo->Speed>>1, finecosine[angle]);
					mo->momy = FixedMul (mo->Speed>>1, finesine[angle]);
					mo->momz = -mo->momz/2;
					if (mo->flags2 & MF2_SEEKERMISSILE)
					{
						mo->tracer = mo->target;
					}
					mo->target = BlockingMobj;
					DoRipping = false;
					return;
				}
explode:
				// explode a missile
				if (ceilingline &&
					ceilingline->backsector &&
					ceilingline->backsector->ceilingpic == skyflatnum &&
					mo->z >= ceilingline->backsector->ceilingplane.ZatPoint (mo->x, mo->y) && //killough
					!(mo->flags3 & MF3_SKYEXPLODE))
				{
					// Hack to prevent missiles exploding against the sky.
					// Does not handle sky floors.
					mo->Destroy ();
					DoRipping = false;
					return;
				}
				// [RH] Don't explode on horizon lines.
				if (BlockingLine != NULL && BlockingLine->special == Line_Horizon)
				{
					mo->Destroy ();
					DoRipping = false;
					return;
				}
				P_ExplodeMissile (mo, BlockingLine, BlockingMobj);
				DoRipping = false;
				return;
			}
			else
			{
				mo->momx = mo->momy = 0;
				steps = 0;
			}
		}
		else
		{
			if (mo->x != ptryx || mo->y != ptryy)
			{
				// If the new position does not match the desired position, the player
				// must have gone through a teleporter, so stop moving right now if it
				// was a regular teleporter. If it was a line-to-line or fogless teleporter,
				// the move should continue, but startx and starty need to change.
				if (mo->momx == 0 && mo->momy == 0)
				{
					step = steps;
				}
				else
				{
					startx = mo->x - Scale (xmove, step, steps);
					starty = mo->y - Scale (ymove, step, steps);
				}
			}
		}
	} while (++step <= steps);

	DoRipping = false;

	// Friction

	if (player && player->mo == mo && player->cheats & CF_NOMOMENTUM)
	{ // debug option for no sliding at all
		mo->momx = mo->momy = 0;
		player->momx = player->momy = 0;
		return;
	}

	if (mo->flags & (MF_MISSILE | MF_SKULLFLY))
	{ // no friction for missiles
		return;
	}

	if (mo->z > mo->floorz && !(mo->flags2 & MF2_ONMOBJ) &&
		(!(mo->flags2 & MF2_FLY) || !(mo->flags & MF_NOGRAVITY)) && !mo->waterlevel)
	{ // [RH] Friction when falling is available for larger aircontrols
		if (player != NULL && level.airfriction != FRACUNIT)
		{
			mo->momx = FixedMul (mo->momx, level.airfriction);
			mo->momy = FixedMul (mo->momy, level.airfriction);

			if (player->mo == mo)		//  Not voodoo dolls
			{
				player->momx = FixedMul (player->momx, level.airfriction);
				player->momy = FixedMul (player->momy, level.airfriction);
			}
		}
		return;
	}

	if (mo->flags & MF_CORPSE)
	{ // Don't stop sliding if halfway off a step with some momentum
		if (mo->momx > FRACUNIT/4 || mo->momx < -FRACUNIT/4
			|| mo->momy > FRACUNIT/4 || mo->momy < -FRACUNIT/4)
		{
			if (mo->floorz > mo->Sector->floorplane.ZatPoint (mo->x, mo->y))
			{
				unsigned i;
				for(i=0;i<mo->Sector->e->ffloors.Size();i++)
				{
					// Sliding around on 3D floors looks extremely bad so
					// if the floor comes from one in the current sector stop sliding the corpse!
					F3DFloor * rover=mo->Sector->e->ffloors[i];
					if (!(rover->flags&FF_EXISTS)) continue;
					if (rover->flags&FF_SOLID && rover->top.plane->ZatPoint(mo->x,mo->y)==mo->floorz) break;
				}
				if (i==mo->Sector->e->ffloors.Size()) return;
			}
		}
	}

	// killough 11/98:
	// Stop voodoo dolls that have come to rest, despite any
	// moving corresponding player:
	if (mo->momx > -STOPSPEED && mo->momx < STOPSPEED
		&& mo->momy > -STOPSPEED && mo->momy < STOPSPEED
		&& (!player || (player->mo != mo)
			|| !(player->cmd.ucmd.forwardmove | player->cmd.ucmd.sidemove)))
	{
		// if in a walking frame, stop moving
		// killough 10/98:
		// Don't affect main player when voodoo dolls stop:
		if (player && player->mo == mo && !(player->cheats & CF_PREDICTING))
		{
			player->mo->PlayIdle ();
		}

		mo->momx = mo->momy = 0;

		// killough 10/98: kill any bobbing momentum too (except in voodoo dolls)
		if (player && player->mo == mo)
			player->momx = player->momy = 0;
	}
	else
	{
		// phares 3/17/98
		// Friction will have been adjusted by friction thinkers for icy
		// or muddy floors. Otherwise it was never touched and
		// remained set at ORIG_FRICTION
		//
		// killough 8/28/98: removed inefficient thinker algorithm,
		// instead using touching_sectorlist in P_GetFriction() to
		// determine friction (and thus only when it is needed).
		//
		// killough 10/98: changed to work with new bobbing method.
		// Reducing player momentum is no longer needed to reduce
		// bobbing, so ice works much better now.

		fixed_t friction = P_GetFriction (mo, NULL);

		mo->momx = FixedMul (mo->momx, friction);
		mo->momy = FixedMul (mo->momy, friction);

		// killough 10/98: Always decrease player bobbing by ORIG_FRICTION.
		// This prevents problems with bobbing on ice, where it was not being
		// reduced fast enough, leading to all sorts of kludges being developed.

		if (player && player->mo == mo)		//  Not voodoo dolls
		{
			player->momx = FixedMul (player->momx, ORIG_FRICTION);
			player->momy = FixedMul (player->momy, ORIG_FRICTION);
		}
	}
}

// Move this to p_inter ***
void P_MonsterFallingDamage (AActor *mo)
{
	int damage;
	int mom;

	if (!(level.flags&LEVEL_MONSTERFALLINGDAMAGE))
		return;

	mom = abs(mo->momz);
	if (mom > 35*FRACUNIT)
	{ // automatic death
		damage = 1000000;
	}
	else
	{
		damage = ((mom - (23*FRACUNIT))*6)>>FRACBITS;
	}
	damage = 1000000;	// always kill 'em
	P_DamageMobj (mo, NULL, NULL, damage, NAME_Falling);
}

//
// P_ZMovement
//
void P_ZMovement (AActor *mo)
{
	fixed_t dist;
	fixed_t delta;
	fixed_t oldz = mo->z;

	// Intercept the stupid 'fall through 3dfloors' bug SSNTails 06-13-2002

	// [GrafZahl] This is a really ugly workaround... :(
	// But unless the collision code is completely rewritten it is the
	// only way to avoid problems caused by incorrect positioning info...
	for(int i=0;i<mo->Sector->e->ffloors.Size();i++)
    {
		F3DFloor*  rover=mo->Sector->e->ffloors[i];

		if (!(rover->flags&FF_EXISTS)) continue;
		if(!(rover->flags & FF_SOLID) || !(rover->flags & FF_EXISTS)) continue;

		fixed_t ff_bottom=rover->bottom.plane->ZatPoint(mo->x, mo->y);
		fixed_t ff_top=rover->top.plane->ZatPoint(mo->x, mo->y);

		fixed_t delta1 = mo->z - (ff_bottom + ((ff_top-ff_bottom)/2));
		fixed_t delta2 = mo->z + mo->height - (ff_bottom + ((ff_top-ff_bottom)/2));

		if(ff_top > mo->floorz && abs(delta1) < abs(delta2)) mo->floorz = ff_top;
		if(ff_bottom < mo->ceilingz && abs(delta1) >= abs(delta2)) mo->ceilingz = ff_bottom;
    }

//
// check for smooth step up
//
	if (mo->player && mo->player->mo == mo && mo->z < mo->floorz)
	{
		mo->player->viewheight -= mo->floorz - mo->z;
		mo->player->deltaviewheight = mo->player->GetDeltaViewHeight();
	}

	if (!(mo->flags2&MF2_FLOATBOB)) mo->z += mo->momz;

//
// apply gravity
//
	if (mo->z > mo->floorz && !(mo->flags & MF_NOGRAVITY))
	{
		fixed_t startmomz = mo->momz;

		if (!mo->waterlevel || mo->flags & MF_CORPSE || (mo->player &&
			!(mo->player->cmd.ucmd.forwardmove | mo->player->cmd.ucmd.sidemove)))
		{
			mo->momz -= (fixed_t)(level.gravity * mo->Sector->gravity *
				FIXED2FLOAT(mo->gravity) * 81.92);
		}
		if (mo->waterlevel > 1)
		{
			fixed_t sinkspeed = mo->flags & MF_CORPSE ? -WATER_SINK_SPEED/3 : -WATER_SINK_SPEED;

			if (mo->momz < sinkspeed)
			{
				mo->momz = (startmomz < sinkspeed) ? startmomz : sinkspeed;
			}
			else
			{
				mo->momz = startmomz + ((mo->momz - startmomz) >>
					(mo->waterlevel == 1 ? WATER_SINK_SMALL_FACTOR : WATER_SINK_FACTOR));
			}
		}
	}

	if (mo->flags2&MF2_FLOATBOB) mo->z += mo->momz;

//
// adjust height
//
	if ((mo->flags & MF_FLOAT) && !(mo->flags2 & MF2_DORMANT) && mo->target)
	{	// float down towards target if too close
		if (!(mo->flags & MF_SKULLFLY) && !(mo->flags & MF_INFLOAT))
		{
			dist = P_AproxDistance (mo->x - mo->target->x, mo->y - mo->target->y);
			delta = (mo->target->z + (mo->height>>1)) - mo->z;
			if (delta < 0 && dist < -(delta*3))
				mo->z -= mo->FloatSpeed, mo->momz = 0;
			else if (delta > 0 && dist < (delta*3))
				mo->z += mo->FloatSpeed, mo->momz = 0;
		}
	}
	if (mo->player && (mo->flags & MF_NOGRAVITY) && (mo->z > mo->floorz))
	{
		mo->z += finesine[(FINEANGLES/80*level.maptime)&FINEMASK]/8;
		mo->momz = FixedMul (mo->momz, FRICTION_FLY);
	}
	if (mo->waterlevel && !(mo->flags & MF_NOGRAVITY))
	{
		mo->momz = FixedMul (mo->momz, mo->Sector->friction);
	}

//
// clip movement
//
	if (mo->z <= mo->floorz)
	{	// Hit the floor
		if ((!mo->player || !(mo->player->cheats & CF_PREDICTING)) &&
			mo->Sector->SecActTarget != NULL &&
			mo->Sector->floorplane.ZatPoint (mo->x, mo->y) == mo->floorz)
		{ // [RH] Let the sector do something to the actor
			mo->Sector->SecActTarget->TriggerAction (mo, SECSPAC_HitFloor);
		}
		P_CheckFor3DFloorHit(mo);
		// [RH] Need to recheck this because the sector action might have
		// teleported the actor so it is no longer below the floor.
		if (mo->z <= mo->floorz)
		{
			if ((mo->flags & MF_MISSILE) &&
				(gameinfo.gametype != GAME_Doom || !(mo->flags & MF_NOCLIP)))
			{
				mo->z = mo->floorz;
				if (mo->flags2 & MF2_BOUNCETYPE)
				{
					mo->FloorBounceMissile (mo->floorsector->floorplane);
					return;
				}
				else if (mo->flags3 & MF3_NOEXPLODEFLOOR)
				{
					mo->momz = 0;
					P_HitFloor (mo);
					return;
				}
				else if (mo->flags3 & MF3_FLOORHUGGER)
				{ // Floor huggers can go up steps
					return;
				}
				else
				{
					if (mo->floorpic == skyflatnum && !(mo->flags3 & MF3_SKYEXPLODE))
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						mo->Destroy ();
						return;
					}
					P_HitFloor (mo);
					P_ExplodeMissile (mo, NULL, NULL);
					return;
				}
			}
			if (mo->flags3 & MF3_ISMONSTER)		// Blasted mobj falling
			{
				if (mo->momz < -(23*FRACUNIT))
				{
					P_MonsterFallingDamage (mo);
				}
			}
			mo->z = mo->floorz;
			if (mo->momz < 0)
			{
				// [RH] avoid integer roundoff by doing comparisons with floats
				// I can't think of any good reason why this varied with gravity
				float minmom = 800.f /*level.gravity * mo->Sector->gravity*/ * -655.36f;
				float mom = (float)mo->momz;

				// Spawn splashes, etc.
				P_HitFloor (mo);
				if (mo->DamageType == NAME_Ice && mom < minmom)
				{
					mo->tics = 1;
					mo->momx = 0;
					mo->momy = 0;
					mo->momz = 0;
					return;
				}
				// Let the actor do something special for hitting the floor
				mo->HitFloor ();
				if (mo->player)
				{
					mo->player->jumpTics = 7;	// delay any jumping for a short while
					if (mom < minmom && !(mo->flags & MF_NOGRAVITY))
					{
						// Squat down.
						// Decrease viewheight for a moment after hitting the ground (hard),
						// and utter appropriate sound.
						PlayerLandedOnThing (mo, NULL);
					}
				}
				mo->momz = 0;
			}
			if (mo->flags & MF_SKULLFLY)
			{ // The skull slammed into something
				mo->momz = -mo->momz;
			}
			mo->Crash();
		}
	}

	if (mo->flags2 & MF2_FLOORCLIP)
	{
		mo->AdjustFloorClip ();
	}

	if (mo->z + mo->height > mo->ceilingz)
	{ // hit the ceiling
		if ((!mo->player || !(mo->player->cheats & CF_PREDICTING)) &&
			mo->Sector->SecActTarget != NULL &&
			mo->Sector->ceilingplane.ZatPoint (mo->x, mo->y) == mo->ceilingz)
		{ // [RH] Let the sector do something to the actor
			mo->Sector->SecActTarget->TriggerAction (mo, SECSPAC_HitCeiling);
		}
		P_CheckFor3DCeilingHit(mo);
		// [RH] Need to recheck this because the sector action might have
		// teleported the actor so it is no longer above the ceiling.
		if (mo->z + mo->height > mo->ceilingz)
		{
			mo->z = mo->ceilingz - mo->height;
			if (mo->flags2 & MF2_BOUNCETYPE)
			{	// ceiling bounce
				mo->FloorBounceMissile (mo->ceilingsector->ceilingplane);
				return;
			}
			if (mo->momz > 0)
				mo->momz = 0;
			if (mo->flags & MF_SKULLFLY)
			{	// the skull slammed into something
				mo->momz = -mo->momz;
			}
			if (mo->flags & MF_MISSILE &&
				(gameinfo.gametype != GAME_Doom || !(mo->flags & MF_NOCLIP)))
			{
				if (mo->flags3 & MF3_CEILINGHUGGER)
				{
					return;
				}
				if (mo->ceilingpic == skyflatnum &&  !(mo->flags3 & MF3_SKYEXPLODE))
				{
					mo->Destroy ();
					return;
				}
				P_ExplodeMissile (mo, NULL, NULL);
				return;
			}
		}
	}
	P_CheckFakeFloorTriggers (mo, oldz);
}

void P_CheckFakeFloorTriggers (AActor *mo, fixed_t oldz)
{
	if (mo->player && (mo->player->cheats & CF_PREDICTING))
	{
		return;
	}
	sector_t *sec = mo->Sector;
	assert (sec != NULL);
	if (sec == NULL)
	{
		return;
	}
	if (sec->heightsec != NULL && sec->SecActTarget != NULL)
	{
		sector_t *hs = sec->heightsec;
		fixed_t waterz = hs->floorplane.ZatPoint (mo->x, mo->y);
		fixed_t newz;
		fixed_t viewheight;

		if (mo->player != NULL)
		{
			viewheight = mo->player->viewheight;
		}
		else
		{
			viewheight = mo->height / 2;
		}

		if (oldz > waterz && mo->z <= waterz)
		{ // Feet hit fake floor
			sec->SecActTarget->TriggerAction (mo, SECSPAC_HitFakeFloor);
		}

		newz = mo->z + viewheight;
		oldz += viewheight;

		if (oldz <= waterz && newz > waterz)
		{ // View went above fake floor
			sec->SecActTarget->TriggerAction (mo, SECSPAC_EyesSurface);
		}
		else if (oldz > waterz && newz <= waterz)
		{ // View went below fake floor
			sec->SecActTarget->TriggerAction (mo, SECSPAC_EyesDive);
		}

		if (!(hs->MoreFlags & SECF_FAKEFLOORONLY))
		{
			waterz = hs->ceilingplane.ZatPoint (mo->x, mo->y);
			if (oldz <= waterz && newz > waterz)
			{ // View went above fake ceiling
				sec->SecActTarget->TriggerAction (mo, SECSPAC_EyesAboveC);
			}
			else if (oldz > waterz && newz <= waterz)
			{ // View went below fake ceiling
				sec->SecActTarget->TriggerAction (mo, SECSPAC_EyesBelowC);
			}
		}
	}
}

//===========================================================================
//
// PlayerLandedOnThing
//
//===========================================================================

static void PlayerLandedOnThing (AActor *mo, AActor *onmobj)
{
	bool grunted;

	if (!mo->player)
		return;

	if (mo->player->mo == mo)
	{
		mo->player->deltaviewheight = mo->momz>>3;
	}

	if (mo->player->cheats & CF_PREDICTING)
		return;

	P_FallingDamage (mo);

	// [RH] only make noise if alive
	if (!mo->player->morphTics && mo->health > 0)
	{
		grunted = false;
		// Why should this number vary by gravity?
		if (mo->momz < (fixed_t)(800.f /*level.gravity * mo->Sector->gravity*/ * -983.04f) && mo->health > 0)
		{
			S_Sound (mo, CHAN_VOICE, "*grunt", 1, ATTN_NORM);
			grunted = true;
		}
		if (onmobj != NULL || !Terrains[P_GetThingFloorType (mo)].IsLiquid)
		{
			if (!grunted || !S_AreSoundsEquivalent (mo, "*grunt", "*land"))
			{
				S_Sound (mo, CHAN_AUTO, "*land", 1, ATTN_NORM);
			}
		}
	}
//	mo->player->centering = true;
}



//
// P_NightmareRespawn
//
void P_NightmareRespawn (AActor *mobj)
{
	fixed_t x, y, z;
	AActor *mo;
	AActor *info = mobj->GetDefault();

	// spawn the new monster (assume the spawn will be good)
	if (info->flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
	else if (info->flags2 & MF2_SPAWNFLOAT)
		z = FLOATRANDZ;
	else if (info->flags2 & MF2_FLOATBOB)
		z = mobj->SpawnPoint[2] << FRACBITS;
	else
		z = ONFLOORZ;

	// spawn it
	x = mobj->SpawnPoint[0] << FRACBITS;
	y = mobj->SpawnPoint[1] << FRACBITS;
	mo = Spawn (RUNTIME_TYPE(mobj), x, y, z, NO_REPLACE);

	if (z == ONFLOORZ)
		mo->z += mo->SpawnPoint[2] << FRACBITS;
	else if (z == ONCEILINGZ)
		mo->z -= mo->SpawnPoint[2] << FRACBITS;

	// something is occupying its position?
	if (!P_TestMobjLocation (mo))
	{
		//[GrafZahl] MF_COUNTKILL still needs to be checked here.
		if (mo->CountsAsKill()) level.total_monsters--;
		mo->Destroy ();
		return;		// no respawn
	}

	z = mo->z;

	// inherit attributes from deceased one
	mo->SpawnPoint[0] = mobj->SpawnPoint[0];
	mo->SpawnPoint[1] = mobj->SpawnPoint[1];
	mo->SpawnPoint[2] = mobj->SpawnPoint[2];
	mo->SpawnAngle = mobj->SpawnAngle;
	mo->SpawnFlags = mobj->SpawnFlags;
	mo->angle = ANG45 * (mobj->SpawnAngle/45);

	mo->HandleSpawnFlags ();
	mo->reactiontime = 18;
	mo->CopyFriendliness (mobj, false);
	mo->Translation = mobj->Translation;

	// spawn a teleport fog at old spot because of removal of the body?
	mo = Spawn ("TeleportFog", mobj->x, mobj->y, mobj->z, ALLOW_REPLACE);
	if (mo != NULL)
	{
		mo->z += TELEFOGHEIGHT;
	}

	// spawn a teleport fog at the new spot
	mo = Spawn ("TeleportFog", x, y, z, ALLOW_REPLACE);
	if (mo != NULL)
	{
		mo->z += TELEFOGHEIGHT;
	}

	// remove the old monster
	mobj->Destroy ();
}


AActor *AActor::TIDHash[128];

//
// P_ClearTidHashes
//
// Clears the tid hashtable.
//

void AActor::ClearTIDHashes ()
{
	int i;

	for (i = 0; i < 128; i++)
		TIDHash[i] = NULL;
}

//
// P_AddMobjToHash
//
// Inserts an mobj into the correct chain based on its tid.
// If its tid is 0, this function does nothing.
//
void AActor::AddToHash ()
{
	if (tid == 0)
	{
		iprev = NULL;
		inext = NULL;
		return;
	}
	else
	{
		int hash = TIDHASH (tid);

		inext = TIDHash[hash];
		iprev = &TIDHash[hash];
		TIDHash[hash] = this;
		if (inext)
		{
			inext->iprev = &inext;
		}
	}
}

//
// P_RemoveMobjFromHash
//
// Removes an mobj from its hash chain.
//
void AActor::RemoveFromHash ()
{
	if (tid != 0 && iprev)
	{
		*iprev = inext;
		if (inext)
		{
			inext->iprev = iprev;
		}
		iprev = NULL;
		inext = NULL;
	}
	tid = 0;
}

angle_t AActor::AngleIncrements ()
{
	return ANGLE_45;
}

void AActor::PreExplode ()
{
}

void AActor::GetExplodeParms (int &damage, int &dist, bool &hurtSource)
{
}

//==========================================================================
//
// AActor :: GetMissileDamage
//
// If the actor's damage amount is an expression, evaluate it and return
// the result. Otherwise, return ((random() & mask) + add) * damage.
//
//==========================================================================

int AActor::GetMissileDamage (int mask, int add)
{
	if ((Damage & 0xC0000000) == 0x40000000)
	{
		return EvalExpressionI (Damage & 0x3FFFFFFF, this);
	}
	if (Damage == 0)
	{
		return 0;
	}
	else if (mask == 0)
	{
		return add * Damage;
	}
	else
	{
		return ((pr_missiledamage() & mask) + add) * Damage;
	}
}

void AActor::Howl ()
{
	int howl = GetClass()->Meta.GetMetaInt(AMETA_HowlSound);
	if (!S_IsActorPlayingSomething(this, CHAN_BODY, howl))
	{
		S_SoundID (this, CHAN_BODY, howl, 1, ATTN_NORM);
	}
}

void AActor::NoBlockingSet ()
{
}

fixed_t AActor::GetSinkSpeed ()
{
	return FRACUNIT;
}

fixed_t AActor::GetRaiseSpeed ()
{
	return 2*FRACUNIT;
}

void AActor::HitFloor ()
{
}

bool AActor::Slam (AActor *thing)
{
	flags &= ~MF_SKULLFLY;
	momx = momy = momz = 0;
	if (health > 0)
	{
		if (!(flags2 & MF2_DORMANT))
		{
			int dam = GetMissileDamage (7, 1);
			P_DamageMobj (thing, this, this, dam, NAME_Melee);
			P_TraceBleed (dam, thing, this);
			SetState (SeeState != NULL ? SeeState : SpawnState);
		}
		else
		{
			SetState (SpawnState);
			tics = -1;
		}
	}
	return false;			// stop moving
}

bool AActor::SpecialBlastHandling (AActor *source, fixed_t strength)
{
	return true;
}

int AActor::SpecialMissileHit (AActor *victim)
{
	return -1;
}

bool AActor::AdjustReflectionAngle (AActor *thing, angle_t &angle)
{
	if (flags2 & MF2_DONTREFLECT) return true;

	// Change angle for reflection
	if (thing->flags4&MF4_SHIELDREFLECT)
	{
		// Shield reflection (from the Centaur
		if (abs (angle - thing->angle)>>24 > 45)
			return true;	// Let missile explode

		if (thing->IsKindOf (RUNTIME_CLASS(AHolySpirit)))	// shouldn't this be handled by another flag???
			return true;

		if (pr_reflect () < 128)
			angle += ANGLE_45;
		else
			angle -= ANGLE_45;

	}
	else if (thing->flags4&MF4_DEFLECT)
	{
		// deflect (like the Heresiarch)
		if(pr_reflect() < 128)
			angle += ANG45;
		else
			angle -= ANG45;
	}
	else
		angle += ANGLE_1 * ((pr_reflect()%16)-8);
	return false;
}

void AActor::PlayActiveSound ()
{
	if (ActiveSound && !S_IsActorPlayingSomething (this, CHAN_VOICE, -1))
	{
		S_SoundID (this, CHAN_VOICE, ActiveSound, 1,
			(flags3 & MF3_FULLVOLACTIVE) ? ATTN_NONE : ATTN_IDLE);
	}
}

bool AActor::IsOkayToAttack (AActor *link)
{
	if (player)				// Minotaur looking around player
	{

		if ((link->flags3 & MF3_ISMONSTER) ||
			(link->player && (link != this)))
		{
			if (!(link->flags&MF_SHOOTABLE))
			{
				return false;
			}
			if (link->flags2&MF2_DORMANT)
			{
				return false;
			}
			if ((link->IsKindOf (RUNTIME_CLASS(AMinotaur))) &&
				(link->tracer == this))
			{
				return false;
			}
			//GHK: added for new sentry turrets
			if ((link->IsKindOf (PClass::FindClass ("TurretA"))) &&
				(link->tracer == this))
			{
				return false;
			}

			if (multiplayer && !deathmatch && link->player)
			{
				return false;
			}
			if (P_CheckSight (this, link))
			{
				return true;
			}
		}
	}
	return false;
}

void AActor::SetShade (DWORD rgb)
{
	PalEntry *entry = (PalEntry *)&rgb;
	alphacolor = rgb | (ColorMatcher.Pick (entry->r, entry->g, entry->b) << 24);
}

void AActor::SetShade (int r, int g, int b)
{
	alphacolor = MAKEARGB(ColorMatcher.Pick (r, g, b), r, g, b);
}

//
// P_MobjThinker
//

CVAR(Bool, sv_rocketsmoke, false, CVAR_ARCHIVE|CVAR_SERVERINFO)

void AActor::Tick ()
{
	if (effects&FX_ROCKET && sv_rocketsmoke && ++visdir==4)
	{
		// add some smoke behind the rocket
		visdir=0;
		AActor * th = Spawn("RocketSmokeTrail", x-momx, y-momy, z, ALLOW_REPLACE);
		if (th)
		{
			th->momz = FRACUNIT;
			th->tics -= pr_rockettrail()&3;
			if (th->tics < 1) th->tics = 1;
		}
	}




	// [RH] Data for Heretic/Hexen scrolling sectors
	static const BYTE HexenScrollDirs[8] = { 64, 0, 192, 128, 96, 32, 224, 160 };
	static const BYTE HexenSpeedMuls[3] = { 5, 10, 25 };
	static const SBYTE HexenScrollies[24][2] =
	{
		{  0,  1 }, {  0,  2 }, {  0,  4 },
		{ -1,  0 }, { -2,  0 }, { -4,  0 },
		{  0, -1 }, {  0, -2 }, {  0, -4 },
		{  1,  0 }, {  2,  0 }, {  4,  0 },
		{  1,  1 }, {  2,  2 }, {  4,  4 },
		{ -1,  1 }, { -2,  2 }, { -4,  4 },
		{ -1, -1 }, { -2, -2 }, { -4, -4 },
		{  1, -1 }, {  2, -2 }, {  4, -4 }
	};

	static const BYTE HereticScrollDirs[4] = { 6, 9, 1, 4 };
	static const BYTE HereticSpeedMuls[5] = { 5, 10, 25, 30, 35 };

	AActor *onmo;
	int i;

	assert (state != NULL);
	if (state == NULL)
	{
		Destroy();
		return;
	}

	PrevX = x;
	PrevY = y;
	PrevZ = z;

	AInventory * item = Inventory;

	// Handle powerup effects here so that the order is controlled
	// by the order in the inventory, not the order in the thinker table
	while (item != NULL && item->Owner == this)
	{
		item->DoEffect();
		item = item->Inventory;
	}

	if (flags & MF_UNMORPHED)
	{
		return;
	}

	//Added by MC: Freeze mode.
	if (bglobal.freeze && !(player && !player->isbot))
	{
		return;
	}

	// Apply freeze mode.
	if (( level.flags & LEVEL_FROZEN ) && ( player == NULL || !( player->cheats & CF_TIMEFREEZE )))
	{
		return;
	}


	fixed_t oldz = z;

	// [RH] Give the pain elemental vertical friction
	// This used to be in APainElemental::Tick but in order to use
	// A_PainAttack with other monsters it has to be here!
	if (flags4 & MF4_VFRICTION)
	{
		if (health >0)
		{
			if (abs (momz) < FRACUNIT/4)
			{
				momz = 0;
				flags4 &= ~MF4_VFRICTION;
			}
			else
			{
				momz = FixedMul (momz, 0xe800);
			}
		}
	}

	// [RH] Pulse in and out of visibility
	if (effects & FX_VISIBILITYPULSE)
	{
		if (visdir > 0)
		{
			alpha += 0x800;
			if (alpha >= OPAQUE)
			{
				alpha = OPAQUE;
				visdir = -1;
			}
		}
		else
		{
			alpha -= 0x800;
			if (alpha <= TRANSLUC25)
			{
				alpha = TRANSLUC25;
				visdir = 1;
			}
		}
	}
	else if (flags & MF_STEALTH)
	{
		// [RH] Fade a stealth monster in and out of visibility
		if (visdir > 0)
		{
			alpha += 2*FRACUNIT/TICRATE;
			if (alpha > OPAQUE)
			{
				alpha = OPAQUE;
				visdir = 0;
			}
		}
		else if (visdir < 0)
		{
			alpha -= 3*FRACUNIT/TICRATE/2;
			if (alpha < 0)
			{
				alpha = 0;
				visdir = 0;
			}
		}
	}

	if (bglobal.botnum && consoleplayer == Net_Arbitrator && !demoplayback &&
		(flags & (MF_SPECIAL|MF_MISSILE)) || (flags3 & MF3_ISMONSTER))
	{
		clock (BotSupportCycles);
		bglobal.m_Thinking = true;
		for (i = 0; i < MAXPLAYERS; i++)
		{
			if (!playeringame[i] || !players[i].isbot)
				continue;

			if (flags3 & MF3_ISMONSTER)
			{
				if (health > 0
					&& !players[i].enemy
					&& player ? !IsTeammate (players[i].mo) : true
					&& P_AproxDistance (players[i].mo->x-x, players[i].mo->y-y) < MAX_MONSTER_TARGET_DIST
					&& P_CheckSight (players[i].mo, this, 2))
				{ //Probably a monster, so go kill it.
					players[i].enemy = this;
				}
			}
			else if (flags & MF_SPECIAL)
			{ //Item pickup time
				//clock (BotWTG);
				bglobal.WhatToGet (players[i].mo, this);
				//unclock (BotWTG);
				BotWTG++;
			}
			else if (flags & MF_MISSILE)
			{
				if (!players[i].missile && (flags3 & MF3_WARNBOT))
				{ //warn for incoming missiles.
					if (target != players[i].mo && bglobal.Check_LOS (players[i].mo, this, ANGLE_90))
						players[i].missile = this;
				}
			}
		}
		bglobal.m_Thinking = false;
		unclock (BotSupportCycles);
	}

	//End of MC

	// [RH] Consider carrying sectors here
	fixed_t cummx = 0, cummy = 0;
	if ((level.Scrolls != NULL || player != NULL) && !(flags & MF_NOCLIP) && !(flags & MF_NOSECTOR))
	{
		fixed_t height, waterheight;	// killough 4/4/98: add waterheight
		const msecnode_t *node;
		int countx, county;

		// killough 3/7/98: Carry things on floor
		// killough 3/20/98: use new sector list which reflects true members
		// killough 3/27/98: fix carrier bug
		// killough 4/4/98: Underwater, carry things even w/o gravity

		// Move objects only if on floor or underwater,
		// non-floating, and clipped.

		countx = county = 0;

		for (node = touching_sectorlist; node; node = node->m_tnext)
		{
			const sector_t *sec = node->m_sector;
			fixed_t scrollx, scrolly;

			if (level.Scrolls != NULL)
			{
				const FSectorScrollValues *scroll = &level.Scrolls[sec - sectors];
				scrollx = scroll->ScrollX;
				scrolly = scroll->ScrollY;
			}
			else
			{
				scrollx = scrolly = 0;
			}

			if (player != NULL)
			{
				int scrolltype = sec->special & 0xff;

				if (scrolltype >= Scroll_North_Slow &&
					scrolltype <= Scroll_SouthWest_Fast)
				{ // Hexen scroll special
					scrolltype -= Scroll_North_Slow;
					if (i_compatflags&COMPATF_RAVENSCROLL)
					{
						angle_t fineangle = HexenScrollDirs[scrolltype / 3] * 32;
						fixed_t carryspeed = DivScale32 (HexenSpeedMuls[scrolltype % 3], 32*CARRYFACTOR);
						scrollx += FixedMul (carryspeed, finecosine[fineangle]);
						scrolly += FixedMul (carryspeed, finesine[fineangle]);
					}
					else
					{
						// Use speeds that actually match the scrolling textures!
						scrollx -= HexenScrollies[scrolltype][0] << (FRACBITS-1);
						scrolly += HexenScrollies[scrolltype][1] << (FRACBITS-1);
					}
				}
				else if (scrolltype >= Carry_East5 &&
						 scrolltype <= Carry_West35)
				{ // Heretic scroll special
					scrolltype -= Carry_East5;
					BYTE dir = HereticScrollDirs[scrolltype / 5];
					fixed_t carryspeed = DivScale32 (HereticSpeedMuls[scrolltype % 5], 32*CARRYFACTOR);
					if (scrolltype<=Carry_East35 && !(i_compatflags&COMPATF_RAVENSCROLL))
					{
						// Use speeds that actually match the scrolling textures!
						carryspeed = (1 << ((scrolltype%5) + FRACBITS-1));
					}
					scrollx += carryspeed * ((dir & 3) - 1);
					scrolly += carryspeed * (((dir & 12) >> 2) - 1);
				}
				else if (scrolltype == dScroll_EastLavaDamage)
				{ // Special Heretic scroll special
					if (i_compatflags&COMPATF_RAVENSCROLL)
					{
						scrollx += DivScale32 (28, 32*CARRYFACTOR);
					}
					else
					{
						// Use a speed that actually matches the scrolling texture!
						scrollx += DivScale32 (12, 32*CARRYFACTOR);
					}
				}
				else if (scrolltype == Scroll_StrifeCurrent)
				{ // Strife scroll special
					int anglespeed = sec->tag - 100;
					fixed_t carryspeed = DivScale32 (anglespeed % 10, 16*CARRYFACTOR);
					angle_t fineangle = (anglespeed / 10) << (32-3);
					fineangle >>= ANGLETOFINESHIFT;
					scrollx += FixedMul (carryspeed, finecosine[fineangle]);
					scrolly += FixedMul (carryspeed, finesine[fineangle]);
				}
			}

			if ((scrollx | scrolly) == 0)
			{
				continue;
			}
			if (flags & MF_NOGRAVITY &&
				(sec->heightsec == NULL || (sec->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC)))
			{
				continue;
			}
			height = sec->floorplane.ZatPoint (x, y);
			if (z > height)
			{
				if (sec->heightsec == NULL || (sec->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC))
				{
					continue;
				}

				waterheight = sec->heightsec->floorplane.ZatPoint (x, y);
				if (waterheight > height && z >= waterheight)
				{
					continue;
				}
			}

			cummx += scrollx;
			cummy += scrolly;
			if (scrollx) countx++;
			if (scrolly) county++;
		}

		// Some levels designed with Boom in mind actually want things to accelerate
		// at neighboring scrolling sector boundaries. But it is only important for
		// non-player objects.
		if (player != NULL || !(i_compatflags & COMPATF_BOOMSCROLL))
		{
			if (countx > 1)
			{
				cummx /= countx;
			}
			if (county > 1)
			{
				cummy /= county;
			}
		}
	}

	// [RH] If standing on a steep slope, fall down it
	if ((flags & MF_SOLID) && !(flags & (MF_NOCLIP|MF_NOGRAVITY)) &&
		!(flags & MF_NOBLOCKMAP) &&
		momz <= 0 &&
		floorz == z)
	{
		const secplane_t * floorplane = &floorsector->floorplane;
		static secplane_t copyplane;

		// Check 3D floors as well
		for(unsigned int i=0;i<floorsector->e->ffloors.Size();i++)
		{
			F3DFloor * rover= floorsector->e->ffloors[i];
			if(!(rover->flags & FF_SOLID) || !(rover->flags & FF_EXISTS)) continue;

			if (rover->top.plane->ZatPoint(x, y) == floorz)
			{
				copyplane = *rover->top.plane;
				if (copyplane.c<0) copyplane.FlipVert();
				floorplane = &copyplane;
				break;
			}
		}

		if (floorplane->c < STEEPSLOPE &&
			floorplane->ZatPoint (x, y) <= floorz)
		{
			const msecnode_t *node;
			bool dopush = true;

			if (floorplane->c > STEEPSLOPE*2/3)
			{
				for (node = touching_sectorlist; node; node = node->m_tnext)
				{
					const sector_t *sec = node->m_sector;
					if (sec->floorplane.c >= STEEPSLOPE)
					{
						if (floorplane->ZatPoint (x, y) >= z - MaxStepHeight)
						{
							dopush = false;
							break;
						}
					}
				}
			}
			if (dopush)
			{
				momx += floorplane->a;
				momy += floorplane->b;
			}
		}
	}

	// [RH] Missiles moving perfectly vertical need some X/Y movement, or they
	// won't hurt anything. Don't do this if damage is 0! That way, you can
	// still have missiles that go straight up and down through actors without
	// damaging anything.
	if ((flags & MF_MISSILE) && (momx|momy) == 0 && Damage != 0)
	{
		momx = 1;
	}

	// Handle X and Y momemtums
	BlockingMobj = NULL;
	P_XYMovement (this, cummx, cummy);
	if (ObjectFlags & OF_MassDestruction)
	{ // actor was destroyed
		return;
	}
	if ((momx | momy) == 0 && (flags2 & MF2_BLASTED))
	{ // Reset to not blasted when momentums are gone
		flags2 &= ~MF2_BLASTED;
	}

	if (flags2 & MF2_FLOATBOB)
	{ // Floating item bobbing motion
		z += FloatBobDiffs[(FloatBobPhase + level.maptime) & 63];
	}
	if (momz || BlockingMobj ||
		(z != floorz && (!(flags2 & MF2_FLOATBOB) ||
		(z - FloatBobOffsets[(FloatBobPhase + level.maptime) & 63] != floorz)
		)))
	{	// Handle Z momentum and gravity
		if (((flags2 & MF2_PASSMOBJ) || (flags & MF_SPECIAL)) && !(i_compatflags & COMPATF_NO_PASSMOBJ))
		{
			if (!(onmo = P_CheckOnmobj (this)))
			{
				P_ZMovement (this);
				flags2 &= ~MF2_ONMOBJ;
			}
			else
			{
				if (player)
				{
					if (momz < (fixed_t)(level.gravity * Sector->gravity * -655.36f)
						&& !(flags&MF_NOGRAVITY))
					{
						PlayerLandedOnThing (this, onmo);
					}
				}
				if (onmo->z + onmo->height - z <= MaxStepHeight)
				{
					if (player && player->mo == this)
					{
						player->viewheight -= onmo->z + onmo->height - z;
						fixed_t deltaview = player->GetDeltaViewHeight();
						if (deltaview > player->deltaviewheight)
						{
							player->deltaviewheight = deltaview;
						}
					}
					z = onmo->z + onmo->height;
				}
				flags2 |= MF2_ONMOBJ;
				momz = 0;
				Crash();
			}
		}
		else
		{
			P_ZMovement (this);
		}

		if (ObjectFlags & OF_MassDestruction)
			return;		// actor was destroyed
	}
	else if (z <= floorz)
	{
		Crash();
	}

	UpdateWaterLevel (oldz);

	// [RH] Don't advance if predicting a player
	if (player && (player->cheats & CF_PREDICTING))
	{
		return;
	}

	// cycle through states, calling action functions at transitions
	if (tics != -1)
	{
		tics--;

		// you can cycle through multiple states in a tic
		// [RH] Use <= 0 instead of == 0 so that spawnstates
		// of 0 tics work as expected.
		if (tics <= 0)
		{
			assert (state != NULL);
			if (state == NULL)
			{
				Destroy();
				return;
			}
			if (!SetState (state->GetNextState()))
				return; 		// freed itself
		}
	}
	else
	{
		int respawn_monsters = G_SkillProperty(SKILLP_Respawn);
		// check for nightmare respawn
		if (!respawn_monsters || !(flags3 & MF3_ISMONSTER) || (flags2 & MF2_DORMANT))
			return;

		movecount++;

		if (movecount < respawn_monsters)
			return;

		if (level.time & 31)
			return;

		if (pr_nightmarerespawn() > 4)
			return;

		P_NightmareRespawn (this);
	}

	//GHK SSHOTTY LAG FIX

	if(sd_alt_con_scoring){

		if(player!=NULL&&multidmgbuffer>0){

			if(CheckLocalView(consoleplayer)){
				char levelscore[10];

				sprintf(levelscore,"+ %d",multidmgbuffer);
                Printf (PRINT_MEDIUM, "%s\n", levelscore);

            }
		}



         multidmgbuffer=0; //reset the buffer to 0 every tick after spitting out damage
		 lastpnumdmg=MAXPLAYERS+1; //reset the target's last playernum who damaged me' var :-)


	}

	//int dmflagsval=dmflags;
//Printf("dmflags ...%d\n%d\n%d\n",dmflagsval,sd_dmflags,(dmflags & ~sd_dmflags));


	//GHK  anti-cheating code for global hi-scoring
	if(sd_global_hiscores&&sd_remote_hiscores_ok&!multiplayer){

		//if(sd_extrahealth_chance!=35&&sd_artifact_chance!=10){

		//}
		//no auto-running, bfg smartaiming or non-default dmflags
		//if(cl_run||sv_smartaim||dmflags!=0||dmflags2!=0){
		//allow autorun
		if(sv_smartaim||(dmflags & ~sd_dmflags)!=0||dmflags2!=0||sp_random_custom_monsters||sp_random_custom_monsters2||sv_cheats||sv_fastweapons||!(sd_bossrush&&sd_bossrush2)){
				sd_remote_hiscores_ok=false;
				Printf ("For Online Hi Score tables...\n");
				Printf ("You must set dmflags=0 and dmflags2=0 in the Gameplay Options.\n");
				Printf ("In your zdoom ini, you must set 'sd_custom_replacements'\n");
				Printf ("to false.\n");
				Printf ("You must also set sv_smartaim, sv_cheats & sv_fastweapons to 0, and sd_bossrush to true\n");
				Printf ("**ONLINE HI SCORING DISABLED**\n");
				//C_MidPrint("SD global hi scoring disabled");
				S_Sound (players[0].mo,CHAN_VOICE, "misc/chtblp", 1, ATTN_NORM);
		}/*else if(sd_extrahealth_chance!=35&&sd_artifact_chance!=10){
			sd_remote_hiscores_ok=false;
			Printf ("For Online Hi Score tables...\n");
			Printf ("You must set sd_extrahealth_chance=35 and sd_artifact_chance=10\n");
			Printf ("in your zdoom ini file. Which are their default values.\n");
			Printf ("**ONLINE HI SCORING DISABLED**\n");
			//C_MidPrint("SD global hi scoring disabled");
			S_Sound (players[0].mo,CHAN_VOICE, "misc/chtblp", 1, ATTN_NORM);

		}*/
		if(sd_online_level>1&&sd_global_hiscores==1){ //we are in hardcore-online mode, but player set console var to regular-online mode
				Printf ("For Hardcore Hi Score tables...\n");
				Printf ("You must stick to Hardcore Mode\n");
				S_Sound (players[0].mo,CHAN_VOICE, "misc/chtblp", 1, ATTN_NORM);
				sd_remote_hiscores_ok=false;

		}

	}

}

//==========================================================================
//
// AActor::UpdateWaterLevel
//
// Returns true if actor should splash
//
//==========================================================================

bool AActor::UpdateWaterLevel (fixed_t oldz, bool dosplash)
{
	BYTE lastwaterlevel = waterlevel;
	fixed_t fh=FIXED_MIN;
	bool reset=false;

	waterlevel = 0;

	if (Sector == NULL)
	{
		return false;
	}

	if (Sector->MoreFlags & SECF_UNDERWATERMASK)
	{
		waterlevel = 3;
	}
	else
	{
		const sector_t *hsec = Sector->heightsec;
		if (hsec != NULL && !(hsec->MoreFlags & SECF_IGNOREHEIGHTSEC))
		{
			fh = hsec->floorplane.ZatPoint (x, y);
			//if (hsec->MoreFlags & SECF_UNDERWATERMASK)	// also check Boom-style non-swimmable sectors!
			{
				if (z < fh)
				{
					waterlevel = 1;
					if (z + height/2 < fh)
					{
						waterlevel = 2;
						if ((player && z + player->viewheight <= fh) ||
							(z + height <= fh))
						{
							waterlevel = 3;
						}
					}
				}
				else if (z + height > hsec->ceilingplane.ZatPoint (x, y))
				{
					waterlevel = 3;
				}
				else
				{
					waterlevel=0;
				}
			}
			// even non-swimmable deep water must be checked here to do the splashes correctly
			// But the water level must be reset when this function returns!
			if (!(hsec->MoreFlags&SECF_UNDERWATERMASK)) reset=true;
		}
		else
		{
			// Check 3D floors as well!
			for(int i=0;i<Sector->e->ffloors.Size();i++)
			{
				F3DFloor*  rover=Sector->e->ffloors[i];

				if (!(rover->flags & FF_EXISTS)) continue;
				if(!(rover->flags & FF_SWIMMABLE) || rover->flags & FF_SOLID) continue;

				fixed_t ff_bottom=rover->bottom.plane->ZatPoint(x, y);
				fixed_t ff_top=rover->top.plane->ZatPoint(x, y);

				if(ff_top <= z || ff_bottom > (z + (height >> 1))) continue;

				fh=ff_top;
				if (z < fh)
				{
					waterlevel = 1;
					if (z + height/2 < fh)
					{
						waterlevel = 2;
						if ((player && z + player->viewheight <= fh) ||
							(z + height <= fh))
						{
							waterlevel = 3;
						}
					}
				}

				break;
			}
		}
	}

	// some additional checks to make deep sectors  la Boom splash without setting
	// the water flags.
	if (boomwaterlevel == 0 && waterlevel != 0 && dosplash) P_HitWater(this, Sector, fh);
	boomwaterlevel=waterlevel;
	if (reset) waterlevel=lastwaterlevel;
	return false;	// we did the splash ourselves! ;)
}

//----------------------------------------------------------------------------
//
// PROC A_FreeTargMobj
//
//----------------------------------------------------------------------------

void A_FreeTargMobj (AActor *mo)
{
	mo->momx = mo->momy = mo->momz = 0;
	mo->z = mo->ceilingz + 4*FRACUNIT;
	mo->flags &= ~(MF_SHOOTABLE|MF_FLOAT|MF_SKULLFLY|MF_SOLID);
	mo->flags |= MF_CORPSE|MF_DROPOFF|MF_NOGRAVITY;
	mo->flags2 &= ~MF2_PASSMOBJ;
	mo->gravity = FRACUNIT;
	mo->player = NULL;

}

//==========================================================================
//
// A_GenericFreezeDeath
//
//==========================================================================

void A_GenericFreezeDeath (AActor *actor)
{
	actor->Translation = TRANSLATION(TRANSLATION_Standard, 7);
	A_FreezeDeath (actor);
}

//==========================================================================
//
// AActor stuff
//
//==========================================================================

FState AActor::States[] =
{
	S_NORMAL (TNT1, 'A', -1, NULL, NULL),
	S_NORMAL (TNT1, 'E', 1050, A_FreeTargMobj, NULL),
	S_NORMAL (TNT1, 'A', 1, NULL, NULL),	// S_NULL

	// Generic freeze death frames. Woo!
	S_NORMAL (----, 'A', 5, A_GenericFreezeDeath, &States[4]),
	S_NORMAL (----, 'A', 1, A_FreezeDeathChunks, &States[4])
};

BEGIN_DEFAULTS (AActor, Any, -1, 0)
	PROP_XScale (FRACUNIT)
	PROP_YScale (FRACUNIT)
	PROP_SpawnState (2)
	PROP_SpawnHealth (1000)
	PROP_ReactionTime (8)
	PROP_RadiusFixed (20)
	PROP_HeightFixed (16)
	PROP_Mass (100)
	PROP_RenderStyle (STYLE_Normal)
	PROP_Alpha (FRACUNIT)
	PROP_MinMissileChance (200)
	PROP_MeleeRange(44)		// MELEERANGE(64) - 20
	PROP_MaxDropOffHeight(24)
	PROP_MaxStepHeight(24)
	PROP_BounceFactor(FRACUNIT*7/10)
	PROP_BounceCount(-1)
	PROP_FloatSpeed(4)
	PROP_Gravity(FRACUNIT)
END_DEFAULTS


//GHK: GetRandomMonster
//every other monster with spawnid in top function is
//called, so break up the monster equally.
//WEIRDNESS: pr_gkspawnchance(x): in the range 0->x should all be called relatively
//equally, but the last vale x never seems to be called, so I add an extra value at the end
//for a buffer of sorts (i.e. pr_gkspawnchance(x+1)).
//blGetMonsters arg was added so that the artifact spawning code in this function
//could be used with the new custom ini monster spawning code
const PClass *PClass::GetRandomMonster(const PClass *type, const int rand, fixed_t ix, fixed_t iy, fixed_t iz, bool blGetMonsters){
	const PClass *newtypeinfo; //GHK experimental code

	//GHK Experimental custom decorate monster replacement code
	//int rnd = M_Random (8);
	//int rnd=0;
	int rnd=0;

	newtypeinfo=type;


	//GHK, Need to consider if we want to spawn SD replacement monsters
	//for levels utilizing ACS. The sdmonsters DECORATE needs Thing IDs added for every monster
	//Additionally ThingCount and ThingCountName and other ACS functions which call actionspecials
	//from ACS script will sometimes add a TID, which simply is not supported by SD monsters
	//SO... either let players use sd monsters at their own risk with ACS wads, or
	//just disable by default.

	if(blGetMonsters&&FBehavior::StaticModules.Size()>0){
		//return newtypeinfo;
		blGetMonsters=false;
	}

	if(blGetMonsters){

		switch (type->ActorInfo->SpawnID)
		{

			case 1: //shot guy

				//every other sergeant replaced
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%27;
				else
					rnd=pr_gkspawnchance(27);

				switch (rnd){

					case 0:
					case 1:
						newtypeinfo = PClass::FindClass ("SSGZombie");
						break;
					case 2:
					case 3:
						newtypeinfo = PClass::FindClass ("SuicideBomber");
						break;
					case 4:
						newtypeinfo = PClass::FindClass ("PlasmaZombie2");
						break;
					case 5:
					case 6:
						newtypeinfo = PClass::FindClass ("RocketGuy");
						break;
					//case 6:
						//newtypeinfo = PClass::FindClass ("StealthFighter");
						//break;
					case 7:
						newtypeinfo = PClass::FindClass ("Thrall");
						break;
					case 8:
					case 9:
						newtypeinfo = PClass::FindClass ("ZombieRailgunner");
						break;
					case 10:
					case 11:
					case 12:
					case 16:
					case 18:
					case 19:
					case 20:
					case 21:
					case 22:
					case 23:
					case 24:
					case 25:
						{
							int rnd2=0;
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd2=M_Random2()%15;
							else
								rnd2=pr_gkspawnchance(15);

							switch(rnd2){
								case 0:
									//newtypeinfo = PClass::FindClass ("FUziGuy");
									newtypeinfo = PClass::FindClass ("PlasmaZombie2");
										break;
								case 1:
									newtypeinfo = PClass::FindClass ("ZombieMarine");
									break;
								case 2:
									newtypeinfo = PClass::FindClass ("StealthFighter");
									break;
								case 3:
									//pk3
									newtypeinfo = PClass::FindClass ("DBTPawn");
									break;
								case 4:
									newtypeinfo = PClass::FindClass ("LaserCannonZombie");
									break;
								case 5:
									newtypeinfo = PClass::FindClass ("FCommander");
									break;
								case 6:
								case 7:
									newtypeinfo = PClass::FindClass ("ZSec");
									break;
								case 8:
									newtypeinfo = PClass::FindClass ("RepeaterZombie");
									break;
								case 9:
									newtypeinfo = PClass::FindClass ("XimRocketGuy");
									break;
								case 10:
									newtypeinfo = PClass::FindClass ("JetpackZombie");
									break;
								case 11:
									newtypeinfo = PClass::FindClass ("DuneWarrior");
									break;
								case 12:
									newtypeinfo = PClass::FindClass ("NailBorg");
									break;
								case 13:
									newtypeinfo = PClass::FindClass ("UnmakerGuy");
									break;
								case 14:
								case 15:
									newtypeinfo = PClass::FindClass ("SonicRailgunZombie");
									break;

							}

						}
						break;
					case 13:
						newtypeinfo = PClass::FindClass ("UndeadPriest");
						break;
					case 14: //pk3
						newtypeinfo = PClass::FindClass ("Railbot");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("SawedOffShotgunGuy");
						break;
					//case 16:
						//newtypeinfo = PClass::FindClass ("UnmakerGuy");
						//break;
					case 17:
						newtypeinfo = PClass::FindClass ("ReaperZombie");
						break;
					case 26:
					case 27:
						newtypeinfo = PClass::FindClass ("Priest");
						break;

				}
				break;
			case 2: // Chaingunner

				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%17;
				else
				rnd=pr_gkspawnchance(17);
				switch (rnd){

					case 0:
					case 1:
						newtypeinfo = PClass::FindClass ("ChaingunGuy2");
						break;
						//newtypeinfo = PClass::FindClass ("Catharsi");
						//break;
					case 2:
						newtypeinfo = PClass::FindClass ("FCommander2");
						break;
					case 3:
					case 4:
						newtypeinfo = PClass::FindClass ("ChaingunMajor");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("Disciple");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("MarineBFG2SD");
						break;
						//{
						//GHK: horrible, horrible HACK. This stops this AScriptedMarine showing up in
						//non GZMONSTERS1.1.WAD games, BUT requires that ONLY GZMONSTERS1.1WAD
						//is supported with ScoreDoom..which is actually OK
						//**NO need for it now, call MarineBFG2 now!!!

						//const PClass *testType= PClass::FindClass ("ChaingunGuy2");
						//if(testType != NULL && testType->ActorInfo != NULL){
						//	newtypeinfo = PClass::FindClass ("MarineBFG");
						//}
						//break;
						//newtypeinfo = PClass::FindClass ("Disciple");
						//break;
						//}
					case 7:
						//pk3
						newtypeinfo = PClass::FindClass ("LaserCannonZombie");
						break;
					case 8:
						//pk3
						newtypeinfo = PClass::FindClass ("PlasmaZombie");
						break;
					case 9:
						//pk3
						newtypeinfo = PClass::FindClass ("DBTPawn");
						break;
					case 10:
						newtypeinfo = PClass::FindClass ("UndeadPriest");
						break;
					case 11:
						newtypeinfo = PClass::FindClass ("UnmakerGuy");
						break;
					case 12:
						newtypeinfo = PClass::FindClass ("XimRocketGuy");
						break;
					case 13:
						newtypeinfo = PClass::FindClass ("RepeaterZombie");
						break;
					case 14:
						newtypeinfo = PClass::FindClass ("SonicRailgunZombie");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("JetpackZombie");
						break;
					case 16:
					case 17:
						//pk3
						newtypeinfo = PClass::FindClass ("ApprenticeofDsparil");
						break;
				}
				break;
			case 3: // Baron of Hell
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%19;
				else
				rnd=pr_gkspawnchance(19);
				//THIS CODE OK???? RETURNS NULL?
				if(PClass::FindClass ("BaronOfHellHARD")){ //look for sdmonstershardboss wad
					switch (rnd){

						case 0:
							newtypeinfo = PClass::FindClass ("AfritHARD");
							break;
						case 1:
							newtypeinfo = PClass::FindClass ("ArchonOfHellHARD");
							break;
						case 2:
							newtypeinfo = PClass::FindClass ("BelphegorCloneHARD");
							break;
						case 3:
							//newtypeinfo = PClass::FindClass ("BruiserDemon");
							newtypeinfo = PClass::FindClass ("LordofHeresyHARD");
							break;
						//case 4:
							//newtypeinfo = PClass::FindClass ("Deathknight");
							//break;
						case 4:
							newtypeinfo = PClass::FindClass ("HellsFuryHARD");
							break;
						case 5:
							//newtypeinfo = PClass::FindClass ("LordofHeresy");
							newtypeinfo = PClass::FindClass ("BruiserDemonHARD");
							break;
						case 6:
							newtypeinfo = PClass::FindClass ("CybruiserHARD");
							break;
						case 7://pk3
							newtypeinfo = PClass::FindClass ("BalorHARD");
							break;
						//case 8:
							//newtypeinfo = PClass::FindClass ("ArchonOfHell");
							//break;
						case 8:
							newtypeinfo = PClass::FindClass ("WarlordOfHellHARD");
							break;
						case 9:
							newtypeinfo = PClass::FindClass ("ArchonOfHell2HARD");
							break;
						case 10:
							newtypeinfo = PClass::FindClass ("CyberbaronHARD");
							break;
						case 11:
							newtypeinfo = PClass::FindClass ("PyroDemonHARD");
							break;
						case 12:
							newtypeinfo = PClass::FindClass ("AzazelHARD");
							break;
						case 13:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("DarknessRiftHARD");
									break;
								}else{//ultimate doom wads, ondeath spawns shotgunguy instead
									newtypeinfo = PClass::FindClass ("DarknessRift1HARD");
									break;
								}
							}
							break;
						case 14:
							newtypeinfo = PClass::FindClass ("ThorHARD");
							break;
						case 15:
							newtypeinfo = PClass::FindClass ("BormerethHARD");
							break;
						case 16:
							newtypeinfo = PClass::FindClass ("TerminatorHARD");
							break;
						case 17:
							newtypeinfo = PClass::FindClass ("Desolator2HARD");
							break;
						case 18:
						case 19:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("ChainGunnerTankHARD");
									break;
								}else{//ultimate doom wads, ondeath spawns shotgunguy instead
									newtypeinfo = PClass::FindClass ("ChainGunnerTank2HARD");
									break;
								}
							}

					}
				}else{
					switch (rnd){

						case 0:
							newtypeinfo = PClass::FindClass ("Afrit");
							break;
						case 1:
							newtypeinfo = PClass::FindClass ("ArchonOfHell");
							break;
						case 2:
							newtypeinfo = PClass::FindClass ("BelphegorClone");
							break;
						case 3:
							//newtypeinfo = PClass::FindClass ("BruiserDemon");
							newtypeinfo = PClass::FindClass ("LordofHeresy");
							break;
						//case 4:
							//newtypeinfo = PClass::FindClass ("Deathknight");
							//break;
						case 4:
							newtypeinfo = PClass::FindClass ("HellsFury");
							break;
						case 5:
							//newtypeinfo = PClass::FindClass ("LordofHeresy");
							newtypeinfo = PClass::FindClass ("BruiserDemon");
							break;
						case 6:
							newtypeinfo = PClass::FindClass ("Cybruiser");
							break;
						case 7://pk3
							newtypeinfo = PClass::FindClass ("Balor");
							break;
						//case 8:
							//newtypeinfo = PClass::FindClass ("ArchonOfHell");
							//break;
						case 8:
							newtypeinfo = PClass::FindClass ("WarlordOfHell");
							break;
						case 9:
							newtypeinfo = PClass::FindClass ("ArchonOfHell2");
							break;
						case 10:
							newtypeinfo = PClass::FindClass ("Cyberbaron");
							break;
						case 11:
							newtypeinfo = PClass::FindClass ("PyroDemon");
							break;
						case 12:
							newtypeinfo = PClass::FindClass ("Azazel");
							break;
						case 13:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("DarknessRift");
									break;
								}else{//ultimate doom wads, ondeath spawns shotgunguy instead
									newtypeinfo = PClass::FindClass ("DarknessRift1");
									break;
								}
							}
							break;
						case 14:
							newtypeinfo = PClass::FindClass ("Thor");
							break;
						case 15:
							newtypeinfo = PClass::FindClass ("Bormereth");
							break;
						case 16:
							newtypeinfo = PClass::FindClass ("Terminator");
							break;
						case 17:
							newtypeinfo = PClass::FindClass ("Desolator2");
							break;
						case 18:
						case 19:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("ChainGunnerTank");
									break;
								}else{//ultimate doom wads, ondeath spawns shotgunguy instead
									newtypeinfo = PClass::FindClass ("ChainGunnerTank2");
									break;
								}
							}

					}
				}
				break;
			case 4: //soldier
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%19;
				else
				rnd=pr_gkspawnchance(19);
				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("ChainsawZombie");
						break;
					//case 2:
					//case 3:
						//newtypeinfo = PClass::FindClass ("SpiderImpHead");
						//break;
					//case 2:
						//newtypeinfo = PClass::FindClass ("PlasmaZombie");
						//break;
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
						newtypeinfo = PClass::FindClass ("RapidFireTrooper");
						break;
					case 6:
					case 7:
					case 11:
					case 14:
					case 16:
						//newtypeinfo = PClass::FindClass ("FUziGuy");
						{
							int rnd2=0;
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd2=M_Random2()%12;
							else
								rnd2=pr_gkspawnchance(12);

							switch(rnd2){
								case 0:
									//newtypeinfo = PClass::FindClass ("FUziGuy");
									newtypeinfo = PClass::FindClass ("PlasmaZombie2");
										break;
								case 1:
									newtypeinfo = PClass::FindClass ("ZombieRailgunner");
									break;
								case 2:
								case 3:
									newtypeinfo = PClass::FindClass ("ZSec");
									break;
								case 4:
									//pk3
									newtypeinfo = PClass::FindClass ("MarineBFG2SD");
									break;
								case 5:
									newtypeinfo = PClass::FindClass ("Thrall");
									break;
								case 6:
									newtypeinfo = PClass::FindClass ("SegwayZombie");
									break;
								case 7:
								case 8:
								case 9:
									newtypeinfo = PClass::FindClass ("StealthFighter");
									break;
								case 10:
									newtypeinfo = PClass::FindClass ("ZombieMarine");
									break;
								case 11:
								case 12:
									newtypeinfo = PClass::FindClass ("RocketGuy");
									break;

							}

						}
						break;
					//case 7:
						//newtypeinfo = PClass::FindClass ("StealthFighter");
						//break;
					//case 6:
						//newtypeinfo = PClass::FindClass ("ZombieMarine");
						//break;
					//case 9:
						//newtypeinfo = PClass::FindClass ("ZombieRailgunner");
						//break;
					case 8:
					case 9:
						//pk3
						newtypeinfo = PClass::FindClass ("FZombieMan");
						break;
						/*if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
							newtypeinfo =PClass::FindClass ("MarineBFG");
						}else{
							newtypeinfo =PClass::FindClass ("StealthZombieMan"); //replacement for doom wads
						}
						break;
						*/
					case 10: //pk3
						newtypeinfo = PClass::FindClass ("ZombieMarine");
						break;
					//case 11:
						//newtypeinfo = PClass::FindClass ("ChainsawZombie");
						//break;
					case 12:
					case 13:
					case 15:
					case 17:
					case 18:
					case 19:

						//newtypeinfo = PClass::FindClass ("ZSec");
						//break;
						{
							int rnd2=0;
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd2=M_Random2()%8;
							else
								rnd2=pr_gkspawnchance(8);

							switch(rnd2){
								case 0:
									//newtypeinfo = PClass::FindClass ("FUziGuy");
									newtypeinfo = PClass::FindClass ("PlasmaZombie");
										break;
								case 1:
									newtypeinfo = PClass::FindClass ("ZombieRailgunner");
									break;
								case 2:
									newtypeinfo = PClass::FindClass ("StealthFighter");
									break;
								case 3:
									newtypeinfo = PClass::FindClass ("ZSec");
									break;
								case 4:
									newtypeinfo = PClass::FindClass ("Thrall");
									break;
								case 5:
									newtypeinfo = PClass::FindClass ("SegwayZombie");
									break;
								case 6:
									newtypeinfo = PClass::FindClass ("ReaperZombie");
									break;
								case 7:
								case 8:
									newtypeinfo = PClass::FindClass ("RocketGuy");
									break;

							}

						}

					//case 8:
						//newtypeinfo = PClass::FindClass ("Thrall");
						//break;

				}

				 break;
			case 5: //imp
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%30;
				else
				rnd=pr_gkspawnchance(30);
				switch (rnd){

					//case 0:
						//newtypeinfo = PClass::FindClass ("Priest");
						//break;
					case 0:
						newtypeinfo = PClass::FindClass ("PhaseImp");
						break; //SEE BOTTOM OF SWITCH CASE TOO

					case 1:
						newtypeinfo = PClass::FindClass ("NamiDarkImp");
						break;
					case 2:
						newtypeinfo = PClass::FindClass ("STDarkImp");
						break;
					case 3:
						newtypeinfo = PClass::FindClass ("VoidDarkImp");
						break;
					//case 4:
						//newtypeinfo = PClass::FindClass ("RocketGuy");
						//break;
					case 4:
						newtypeinfo = PClass::FindClass ("Devil");
						break;
					//case 6:
						//newtypeinfo = PClass::FindClass ("Ghoul");
						//break;
					//case 7:
						//newtypeinfo = PClass::FindClass ("ImpWarlord");
						//break;
					//case 8:
						//newtypeinfo = PClass::FindClass ("NetherworldDrone");
						//break;
					case 5:

						newtypeinfo = PClass::FindClass ("Shadow");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("SlimeImp");
						break;
					case 7:
						newtypeinfo = PClass::FindClass ("SnakeImp");
						break;
					case 8:
						newtypeinfo = PClass::FindClass ("StoneImp");
						break;
					case 9:
						newtypeinfo = PClass::FindClass ("SuperImp");
						break;
					case 10:
						newtypeinfo = PClass::FindClass ("SoulHarvester");
						break;
					case 11:
						newtypeinfo = PClass::FindClass ("NetherworldDrone");
						break;
					//case 12:
						//newtypeinfo = PClass::FindClass ("DEWraith");
						//break;
					case 12:
						newtypeinfo = PClass::FindClass ("ImpWarlord");
						break;
					case 13:
						newtypeinfo = PClass::FindClass ("Catharsi");
						break;
					//newtypeinfo = PClass::FindClass ("Ghoul");
						//break;
					case 14:
						newtypeinfo = PClass::FindClass ("Ghoul");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("ArmoredImp");
						break;
					case 16:
						newtypeinfo = PClass::FindClass ("Vulgar");
						break;
					case 17:
						newtypeinfo = PClass::FindClass ("CycloImp");
						break;
					case 18:
						newtypeinfo = PClass::FindClass ("SpiritImp");
						break;
					case 19:
						newtypeinfo = PClass::FindClass ("FoxImp");
						break;
					case 20:
						newtypeinfo = PClass::FindClass ("Illus");
						break;
					case 21:
						newtypeinfo = PClass::FindClass ("Scourge");
						break;
					case 22:
						newtypeinfo = PClass::FindClass ("FlyingImp");
						break;
					case 23:
							{
								int rnd2=0;
								if(!multiplayer&&!sp_random_custom_monsters2)
									rnd2=M_Random2()%2;
								else
									rnd2=pr_gkspawnchance(2);

								switch(rnd2){
									case 0:
										newtypeinfo = PClass::FindClass ("XWizard");
										break;
									case 1:
									case 2:
										newtypeinfo = PClass::FindClass ("FleshWizard");
										break;
								}
							}
							break;
					case 24:
						newtypeinfo = PClass::FindClass ("Hellion");
						break;
					case 25:
						newtypeinfo = PClass::FindClass ("Roach");
						break;
					case 26:
						newtypeinfo = PClass::FindClass ("CyberImp");
						break;
					case 27:
						newtypeinfo = PClass::FindClass ("SuperFlyingImp");
						break;
					case 28:
						newtypeinfo = PClass::FindClass ("D3Wraith");
						break;
					case 29:
					case 30:
						newtypeinfo = PClass::FindClass ("LesserMutant");
						break;

				}
				break;
			case 6: // Arachnotron
				if(rand<126)
					break;

				//Lets not replace on map07 special
				//if(!(level.flags & LEVEL_MAP07SPECIAL)){
					if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%10;
				else
					rnd=pr_gkspawnchance(10);
					switch (rnd){

						case 0:
							newtypeinfo = PClass::FindClass ("ZombieTank");
							break;
						case 1: //pk3
							newtypeinfo = PClass::FindClass ("FusionSpider");
							break;
						case 2:
							newtypeinfo = PClass::FindClass ("Amachotron");
							break;
						case 3:
							newtypeinfo = PClass::FindClass ("SpatterTron");
							break;
						case 4:
							newtypeinfo = PClass::FindClass ("ArachnotronOfHell");
							break;
						case 5:
							newtypeinfo = PClass::FindClass ("SmallInfernalSpider");
							break;
						case 6:
							newtypeinfo = PClass::FindClass ("Crusaderbot");
							break;
						//case 7:
							//newtypeinfo = PClass::FindClass ("HellRoseSpid");
							//break;
						case 7:
							newtypeinfo = PClass::FindClass ("BlackWidow");
							break;
						case 8:
							newtypeinfo = PClass::FindClass ("CGunSpider");
							break;
						case 9:
						case 10:
							newtypeinfo = PClass::FindClass ("RailArachnotron");
							break;
					}
				//}
				break;
			case 7: //spider mstermind
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%21;
				else
				rnd=pr_gkspawnchance(21);
				//newtypeinfo = PClass::FindClass ("Annihilator");
				if(PClass::FindClass ("SpiderMastermindHARD")){ //look for sdmonstershardboss wad
					switch (rnd){

						case 0:
						case 1:
							newtypeinfo = PClass::FindClass ("CyberMastermindHARD");
							break;
						case 2:
						case 3:
							newtypeinfo = PClass::FindClass ("DemolisherHARD");
							break;
						//case 6:
						//case 7:
							//newtypeinfo = PClass::FindClass ("Arachnophyte");
						case 4:
							newtypeinfo = PClass::FindClass ("AnnihilatorHARD");
							break;
						case 5:
						case 6:
							newtypeinfo = PClass::FindClass ("ArachnophyteHARD");
							break;
						case 7:
							newtypeinfo = PClass::FindClass ("AzaniginHARD");
							break;
						case 8:
							newtypeinfo = PClass::FindClass ("ThamuzHARD");
							break;
						case 9:
							newtypeinfo = PClass::FindClass ("InfernuxGrandHARD");
							break;
						case 10:
							newtypeinfo = PClass::FindClass ("ApprenticeHARD");
							break;
						case 11:
							newtypeinfo = PClass::FindClass ("Hellsmith1HARD");
							break;
						case 12:
							newtypeinfo = PClass::FindClass ("AvatarHARD");
							break;
						case 13:
						case 14:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("BigInfernalSpiderHARD");
									break;
								}else{//ultimate doom,
									//so lets re-seed and grab another custom monster
									int rnd2=0;
									if(!multiplayer&&!sp_random_custom_monsters2)
										rnd2=M_Random2()%18;
									else
										rnd2=pr_gkspawnchance(18);

									switch(rnd2){
										case 0:
										case 1:
											newtypeinfo = PClass::FindClass ("CyberMastermindHARD");
											break;
										case 2:
										case 3:
											newtypeinfo = PClass::FindClass ("DemolisherHARD");
											break;
										//case 6:
										//case 7:
											//newtypeinfo = PClass::FindClass ("Arachnophyte");
										case 4:
											newtypeinfo = PClass::FindClass ("AnnihilatorHARD");
											break;
										case 5:
										case 6:
											newtypeinfo = PClass::FindClass ("ArachnophyteHARD");
											break;
										case 7:
											newtypeinfo = PClass::FindClass ("AzaniginHARD");
											break;
										case 8:
											newtypeinfo = PClass::FindClass ("ThamuzHARD");
											break;
										case 9:
											newtypeinfo = PClass::FindClass ("InfernuxGrandHARD");
											break;
										case 10:
											newtypeinfo = PClass::FindClass ("ApprenticeHARD");
											break;
										case 11:
											newtypeinfo = PClass::FindClass ("Hellsmith1HARD");
											break;
										case 12:
										case 13:
											newtypeinfo = PClass::FindClass ("SupremeFiendHARD");
											break;
										case 14:
											newtypeinfo = PClass::FindClass ("InfernoDemonHARD");
											break;
										case 15:
											newtypeinfo = PClass::FindClass ("AvatarHARD");
											break;
										case 16:
										case 17:
										case 18:
											newtypeinfo = PClass::FindClass ("OverLordHARD");
											break;

									}

								}
							break;

							}

							break;
						case 15:
						case 16:
							newtypeinfo = PClass::FindClass ("SupremeFiendHARD");
							break;
						case 17:
						case 18:
							newtypeinfo = PClass::FindClass ("OverLordHARD");
							break;
						case 19:
							newtypeinfo = PClass::FindClass ("InfernoDemonHARD");
							break;
						case 20:
						case 21:
							newtypeinfo = PClass::FindClass ("SpiderMastermindHARD");
							break; //regular spidermastermind
					}

				}else{
					switch (rnd){

						case 0:
						case 1:
							newtypeinfo = PClass::FindClass ("CyberMastermind");
							break;
						case 2:
						case 3:
							newtypeinfo = PClass::FindClass ("Demolisher");
							break;
						//case 6:
						//case 7:
							//newtypeinfo = PClass::FindClass ("Arachnophyte");
						case 4:
							newtypeinfo = PClass::FindClass ("Annihilator");
							break;
						case 5:
						case 6:
							newtypeinfo = PClass::FindClass ("Arachnophyte");
							break;
						case 7:
							newtypeinfo = PClass::FindClass ("Azanigin");
							break;
						case 8:
							newtypeinfo = PClass::FindClass ("Thamuz");
							break;
						case 9:
							newtypeinfo = PClass::FindClass ("InfernuxGrand");
							break;
						case 10:
							newtypeinfo = PClass::FindClass ("Apprentice");
							break;
						case 11:
							newtypeinfo = PClass::FindClass ("Hellsmith1");
							break;
						case 12:
							newtypeinfo = PClass::FindClass ("Avatar");
							break;
						case 13:
						case 14:
							{
								if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
									newtypeinfo = PClass::FindClass ("BigInfernalSpider");
									break;
								}else{//ultimate doom,
									//so lets re-seed and grab another custom monster
									int rnd2=0;
									if(!multiplayer&&!sp_random_custom_monsters2)
										rnd2=M_Random2()%18;
									else
										rnd2=pr_gkspawnchance(18);

									switch(rnd2){
										case 0:
										case 1:
											newtypeinfo = PClass::FindClass ("CyberMastermind");
											break;
										case 2:
										case 3:
											newtypeinfo = PClass::FindClass ("Demolisher");
											break;
										//case 6:
										//case 7:
											//newtypeinfo = PClass::FindClass ("Arachnophyte");
										case 4:
											newtypeinfo = PClass::FindClass ("Annihilator");
											break;
										case 5:
										case 6:
											newtypeinfo = PClass::FindClass ("Arachnophyte");
											break;
										case 7:
											newtypeinfo = PClass::FindClass ("Azanigin");
											break;
										case 8:
											newtypeinfo = PClass::FindClass ("Thamuz");
											break;
										case 9:
											newtypeinfo = PClass::FindClass ("InfernuxGrand");
											break;
										case 10:
											newtypeinfo = PClass::FindClass ("Apprentice");
											break;
										case 11:
											newtypeinfo = PClass::FindClass ("Hellsmith1");
											break;
										case 12:
										case 13:
											newtypeinfo = PClass::FindClass ("SupremeFiend");
											break;
										case 14:
											newtypeinfo = PClass::FindClass ("InfernoDemon");
											break;
										case 15:
											newtypeinfo = PClass::FindClass ("Avatar");
											break;
										case 16:
										case 17:
										case 18:
											newtypeinfo = PClass::FindClass ("OverLord");
											break;

									}

								}
							break;

							}

							break;
						case 15:
						case 16:
							newtypeinfo = PClass::FindClass ("SupremeFiend");
							break;
						case 17:
						case 18:
							newtypeinfo = PClass::FindClass ("OverLord");
							break;
						case 19:
							newtypeinfo = PClass::FindClass ("InfernoDemon");
							break;
						case 20:
						case 21:
							break; //regular spidermastermind
					}

				}
				break;
			case 8://demon
			case 9://spectre
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%17;
				else
				rnd=pr_gkspawnchance(17);

				switch (rnd){

					case 1:
						newtypeinfo = PClass::FindClass ("HellGuard");
						break;
					case 2:
						newtypeinfo = PClass::FindClass ("HellWarrior");
						break;
					//case 3:
					//case 4:
						//newtypeinfo = PClass::FindClass ("ZombieTank");
						//break;
					case 3:
						newtypeinfo = PClass::FindClass ("BloodDemonClone");
						break;
					case 4:
						newtypeinfo = PClass::FindClass ("Bloodfiend");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("HotDog");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("MaulerDemon");
						break;
					case 7:
						newtypeinfo = PClass::FindClass ("NightmareDemon");
						break;
					case 8:
						{
								int rnd2=0;
								if(!multiplayer&&!sp_random_custom_monsters2)
									rnd2=M_Random2()%4;
								else
									rnd2=pr_gkspawnchance(4);

								switch(rnd2){
									case 0:
									case 1:
									case 2:
										newtypeinfo = PClass::FindClass ("HellRose");
										break;
									case 3:
									case 4:
										newtypeinfo = PClass::FindClass ("HellRoseSpid");
										break;
								}
							}
							break;
					case 9:
						newtypeinfo = PClass::FindClass ("StoneDemon");
						break;
					case 10:
						newtypeinfo = PClass::FindClass ("KDIZDNightmare");
						break;
					case 11:
						newtypeinfo = PClass::FindClass ("PlasmaDemon");
						break;
					case 12:
						newtypeinfo = PClass::FindClass ("SlimeWorm");
						break;
					//case 13:
						//newtypeinfo = PClass::FindClass ("HellRoseSpid");
						//break;
					case 13:
						newtypeinfo = PClass::FindClass ("Satyr");
						break;
					case 14:
						newtypeinfo = PClass::FindClass ("ZombieFlyer");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("Lurker");
						break;
					case 16:
					case 17:
						newtypeinfo = PClass::FindClass ("Watcher");
						break;

				}
				 break;
			/*case 9://spectre
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2(19);
				else
				rnd=pr_gkspawnchance(19);
				switch (rnd){

					//case 1:
					//case 2:
					//case 3:
					//case 4:
						//newtypeinfo = PClass::FindClass ("ZombieTank");
						//break;

					case 1:
					case 2:
						newtypeinfo = PClass::FindClass ("BloodDemonClone");
						break;
					case 3:
					case 4:
						newtypeinfo = PClass::FindClass ("Bloodfiend");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("HotDog");
						break;
					case 6:
					case 7:
						newtypeinfo = PClass::FindClass ("MaulerDemon");
						break;
					case 8:
					case 9:
						newtypeinfo = PClass::FindClass ("NightmareDemon");
						break;
					case 10:
					case 11:
						newtypeinfo = PClass::FindClass ("PlasmaDemon");
						break;
					case 12:
						newtypeinfo = PClass::FindClass ("FIceGuy");
						break;
					case 13:
						newtypeinfo = PClass::FindClass ("FDemon1");
						break;
					case 14:
						newtypeinfo = PClass::FindClass ("FDemon2");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("FPossesedEttin");
						break;
					case 16:
						newtypeinfo = PClass::FindClass ("FMagicCentaur");
						break;
					case 17:
						newtypeinfo = PClass::FindClass ("FSnake");
						break;
					case 18:
					case 19:
						newtypeinfo = PClass::FindClass ("Satyr");
						break;

				}
				 break;
			 */

			//case 10:
				//break;
			case 116://wolfenSS
				break;
			case 20:// Revenant
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%5;
				else
				rnd=pr_gkspawnchance(5);
				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("ZombieTank");
						break;
					case 1:
						newtypeinfo = PClass::FindClass ("Malevonant");
						break;
					case 2:
						newtypeinfo = PClass::FindClass ("DarkClink");
						break;
					case 3:
						newtypeinfo = PClass::FindClass ("NightmareBeast");
						break;
					case 4:
					case 5:
						newtypeinfo = PClass::FindClass ("Incarnate");
						break;
				}
				 break;
			case 115:// Pain Elemental
			case 19: //Cacodemon
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%26;
				else
				rnd=pr_gkspawnchance(26);
				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("PlasmaElemental");
						break;
					case 1:
						newtypeinfo = PClass::FindClass ("TorturedSoul");
						break;
					case 2:
						newtypeinfo = PClass::FindClass ("Inferno");
						break;
					case 3:
						newtypeinfo = PClass::FindClass ("CacolanternClone");
						break;
					case 4:
						newtypeinfo = PClass::FindClass ("CacoLich1");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("EnhancedCacodemon");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("Fallen");
						break;
					case 7:
						newtypeinfo = PClass::FindClass ("Watcher");
						break;
					case 8:
						newtypeinfo = PClass::FindClass ("Wyvern1");
						break;
					case 9:
						newtypeinfo = PClass::FindClass ("Helemental");
						break;
					case 10:
						newtypeinfo = PClass::FindClass ("Agathodemon");
						break;
					case 11:
						newtypeinfo = PClass::FindClass ("NightmareCacodemon");
						break;
					case 12:
						newtypeinfo = PClass::FindClass ("CacoElemental");
						break;
					case 13:
						newtypeinfo = PClass::FindClass ("CrackoDemon");
						break;
					case 14:
						newtypeinfo = PClass::FindClass ("SpeedDemon");
						break;
					case 15:
						newtypeinfo = PClass::FindClass ("SurrealDemon");
						break;
					case 16:
						newtypeinfo = PClass::FindClass ("ZombieFlyer");
						break;
					case 17:
						newtypeinfo = PClass::FindClass ("Wicked");
						break;
					case 18:
						newtypeinfo = PClass::FindClass ("Quasit");
						break;
					case 19:
						newtypeinfo = PClass::FindClass ("Defiler");
						break;
					case 20:
						newtypeinfo = PClass::FindClass ("Poe");
						break;
					case 21:
						newtypeinfo = PClass::FindClass ("FlyingImp");
						break;
					case 22:
						newtypeinfo = PClass::FindClass ("Wicked");
						break;
					case 23:
						newtypeinfo = PClass::FindClass ("Aracnorb");
						break;
					case 24:
						newtypeinfo = PClass::FindClass ("D3Cacodemon");
						break;
					case 25:
					case 26:
						newtypeinfo = PClass::FindClass ("SuperFlyingImp");
						break;

				}
				break;
			case 110:// Lost Soul
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%12;
				else
				rnd=pr_gkspawnchance(12);
				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("ESoul");
						break;
					case 1:
						newtypeinfo = PClass::FindClass ("PoisonSoul");
						break;
					case 2:
						newtypeinfo = PClass::FindClass ("HS");
						break;
					case 3:
						newtypeinfo = PClass::FindClass ("PsychicSoul");
						break;
					case 4:
						newtypeinfo = PClass::FindClass ("Terror");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("HellFireSoul");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("EyeEx");
						break;
					case 7:
						newtypeinfo = PClass::FindClass ("EyePoison");
						break;
					case 8:
						newtypeinfo = PClass::FindClass ("EyeSpider");
						break;
					case 9:
						newtypeinfo = PClass::FindClass ("DreamCreeper");
						break;
					case 10:
						newtypeinfo = PClass::FindClass ("D3ForgottenOne");
						break;
					case 11:
					case 12:
						newtypeinfo = PClass::FindClass ("Rictus");
						break;
				}
				break;
			case 112:// Mancubus
				if(rand<126)
					break;
				//Lets not replace on map07 special
				//if(!(level.flags & LEVEL_MAP07SPECIAL)){
					if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%7;
				else
					rnd=pr_gkspawnchance(7);
					switch (rnd){

						case 0:
							newtypeinfo = PClass::FindClass ("Queen");
							break;
						case 1:
							newtypeinfo = PClass::FindClass ("DESentinel");
							break;
						case 2:
							newtypeinfo = PClass::FindClass ("reaper");
							break;
						case 3:
							newtypeinfo = PClass::FindClass ("inqbot");
							break;
						case 4:
						//case 4:
							newtypeinfo = PClass::FindClass ("Maxibus");
							break;
						//case 5:
						//case 5:
							//newtypeinfo = PClass::FindClass ("HellRoseSpid");
							//break;
						case 5:
							newtypeinfo = PClass::FindClass ("Daedabus");
							break;
						case 6:
						case 7:
							newtypeinfo = PClass::FindClass ("Hectebus");
							break;
					}
				//}
				break;
			case 114: //cyberdemon
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%9;
				else
				rnd=pr_gkspawnchance(9);
				if(PClass::FindClass ("CyberDemonHARD")){ //look for sdmonstershardboss wad
						switch (rnd){

							case 0:
								newtypeinfo = PClass::FindClass ("ApprenticeHARD");
								break;
							case 1:
								newtypeinfo = PClass::FindClass ("AvatarHARD");
								break;
							case 2:
								newtypeinfo = PClass::FindClass ("HellSmith1HARD");
								break;
							case 3:
								newtypeinfo = PClass::FindClass ("ThamuzHARD");
								break;
							case 4:
								newtypeinfo = PClass::FindClass ("InfernuxGrandHARD");
								break;
							case 5:
								newtypeinfo = PClass::FindClass ("AnnihilatorHARD");
								break;
							case 6:
								newtypeinfo = PClass::FindClass ("AzaniginHARD");
								break;
							case 7:
								newtypeinfo = PClass::FindClass ("InfernoDemonHARD");
								break;
						case 8:
						case 9:
							newtypeinfo = PClass::FindClass ("CyberDemonHARD");
							break; //regular cyberdemon
					}
				}else{
						switch (rnd){

							case 0:
								newtypeinfo = PClass::FindClass ("Apprentice");
								break;
							case 1:
								newtypeinfo = PClass::FindClass ("Avatar");
								break;
							case 2:
								newtypeinfo = PClass::FindClass ("HellSmith1");
								break;
							case 3:
								newtypeinfo = PClass::FindClass ("Thamuz");
								break;
							case 4:
								newtypeinfo = PClass::FindClass ("InfernuxGrand");
								break;
							case 5:
								newtypeinfo = PClass::FindClass ("Annihilator");
								break;
							case 6:
								newtypeinfo = PClass::FindClass ("Azanigin");
								break;
							case 7:
								newtypeinfo = PClass::FindClass ("InfernoDemon");
								break;
						case 8:
						case 9:
							break; //regular cyberdemon
					}

				}

				 break;

			/*case 19:// Cacodemon
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2(18);
				else
				rnd=pr_gkspawnchance(18);

				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("CacolanternClone");
						break;
					case 1:
					case 2:
						newtypeinfo = PClass::FindClass ("CacoLich1");
						break;
					case 3:
					case 4:
						newtypeinfo = PClass::FindClass ("EnhancedCacodemon");
						break;
					case 5:
					case 6:
						newtypeinfo = PClass::FindClass ("PlasmaElemental");
						break;
					case 7:
					case 8:
						newtypeinfo = PClass::FindClass ("TorturedSoul");
						break;
					case 9:
					case 10:
						newtypeinfo = PClass::FindClass ("Inferno");
						break;
					case 11:
						newtypeinfo = PClass::FindClass ("Fallen");
						break;
					case 12:
					case 13:
						newtypeinfo = PClass::FindClass ("KDiZDNightmare");
						break;
					case 14:
					case 15:
						newtypeinfo = PClass::FindClass ("Watcher");
						break;
					case 16:
						newtypeinfo = PClass::FindClass ("FPreist4");
						break;
					case 17:
					case 18:
						newtypeinfo = PClass::FindClass ("CrackoDemon");
						break;


					//case 3:
						//newtypeinfo = PClass::FindClass ("Fallen");
						//break;
					//case 4:
						//newtypeinfo = PClass::FindClass ("PlasmaElemental");
						//break;
					//case 5:
						//newtypeinfo = PClass::FindClass ("TorturedSoul");
						//break;
					//case 6:
						//newtypeinfo = PClass::FindClass ("Arachnophyte");
						//break;

				}
				//newtypeinfo = PClass::FindClass ("DESentinel");
				 break;
				 */
			case 113://hell knight
				if(rand<126)
					break;

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%10;
				else
				rnd=pr_gkspawnchance(10);
				switch (rnd){

					//case 0:
						//newtypeinfo = PClass::FindClass ("HellGuard");
						//break;
					//case 1:
						//newtypeinfo = PClass::FindClass ("HellWarrior");
						//break;
					case 1:
						newtypeinfo = PClass::FindClass ("TornadoDemon");
						break;
					//case 2:
						//newtypeinfo = PClass::FindClass ("Thor");
						//break;
					case 2:
						newtypeinfo = PClass::FindClass ("HornBeast"); //PClass::FindClass ("ZombieTank");
						break;
					case 3:
						newtypeinfo = PClass::FindClass ("ObsidianStatueNonDormant");
						break;
					case 4:
						newtypeinfo = PClass::FindClass ("Bormereth");
						break;
					case 5:
						newtypeinfo = PClass::FindClass ("Phantom");
						break;
					case 6:
						newtypeinfo = PClass::FindClass ("Terminator");
						break;
					case 7:
						newtypeinfo = PClass::FindClass ("ShadowBeast");
						break;
					case 8:
						newtypeinfo = PClass::FindClass ("Golem");
						break;
					case 9:
					case 10:
						newtypeinfo = PClass::FindClass ("Desolator");
						break;


				}
				 break;
			case 111:// Archvile
				if(rand<126)
					break;
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2()%2;
				else
				rnd=pr_gkspawnchance(2);
				switch (rnd){

					case 0:
						newtypeinfo = PClass::FindClass ("Deathknight");
						break;
					//case 1:
						//newtypeinfo = PClass::FindClass ("TornadoDemon");
						//break;
					//case 2:
						//newtypeinfo = PClass::FindClass ("Thor");
						//break;
					case 1:
					case 2:
						newtypeinfo = PClass::FindClass ("Diabloist");
						break;
					//case 3:
					//case 4:
						//newtypeinfo = PClass::FindClass ("Thor");
						//break;
				}
				break;


			//default:
			 // These statements executed if none of the others are
		 }
	}
	 //ghk PoinstBunnySpawner

	/*
	Byte SPWNID = type->ActorInfo->SpawnID;
	 if(rand<3&&(SPWNID==1||SPWNID==2||SPWNID==4||SPWNID==5||SPWNID==8||SPWNID==9)){
		 newtypeinfo = PClass::FindClass ("PointsBunny");
		return newtypeinfo;
	 }else{
		return newtypeinfo;
	 }
	*/


	//if(rnd>127&&spawnid==5){
		//newtypeinfo = PClass::FindClass ("Afrit");
		//if (newtypeinfo != NULL && newtypeinfo->ActorInfo != NULL)

				//type=newtypeinfo;
		//}
	//}

		DWORD ghkflags = ((AActor*)(newtypeinfo->Defaults))->flags;
		int ghkhealth =((AActor*)(newtypeinfo->Defaults))->health;

	 	if(sd_artifacts&&((ghkflags & MF_COUNTKILL) && !(ghkflags & MF_FRIENDLY))){ //ghk basically Countsaskill()
			//Printf (PRINT_MEDIUM, "%s%d\n","rndindex:",rndindexA);

			//bit of a hack, but for online hi scoring
			//do a check to for sd-artifacts and if not found and sd_global_scoing is on
			//then return, since with it being on, some extra regular powerups
			//will spawn
			//if(!PClass::FindClass ("SDSmartBomb")&&sd_global_hiscores)
			//It should always return, even for non online scoring games
			//like offline and MP! sd_artifacts flag should be depricated
			//if(!PClass::FindClass ("SDSmartBomb")) (check added in calling function)
				//return newtypeinfo;

			if(ghkhealth<20) //dont do anything for monsters with less than 20hp
				return newtypeinfo;

			if(sd_custom_replacements){
				const PClass *newtypeinfoA; // = PClass::FindClass("SDArtiSpawner");//GHK this
				int rnd = 0;
				int rndH = 0;
				bool blGetHealth = false;

				//Printf (PRINT_MEDIUM, "%d\n", M_Random3());
				//if(M_Random3()<10){

					//P_DropItem (actor, newtypeinfo,1, 256); //255
				//}

				//Lets drop health now id sd_artifacts is enabled
				//better for custom monsters

				if(!multiplayer&&!sp_random_custom_monsters2){
					rndH =M_Random3()%100 + 1;

				}else{
					rndH=pr_gkspawnchance2(100) + 1;


				}
				if(sd_extrahealth_chance2>0&&sdExtraHealthRepCount>0){

					if(sd_extrahealth_chance2>=rndH){ //default 35
							blGetHealth=true;
						}




					if(blGetHealth){
						//if (debugfile) fprintf (debugfile, "healthNumber%d",rnd);
						if(!multiplayer&&!sp_random_custom_monsters2){
							if(sdExtraHealthRange>=255){
								rnd=int(((float(M_Random3()) + 1.0)/256.0)*float(sdExtraHealthRange));

							}else{
								rnd=M_Random3()%sdExtraHealthRange + 1;
							}
						}else{
							rnd=pr_gkspawnchance(sdExtraHealthRange) + 1;
						}


									//now loop through range array to get corresponding index
									//of creature array
						for(int i=0;i<sdExtraHealthRepCount;i++){

							if(rnd<=sdExtraHealthRepChances[i]){
								newtypeinfoA=PClass::FindClass(sdExtraHealthReps[i]);
								break;
							}


						}


						//if (debugfile) fprintf (debugfile, "type1: %s",newtypeinfoA->TypeName.GetChars());

						AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);



						//if (newtypeinfoA != NULL && newtypeinfo->ActorInfo != NULL){

								//if (debugfile) fprintf (debugfile, "CLASSH: %s\n",newtypeinfoA->ActorInfo->Class->TypeName.GetChars());

						//}


						//P_DropItem (actor, newtypeinfoA,-1, 255);
						//AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);

					}else{
						//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random3();
					}
				}else{
					//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random3();
				}


				//default sd_artifact_chance = 10
				if(!multiplayer&&!sp_random_custom_monsters2){
					rnd =M_Random3()%100 + 1;

				}else{
					rnd=pr_gkspawnchance2(100) + 1;


				}

				if(sd_artifact_chance2>0&&sdArtiRepCount>0){

					if(sd_artifact_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdArtiRange>=255){
										rnd=int(((float(M_Random3()) + 1.0)/256.0)*float(sdArtiRange));

									}else{
										rnd=M_Random3()%sdArtiRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance2(sdArtiRange) + 1;
								}

								//ghk check if an artifact has already been spawned
								//if not, then look for the next non-spawned artifiact to spawn
								if(arrArtifacts[rnd]>0){
									int sdArtiRepCountMid = ceil(float(sdArtiRepCount)/2.0);
									if(rnd>sdArtiRepCountMid){
										for(int j=0;j<sdArtiRepCount;j++)
										{	//if everything has spawned at least once, then spawn multiples.
											if(arrArtifacts[j]==0){
												rnd=j;
												break;
											}
										}
									}else{

										int sdArtiRepCount2 = sdArtiRepCount-1;
										for(int j=sdArtiRepCount2;j>-1;j--)
										{	//if everything has spawned at least once, then spawn multiples.
											if(arrArtifacts[j]==0){
												rnd=j;
												break;
											}
										}

									}


								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdArtiRepCount;i++){

									if(rnd<=sdArtiRepChances[i]){
										arrArtifacts[i]++;
										newtypeinfoA=PClass::FindClass(sdArtiReps[i]);
										break;
									}

								}

								//if (debugfile) fprintf (debugfile, "type1: %s",newtypeinfoA->TypeName.GetChars());

								AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);


							}else{
							//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random3();
					}

				}else{
							//progress the rndtable regardless for consistency
						if(!multiplayer&&!sp_random_custom_monsters2)
							M_Random3();
				}
				//ghk check if an artifact has already been spawned
				//if not, then look for the next non-spawned artifiact to spawn
				//Printf (PRINT_MEDIUM, "%s%d\n","HEY2:",rnd);


							//if (newtypeinfoA != NULL && newtypeinfo->ActorInfo != NULL){

							//if (debugfile) fprintf (debugfile, "CLASSA: %s\n",newtypeinfoA->ActorInfo->Class->TypeName.GetChars());

							//}
							//if(M_Random3()%4>2){

								//Printf (PRINT_MEDIUM, "%s%d\n","HEY:",rnd);
								//P_DropItem (actor, newtypeinfoA,1, 255);


				//if (debugfile) fprintf (debugfile, "type1: %s",newtypeinfoA->TypeName.GetChars());

						//AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);
							//}
			//}


			}else{
			//if ((level.flags & (LEVEL_CYBORGSPECIAL|
				//LEVEL_SPIDERSPECIAL|LEVEL_BRUISERSPECIAL)) == 0){//ghk dont spawn on 'boss' levels
				const PClass *newtypeinfoA; // = PClass::FindClass("SDArtiSpawner");//GHK this
				int rnd = 0;
				int rndH = 0;
				bool blGetHealth = false;

				//Printf (PRINT_MEDIUM, "%d\n", M_Random3());
				//if(M_Random3()<10){

					//P_DropItem (actor, newtypeinfo,1, 256); //255
				//}

				//Lets drop health now id sd_artifacts is enabled
				//better for custom monsters

				if(!multiplayer&&!sp_random_custom_monsters2){
					int rnd2 =M_Random3();

					if(M_Random3()<=sd_extrahealth_chance2){ //default 35
						rndH=rnd2%6;
						blGetHealth=true;
					}


				}else{

					if(pr_gkspawnchance2(256)<=sd_extrahealth_chance2){ //default 35

						rndH=pr_gkspawnchance2(6);
						blGetHealth=true;

					}

				}

				if(blGetHealth){
					//if (debugfile) fprintf (debugfile, "healthNumber%d",rnd);
					switch (rndH){

								case 0:
								case 1:
								case 2:
									newtypeinfoA = PClass::FindClass ("StimPack");
									break;
								case 3:
								case 4:
									newtypeinfoA = PClass::FindClass ("Medikit");
									break;
								case 5:
								case 6:
									newtypeinfoA = PClass::FindClass ("GreenArmor");
									break;



					}
					//if (newtypeinfoA != NULL && newtypeinfo->ActorInfo != NULL){

							//if (debugfile) fprintf (debugfile, "CLASSH: %s\n",newtypeinfoA->ActorInfo->Class->TypeName.GetChars());

					//}


					//P_DropItem (actor, newtypeinfoA,-1, 255);
					AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);

				}



				//default sd_artifact_chance = 10
				if(!multiplayer&&!sp_random_custom_monsters2){
					int rnd2 =M_Random3();

						if(M_Random3()>sd_artifact_chance2) return newtypeinfo; //cvar sd_artifact_chance default is 50 (out of 255)
						rnd=rnd2%16;


				}else{

					if(pr_gkspawnchance2(256)>sd_artifact_chance2) return newtypeinfo;

						rnd=pr_gkspawnchance2(16);

				}



				//ghk check if an artifact has already been spawned
				//if not, then look for the next non-spawned artifiact to spawn
				//Printf (PRINT_MEDIUM, "%s%d\n","HEY2:",rnd);

				if(arrArtifacts[rnd]>0){
					if(rnd>7){
						for(int j=0;j<16;j++)
						{	//if everything has spawned at least once, then spawn multiples.
							if(arrArtifacts[j]==0){
								rnd=j;
								break;
							}
						}
					}else{
						for(int j=15;j>-1;j--)
						{	//if everything has spawned at least once, then spawn multiples.
							if(arrArtifacts[j]==0){
								rnd=j;
								break;
							}
						}

					}
				}
				//if (debugfile) fprintf (debugfile, "artiNumber:%d",rnd);
							switch (rnd){

								case 0:
									arrArtifacts[0]++;
									newtypeinfoA = PClass::FindClass ("TerrorSphere");
									break;
								case 1:
									arrArtifacts[1]++;
									newtypeinfoA = PClass::FindClass ("ArtiSpeedBoots2");
									break;
								case 2:
									arrArtifacts[2]++;
									newtypeinfoA = PClass::FindClass ("ArtiDarkServant2");
									break;
								case 3:
									arrArtifacts[3]++;
									//newtypeinfoA = PClass::FindClass ("BruiserDemon");
									newtypeinfoA = PClass::FindClass ("QuarterDamage");
									break;
								//case 4:
									//newtypeinfoA = PClass::FindClass ("Deathknight");
									//break;
								case 4:
									arrArtifacts[4]++;
									newtypeinfoA = PClass::FindClass ("QuadDamage");
									break;
								//case 5:
									//arrArtifacts[5]++;
									//newtypeinfoA = PClass::FindClass ("PointsBunnySpawner");
									//break;
								case 5:
									arrArtifacts[5]++;
									//newtypeinfoA = PClass::FindClass ("GodAvatar");
									newtypeinfoA = PClass::FindClass ("DoubleDamage");
									break;
								case 6://pk3
									arrArtifacts[6]++;
									newtypeinfoA = PClass::FindClass ("Regen");
									break;
								case 7:
									arrArtifacts[7]++;
									newtypeinfoA = PClass::FindClass ("Drain");
									break;
								case 8:
									arrArtifacts[8]++;
									newtypeinfoA = PClass::FindClass ("HalfDamage");
									break;
								case 9:
									arrArtifacts[9]++;
									newtypeinfoA = PClass::FindClass ("InvulnerabilitySphere");
									break;

								case 10:
									{
										int rnd3=0;
										int rnd4 =M_Random3();
										arrArtifacts[10]++;
										//arrArtifacts[11]++;
										//newtypeinfoA = PClass::FindClass ("ArtiPredator");
										if(!multiplayer&&!sp_random_custom_monsters2){

											rnd3=rnd4%2;
										}else{

											rnd3=pr_gkspawnchance2(2);
										}

										switch (rnd3){
											case 0:
												newtypeinfoA = PClass::FindClass ("BigBackPack2");
												break;
											case 1:
											case 2:
												newtypeinfoA = PClass::FindClass ("BigBackPack");
												break;

										}
									}
									//arrArtifacts[11]++;
									//newtypeinfoA = PClass::FindClass ("BigBackPack");
									break;
								case 11:
									//arrArtifacts[11]++;
									//arrArtifacts[11]++;
									//newtypeinfoA = PClass::FindClass ("ArtiPorkSD");
									{
										int rnd3=0;
										int rnd4 =M_Random3();
										arrArtifacts[11]++;
										//arrArtifacts[11]++;
										//newtypeinfoA = PClass::FindClass ("ArtiPredator");
										if(!multiplayer&&!sp_random_custom_monsters2){

											rnd3=rnd4%6;
										}else{

											rnd3=pr_gkspawnchance2(6);
										}
										//if (debugfile) fprintf (debugfile, "secondartiNumber%d",rnd3);
										switch (rnd3){

											case 0:
												newtypeinfoA = PClass::FindClass ("Berserk");
												break;
											case 1:
												newtypeinfoA = PClass::FindClass ("BlurSphere");
												break;
											case 2:
												newtypeinfoA = PClass::FindClass ("BlueArmor");
												break;
											case 3:
												newtypeinfoA = PClass::FindClass ("SoulSphereSD");
												break;
											case 4:
												{
													if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
														newtypeinfoA = PClass::FindClass ("Megasphere");
														break;
													}else{//ultimate doom wads, ondeath spawns shotgunguy instead
														newtypeinfoA = PClass::FindClass ("SoulSphereSD");
														break;
													}
												}
											case 5:
											case 6:
												newtypeinfoA = PClass::FindClass ("Backpack");
												break;

											//case 7:
												//newtypeinfoA = PClass::FindClass ("SpherePrecog");
												//break;

											//case 8:
												//newtypeinfoA = PClass::FindClass ("InvulnerabilitySphere");
												//break;

										}
									}
									break;
								case 12:
									{
										int rnd3=0;
										int rnd4 =M_Random3();
										arrArtifacts[12]++;
										//arrArtifacts[11]++;
										//newtypeinfoA = PClass::FindClass ("ArtiPredator");
										if(!multiplayer&&!sp_random_custom_monsters2){

											rnd3=rnd4%6;
										}else{

											rnd3=pr_gkspawnchance2(6);
										}
										//if (debugfile) fprintf (debugfile, "thirdartiNumber%d",rnd3);
										switch (rnd3){

											case 0:
												newtypeinfoA = PClass::FindClass ("Berserk");
												break;
											case 1:
												newtypeinfoA = PClass::FindClass ("BlurSphere");
												break;
											case 2:
												newtypeinfoA = PClass::FindClass ("BlueArmor");
												break;
											case 3:
												newtypeinfoA = PClass::FindClass ("SoulSphereSD");
												break;
											case 4:
												{
													if(gameinfo.flags & GI_MAPxx){  //only for Doom2+
														newtypeinfoA = PClass::FindClass ("Megasphere");
														break;
													}else{//ultimate doom wads, ondeath spawns shotgunguy instead
														newtypeinfoA = PClass::FindClass ("SoulSphereSD");
														break;
													}
												}
											case 5:
											case 6:
												newtypeinfoA = PClass::FindClass ("Backpack");
												break;

											//case 7:
												//newtypeinfoA = PClass::FindClass ("SpherePrecog");
												//break;

											//case 8:
												//newtypeinfoA = PClass::FindClass ("InvulnerabilitySphere");
												//break;

										}
									}
									break;
								case 13:
									arrArtifacts[13]++;
									newtypeinfoA = PClass::FindClass ("TimeFreezer");
									break;
								case 14:
									arrArtifacts[14]++;
									newtypeinfoA = PClass::FindClass ("SDSmartBomb");
									break;
								case 15:
								case 16:
									arrArtifacts[15]++;
									//arrArtifacts[11]++;
									newtypeinfoA = PClass::FindClass ("ArtiSentryServant");
									break;

							}

							//if (newtypeinfoA != NULL && newtypeinfo->ActorInfo != NULL){

							//if (debugfile) fprintf (debugfile, "CLASSA: %s\n",newtypeinfoA->ActorInfo->Class->TypeName.GetChars());

							//}
							//if(M_Random3()%4>2){

								//Printf (PRINT_MEDIUM, "%s%d\n","HEY:",rnd);
								//P_DropItem (actor, newtypeinfoA,1, 255);
							AActor::StaticSpawn (newtypeinfoA, ix, iy, iz+ 8 * FRACUNIT, ALLOW_REPLACE, false);
							//}
			//}

		}
	}

	return newtypeinfo;
}

//==========================================================================
//
// P_SpawnMobj
//
//==========================================================================

AActor *AActor::StaticSpawn (const PClass *type, fixed_t ix, fixed_t iy, fixed_t iz, replace_t allowreplacement, bool nsFlag)
{
	const PClass *newtypeinfo=NULL; //GHK experimental code
	bool setBoss = false; //GHK
	FName typeName=NULL; //GHK
	int spwnid=0;
	int rnd=0;

	if (type == NULL)
	{
		I_Error ("Tried to spawn a class-less actor\n");
	}

	if (type->ActorInfo == NULL)
	{
		I_Error ("%s is not an actor\n", type->TypeName.GetChars());
	}

	//if (debugfile) fprintf (debugfile, "ghk1c?%d",FBehavior::StaticModules.Size());
	//GHK: only for DOOM series
	//Add checks for addonpack here, to support new artifact code.
	if (gameinfo.gametype == GAME_Doom){
		//GHK Experimental custom decorate monster replacement code
		//int rnd = M_Random ();

		spwnid=type->ActorInfo->SpawnID;

		//type->TypeName.GetChars();
		//do a lower rnd for major bosses or none at all?
		/*if(rnd>190&&((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116))){
			//newtypeinfo = PClass::FindClass ("DoomImp");
			newtypeinfo = PClass::GetRandomMonster (type);
			if (newtypeinfo != NULL && newtypeinfo->ActorInfo != NULL)
				{
					type=newtypeinfo;
			}

		}*/
		if(spwnid==125)
			level.total_barrels++;

		//GHK, Need to consider if we want to spawn SD replacement monsters
		//for levels utilizing ACS. The sdmonsters DECORATE needs Thing IDs added for every monster
		//Additionally ThingCount and ThingCountName and other ACS functions which call actionspecials
		//from ACS script will sometimes add a TID, which simply is not supported by SD monsters
		//SO... either let players use sd monsters at their own risk with ACS wads, or
		//just disable by default.

		if(sd_custom_replacements){ //ghk

			//get if we should replace archiviles, cyberdemons & mastrminds if !sd_do_default_monsters


			int sd_do_defaultmonsters_replaceall = sd_do_default_monsters&&sd_defaultmonstermaps_replace_all2;

			if((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116)||(spwnid==125)||(spwnid==149)){

				M_Random2(); //GHK: needs to be here to make sure warping randomization and
							 //regular progression randomization are equivalent. Not 100% sure why.

				int rnd=0;

				switch(spwnid){

					case 125: //exp barrel
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_explosivebarrel_chance2>0&&sdExplosiveBarrelRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_explosivebarrel_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdExplosiveBarrelRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdExplosiveBarrelRange));

									}else{
										rnd=M_Random2()%sdExplosiveBarrelRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdExplosiveBarrelRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdExplosiveBarrelRepCount;i++){

									if(rnd<=sdExplosiveBarrelRepChances[i]){
										newtypeinfo=PClass::FindClass(sdExplosiveBarrelReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
							//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
						}
						break;
					case 149: //burning barrel
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_burningbarrel_chance2>0&&sdBurningBarrelRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_burningbarrel_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdBurningBarrelRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdBurningBarrelRange));

									}else{
										rnd=M_Random2()%sdBurningBarrelRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdBurningBarrelRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdBurningBarrelRepCount;i++){

									if(rnd<=sdBurningBarrelRepChances[i]){
										newtypeinfo=PClass::FindClass(sdBurningBarrelReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}
						break;

					case 111: //archvile
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_archvile_chance2>0&&sdArchvileRepCount>0&&!sd_do_defaultmonsters_replaceall){ //&&!sd_do_default_monsters

							if(sd_rep_archvile_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdArchvileRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdArchvileRange));

									}else{
										rnd=M_Random2()%sdArchvileRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdArchvileRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdArchvileRepCount;i++){

									if(rnd<=sdArchvileRepChances[i]){
										newtypeinfo=PClass::FindClass(sdArchvileReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 6: //arachnotron
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_arachnotron_chance2>0&&sdArachnotronRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_arachnotron_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdArachnotronRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdArachnotronRange));

									}else{
										rnd=M_Random2()%sdArachnotronRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdArachnotronRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdArachnotronRepCount;i++){

									if(rnd<=sdArachnotronRepChances[i]){
										newtypeinfo=PClass::FindClass(sdArachnotronReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 3: //BARONOFHELL
						//Lets See if we are Boss-Rushing?...requires addonpack //&&!sd_do_default_monsters
						if((level.flags & LEVEL_BRUISERSPECIAL)&&sd_bossrush2&&PClass::FindClass("SDBossChainEnder")&&!sd_do_default_monsters){
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd=M_Random2()%100 + 1;
							else
								rnd=pr_gkspawnchance(100) + 1;


									//ok, now find which creature gets picked.
									//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
										if(sdBaronChainRange>=255){
											rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdBaronChainRange));

										}else{
											rnd=M_Random2()%sdBaronChainRange + 1;
										}
									}else{
										rnd=pr_gkspawnchance(sdBaronChainRange) + 1;
									}


									//now loop through range array to get corresponding index
									//of creature array
									for(int i=0;i<sdBaronChainRepCount;i++){

										if(rnd<=sdBaronChainChances[i]){
											newtypeinfo=PClass::FindClass(sdBaronChainReps[i]);
											break;
										}

									}


						}else{
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd=M_Random2()%100 + 1;
							else
								rnd=pr_gkspawnchance(100) + 1;


							if(sd_rep_baronofhell_chance2>0&&sdBaronOfHellRepCount>0&&!sd_do_default_monsters){ //&&!sd_do_default_monsters

								if(sd_rep_baronofhell_chance2>=rnd){
									//ok, now find which creature gets picked.
									//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
										if(sdBaronOfHellRange>=255){
											rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdBaronOfHellRange));

										}else{
											rnd=M_Random2()%sdBaronOfHellRange + 1;
										}
									}else{
										rnd=pr_gkspawnchance(sdBaronOfHellRange) + 1;
									}


									//now loop through range array to get corresponding index
									//of creature array
									for(int i=0;i<sdBaronOfHellRepCount;i++){

										if(rnd<=sdBaronOfHellRepChances[i]){
											newtypeinfo=PClass::FindClass(sdBaronOfHellReps[i]);
											break;
										}

									}

								}else{
									//progress the rndtable regardless for consistency
									if(!multiplayer&&!sp_random_custom_monsters2)
										M_Random2();
								}

							}else{
									//progress the rndtable regardless for consistency
									if(!multiplayer&&!sp_random_custom_monsters2)
										M_Random2();
							}
						}
						break;

					case 113: //HellKnight
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_hellknight_chance2>0&&sdHellKnightRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_hellknight_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdHellKnightRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdHellKnightRange));

									}else{
										rnd=M_Random2()%sdHellKnightRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdHellKnightRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdHellKnightRepCount;i++){

									if(rnd<=sdHellKnightRepChances[i]){
										newtypeinfo=PClass::FindClass(sdHellKnightReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 19: //Cacodemon
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_cacodemon_chance2>0&&sdCacodemonRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_cacodemon_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdCacodemonRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdCacodemonRange));

									}else{
										rnd=M_Random2()%sdCacodemonRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdCacodemonRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdCacodemonRepCount;i++){

									if(rnd<=sdCacodemonRepChances[i]){
										newtypeinfo=PClass::FindClass(sdCacodemonReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 114: //Cyberdemon		//&&!sd_do_default_monsters
						if((level.flags & LEVEL_CYBORGSPECIAL)&&sd_bossrush2&&PClass::FindClass("SDBossChainEnder")&&!sd_do_defaultmonsters_replaceall){
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd=M_Random2()%100 + 1;
							else
								rnd=pr_gkspawnchance(100) + 1;


									//ok, now find which creature gets picked.
									//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
										if(sdCyberChainRange>=255){
											rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdCyberChainRange));

										}else{
											rnd=M_Random2()%sdCyberChainRange + 1;
										}
									}else{
										rnd=pr_gkspawnchance(sdCyberChainRange) + 1;
									}


									//now loop through range array to get corresponding index
									//of creature array
									for(int i=0;i<sdCyberChainRepCount;i++){

										if(rnd<=sdCyberChainChances[i]){
											newtypeinfo=PClass::FindClass(sdCyberChainReps[i]);
											break;
										}

									}


						}else{


							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd=M_Random2()%100 + 1;
							else
								rnd=pr_gkspawnchance(100) + 1;


							if(sd_rep_cyberdemon_chance2>0&&sdCyberdemonRepCount>0&&!sd_do_defaultmonsters_replaceall){ //&&!sd_do_default_monsters

								if(sd_rep_cyberdemon_chance2>=rnd){
									//ok, now find which creature gets picked.
									if(!multiplayer&&!sp_random_custom_monsters2){
										if(sdCyberdemonRange>=255){
											rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdCyberdemonRange));

										}else{
											rnd=M_Random2()%sdCyberdemonRange + 1;
										}
									}else{
										rnd=pr_gkspawnchance(sdCyberdemonRange) + 1;
									}


									//now loop through range array to get corresponding index
									//of creature array
									for(int i=0;i<sdCyberdemonRepCount;i++){

										if(rnd<=sdCyberdemonRepChances[i]){
											newtypeinfo=PClass::FindClass(sdCyberdemonReps[i]);
											break;
										}

									}

								}else{
									//progress the rndtable regardless for consistency
									if(!multiplayer&&!sp_random_custom_monsters2)
										M_Random2();
								}

							}else{
									//progress the rndtable regardless for consistency
									if(!multiplayer&&!sp_random_custom_monsters2)
										M_Random2();
							}
						}
						break;
					case 8: //Demon
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_demon_chance2>0&&sdDemonRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_demon_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdDemonRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdDemonRange));

									}else{
										rnd=M_Random2()%sdDemonRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdDemonRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdDemonRepCount;i++){

									if(rnd<=sdDemonRepChances[i]){
										newtypeinfo=PClass::FindClass(sdDemonReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}
						break;
					case 9: //Spectre
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_spectre_chance2>0&&sdSpectreRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_spectre_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdSpectreRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdSpectreRange));

									}else{
										rnd=M_Random2()%sdSpectreRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdSpectreRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdSpectreRepCount;i++){

									if(rnd<=sdSpectreRepChances[i]){
										newtypeinfo=PClass::FindClass(sdSpectreReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
				case 2: //ChaingunGuy
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_chaingunguy_chance2>0&&sdChaingunGuyRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_chaingunguy_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdChaingunGuyRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdChaingunGuyRange));

									}else{
										rnd=M_Random2()%sdChaingunGuyRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdChaingunGuyRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdChaingunGuyRepCount;i++){

									if(rnd<=sdChaingunGuyRepChances[i]){
										newtypeinfo=PClass::FindClass(sdChaingunGuyReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 5: //DoomImp
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_doomimp_chance2>0&&sdDoomImpRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_doomimp_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdDoomImpRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdDoomImpRange));

									}else{
										rnd=M_Random2()%sdDoomImpRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdDoomImpRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdDoomImpRepCount;i++){

									if(rnd<=sdDoomImpRepChances[i]){
										newtypeinfo=PClass::FindClass(sdDoomImpReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 112: //Fatso
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_fatso_chance2>0&&sdFatsoRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_fatso_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range

								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdFatsoRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdFatsoRange));

									}else{
										rnd=M_Random2()%sdFatsoRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdFatsoRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdFatsoRepCount;i++){

									if(rnd<=sdFatsoRepChances[i]){
										newtypeinfo=PClass::FindClass(sdFatsoReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 110: //LostSoul
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_lostsoul_chance2>0&&sdLostSoulRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_lostsoul_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdLostSoulRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdLostSoulRange));

									}else{
										rnd=M_Random2()%sdLostSoulRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdLostSoulRange) + 1;
								}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdLostSoulRepCount;i++){

									if(rnd<=sdLostSoulRepChances[i]){
										newtypeinfo=PClass::FindClass(sdLostSoulReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 115: //PainElemental
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_painelemental_chance2>0&&sdPainElementalRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_painelemental_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdPainElementalRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdPainElementalRange));

									}else{
										rnd=M_Random2()%sdPainElementalRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdPainElementalRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdPainElementalRepCount;i++){

									if(rnd<=sdPainElementalRepChances[i]){
										newtypeinfo=PClass::FindClass(sdPainElementalReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
					case 20: //Revenant
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_revenant_chance2>0&&sdRevenantRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_revenant_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdRevenantRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdRevenantRange));

									}else{
										rnd=M_Random2()%sdRevenantRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdRevenantRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdRevenantRepCount;i++){

									if(rnd<=sdRevenantRepChances[i]){
										newtypeinfo=PClass::FindClass(sdRevenantReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
						}
						break;
				case 1: //ShotgunGuy
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_shotgunguy_chance2>0&&sdShotgunGuyRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_shotgunguy_chance2>=rnd){
								//ok, now find which creature gets picked.
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdShotgunGuyRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdShotgunGuyRange));

									}else{
										rnd=M_Random2()%sdShotgunGuyRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdShotgunGuyRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdShotgunGuyRepCount;i++){

									if(rnd<=sdShotgunGuyRepChances[i]){
										newtypeinfo=PClass::FindClass(sdShotgunGuyReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
						}
						break;
				case 7: //SpiderMastermind
						//&&!sd_do_default_monsters

					if((level.flags & LEVEL_SPIDERSPECIAL)&&sd_bossrush2&&PClass::FindClass("SDBossChainEnder")&&!sd_do_defaultmonsters_replaceall){
							if(!multiplayer&&!sp_random_custom_monsters2)
								rnd=M_Random2()%100 + 1;
							else
								rnd=pr_gkspawnchance(100) + 1;


									//ok, now find which creature gets picked.
									//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
										if(sdSpiderChainRange>=255){
											rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdSpiderChainRange));

										}else{
											rnd=M_Random2()%sdSpiderChainRange + 1;
										}
									}else{
										rnd=pr_gkspawnchance(sdSpiderChainRange) + 1;
									}


									//now loop through range array to get corresponding index
									//of creature array
									for(int i=0;i<sdSpiderChainRepCount;i++){

										if(rnd<=sdSpiderChainChances[i]){
											newtypeinfo=PClass::FindClass(sdSpiderChainReps[i]);
											break;
										}

									}


					}else{
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_spidermastermind_chance2>0&&sdSpiderMastermindRepCount>0&&!sd_do_defaultmonsters_replaceall){ //&&!sd_do_default_monsters

							if(sd_rep_spidermastermind_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdSpiderMastermindRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdSpiderMastermindRange));

									}else{
										rnd=M_Random2()%sdSpiderMastermindRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdSpiderMastermindRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdSpiderMastermindRepCount;i++){

									if(rnd<=sdSpiderMastermindRepChances[i]){
										newtypeinfo=PClass::FindClass(sdSpiderMastermindReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
						}
		}
						break;
				case 116: //WolfensteinSS
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_wolfensteinss_chance2>0&&sdWolfensteinSSRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_wolfensteinss_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
							if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdWolfensteinSSRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdWolfensteinSSRange));

									}else{
										rnd=M_Random2()%sdWolfensteinSSRange + 1;
									}
							}else{
									rnd=pr_gkspawnchance(sdWolfensteinSSRange) + 1;
							}


								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdWolfensteinSSRepCount;i++){

									if(rnd<=sdWolfensteinSSRepChances[i]){
										newtypeinfo=PClass::FindClass(sdWolfensteinSSReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
									M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
							if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
						}
						break;
					case 4: //ZombieMan
						if(!multiplayer&&!sp_random_custom_monsters2)
							rnd=M_Random2()%100 + 1;
						else
							rnd=pr_gkspawnchance(100) + 1;


						if(sd_rep_zombieman_chance2>0&&sdZombieManRepCount>0&&!sd_do_default_monsters){

							if(sd_rep_zombieman_chance2>=rnd){
								//ok, now find which creature gets picked.
								//within the range
								if(!multiplayer&&!sp_random_custom_monsters2){
									if(sdZombieManRange>=255){
										rnd=int(((float(M_Random2()) + 1.0)/256.0)*float(sdZombieManRange));
										//ceil(?)(((M_Random2() + 1)/256)*sdZombieManRange);

									}else{
										rnd=M_Random2()%sdZombieManRange + 1;
									}
								}else{
									rnd=pr_gkspawnchance(sdZombieManRange) + 1;
								}

								//now loop through range array to get corresponding index
								//of creature array
								for(int i=0;i<sdZombieManRepCount;i++){

									if(rnd<=sdZombieManRepChances[i]){
										newtypeinfo=PClass::FindClass(sdZombieManReps[i]);
										break;
									}

								}

							}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
							}

						}else{
								//progress the rndtable regardless for consistency
								if(!multiplayer&&!sp_random_custom_monsters2)
								M_Random2();
						}


				}
				if(FBehavior::StaticModules.Size()==0||sd_acs_level_custom_monster_override){

					//if (newtypeinfo != NULL && newtypeinfo->ActorInfo != NULL){

						//if (debugfile) fprintf (debugfile, "CLASS: %s\n",newtypeinfo->ActorInfo->Class->TypeName.GetChars());

					//}
					if (newtypeinfo != NULL && newtypeinfo->ActorInfo != NULL)
					{
						//GHK: Lets set the TypeName..for Boss Replacement!
						//Sniff the type being replaced..probably an easier way to do this***
						//AActor *actorTest;
						//actorTest = static_cast<AActor *>(const_cast<PClass *>(type)->CreateNew ());

						//typeName=actorTest->GetClass()->ActorInfo->GetReplacee()->Class->TypeName;

						//if ((level.flags & (LEVEL_BRUISERSPECIAL)) == 0 && spwnid==3){
							//newtypeinfo->ActorInfo->GetReplacee()->Class->TypeName=type->ActorInfo->GetReplacee()->Class->TypeName;
							//newtypeinfo->TypeName.SetName(type->TypeName.GetChars());

						//}

						//typeName=type->TypeName;

						//GHK: for levels with special actions, keep the default type,
						//so it can be replaced below with its special replacement, since
						//it is important for boss levels with custom replacement types defined
						//by the wad level
						if(spwnid==7||spwnid==114||spwnid==3||spwnid==112||spwnid==6)
						{

							/*switch(spwnid){
								case 7:
									newtypeinfo->SDParentClass=type->ActorInfo->Class; //RUNTIME_CLASS(PClass::FindClass (NAME_SpiderMastermind)); //ghk, used for A_BossDeath code.
									break;
								case 114:
									newtypeinfo->SDParentClass=RUNTIME_CLASS(ACyberDemon); //ghk, used for A_BossDeath code.
									break;
								case 3:
									newtypeinfo->SDParentClass=RUNTIME_CLASS(ABaronOfHell); //ghk, used for A_BossDeath code.
									break;
								case 112:
									newtypeinfo->SDParentClass=RUNTIME_CLASS(AFatso); //ghk, used for A_BossDeath code.
									break;
								case 6:
									newtypeinfo->SDParentClass=RUNTIME_CLASS(AArachnotron); //ghk, used for A_BossDeath code.
									break;
							}
							*/
							//if (debugfile) fprintf (debugfile, "typeinfo0: %s",type->ActorInfo->Class->TypeName.GetChars());
							//if (debugfile) fprintf (debugfile, "mytypeinfo0: %s",newtypeinfo->ActorInfo->Class->TypeName.GetChars());

							if (!level.info->specialactions){
								newtypeinfo->SDParentClass=type->ActorInfo->Class;
								type=newtypeinfo;
								//if (debugfile) fprintf (debugfile, "mytypeinfo1: %s",newtypeinfo->SDParentClass->ActorInfo->Class->TypeName.GetChars());

							}else{
								type->SDParentClass=type->ActorInfo->Class; //GHK HACK  FOR A_BOSSDEATH
							}
						}else{
							newtypeinfo->SDParentClass=type->ActorInfo->Class;
							type=newtypeinfo;
						}

					}else{
						type->SDParentClass=type->ActorInfo->Class; //GHK HACK  FOR A_BOSSDEATH

						//if (debugfile) fprintf (debugfile, "mytypeinfo1: %s",type->ActorInfo->Class->TypeName.GetChars());

						//if (debugfile) fprintf (debugfile, "mytypeinfo1: %s",type->SDParentClass->ActorInfo->Class->TypeName.GetChars());

					}

				}else{
					//GHK, Need to consider if we want to spawn SD replacement monsters
					//for levels utilizing ACS. The sdmonsters DECORATE needs Thing IDs added for every monster
					//Additionally ThingCount and ThingCountName and other ACS functions which call actionspecials
					//from ACS script will sometimes add a TID, which simply is not supported by SD monsters
					//SO... either let players use sd monsters at their own risk with ACS wads, or
					//just disable by default. ...disable by default
					newtypeinfo=type;
					type->SDParentClass=type->ActorInfo->Class;

				}
				//now just get any associated health and artifacts which should also spawn
				if(PClass::FindClass ("SDSmartBomb")&&!nsFlag)
					PClass::GetRandomMonster (type,rnd,ix , iy, iz, false);

			}else{
				//all other spawnids, make sure SDParentClass is set to something
				type->SDParentClass=type->ActorInfo->Class;
			}


		}else if(!sd_do_default_monsters){
			//default 2.5r4 monsters



			if((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116)){

				M_Random2(); //GHK: needs to be here to make sure warping randomization and
							 //regular progression randomization are equivalent. Not 100% sure why.


			if(spwnid==7||spwnid==114){
				//cyber & spid bosses..always replace
				//except for boss levels for now...
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2();
				else
				rnd=pr_gkspawnchance();

				//NOW ALWAYS DO A REPLACE FOR CYBS & SPIDMASTERS
				//if(rnd>80){
				if(rnd>=0){
					//if ((level.flags & (LEVEL_CYBORGSPECIAL|
								//LEVEL_SPIDERSPECIAL)) == 0){

						if(PClass::FindClass ("SDSmartBomb")) //Add checks for addonpack here, to support new artifact code.
							newtypeinfo = PClass::GetRandomMonster (type,rnd,ix, iy, iz);
					//}
				}
			}else if(spwnid==3){
				//barons, more chance of replacing, now 3/4 of the time

				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2();
					else
						rnd=pr_gkspawnchance();

				//if(rnd>130){
				if(rnd>63){
					//except for boss levels for now...

					//if ((level.flags & (LEVEL_BRUISERSPECIAL)) == 0){
						//AActor *actorTest;
						//actorTest = static_cast<AActor *>(const_cast<PClass *>(type)->CreateNew ());

						//typeName=actorTest->GetClass()->ActorInfo->GetReplacee()->Class->TypeName;

						//newtypeinfo = PClass::GetRandomMonster (type);
					//}else{
						//FSpecialAction *sa = level.info->specialactions;
						//while (sa){
							//if(sa->Type==type->TypeName){
								//sa->Type=newtypeinfo->TypeName;
								//break;
							//}
							//sa = sa->Next;

						//}

					//}
						if(PClass::FindClass ("SDSmartBomb")) //Add checks for addonpack here, to support new artifact code.
							newtypeinfo = PClass::GetRandomMonster (type,rnd,ix , iy, iz);

					//}
				}else{
					//check for hardboss wad...
					if(PClass::FindClass ("BaronOfHellHARD")){
						newtypeinfo = PClass::FindClass ("BaronOfHellHARD");
					}
				}

			}else{
				//the rest
				if(!multiplayer&&!sp_random_custom_monsters2)
					rnd=M_Random2();
					else
						rnd=pr_gkspawnchance();
				//now replace 2/3 of the time
				//if(rnd>150&&((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116))){
				//if(rnd>85&&((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116))){
				if((spwnid>=1&&spwnid<=10)||(spwnid>=19&&spwnid<=20)||(spwnid>=110&&spwnid<=116)){

				//newtypeinfo = PClass::FindClass ("DoomImp");
					if(PClass::FindClass ("SDSmartBomb")) //Add checks for addonpack here, to support new artifact code.
						newtypeinfo = PClass::GetRandomMonster (type,rnd,ix,iy,iz);


				}

			}
			if (newtypeinfo != NULL && newtypeinfo->ActorInfo != NULL)
			{
					//GHK: Lets set the TypeName..for Boss Replacement!
					//Sniff the type being replaced..probably an easier way to do this***
					//AActor *actorTest;
					//actorTest = static_cast<AActor *>(const_cast<PClass *>(type)->CreateNew ());

					//typeName=actorTest->GetClass()->ActorInfo->GetReplacee()->Class->TypeName;

					//if ((level.flags & (LEVEL_BRUISERSPECIAL)) == 0 && spwnid==3){
						//newtypeinfo->ActorInfo->GetReplacee()->Class->TypeName=type->ActorInfo->GetReplacee()->Class->TypeName;
						//newtypeinfo->TypeName.SetName(type->TypeName.GetChars());

					//}

					//typeName=type->TypeName;

					//GHK: for levels with special actions, keep the default type,
					//so it can be replaced below with its special replacement, since
					//it is important for boss levels with custom replacement types defined
					//by the wad level
					if(spwnid==7||spwnid==114||spwnid==3||spwnid==112||spwnid==6)
					{

						/*switch(spwnid){
							case 7:
								newtypeinfo->SDParentClass=type->ActorInfo->Class; //RUNTIME_CLASS(PClass::FindClass (NAME_SpiderMastermind)); //ghk, used for A_BossDeath code.
								break;
							case 114:
								newtypeinfo->SDParentClass=RUNTIME_CLASS(ACyberDemon); //ghk, used for A_BossDeath code.
								break;
							case 3:
								newtypeinfo->SDParentClass=RUNTIME_CLASS(ABaronOfHell); //ghk, used for A_BossDeath code.
								break;
							case 112:
								newtypeinfo->SDParentClass=RUNTIME_CLASS(AFatso); //ghk, used for A_BossDeath code.
								break;
							case 6:
								newtypeinfo->SDParentClass=RUNTIME_CLASS(AArachnotron); //ghk, used for A_BossDeath code.
								break;
						}
						*/
						if (!level.info->specialactions){
							newtypeinfo->SDParentClass=type->ActorInfo->Class;
							type=newtypeinfo;
						}else{
							type->SDParentClass=type->ActorInfo->Class; //GHK HACK  FOR A_BOSSDEATH
						}
					}else{
						newtypeinfo->SDParentClass=type->ActorInfo->Class;
						type=newtypeinfo;
					}

			}else{
				type->SDParentClass=type->ActorInfo->Class; //GHK HACK  FOR A_BOSSDEATH
			}
		}else{
			//all other spawnids, make sure SDParentClass is set to something
			type->SDParentClass=type->ActorInfo->Class;
		}

	}
	else{
			//all other spawnids, make sure SDParentClass is set to something
			type->SDParentClass=type->ActorInfo->Class;
		}

	}


	if (allowreplacement){
		type = type->ActorInfo->GetReplacement()->Class;
		type->SDParentClass=type->ActorInfo->GetReplacee()->Class; //GHK HACK FOR A_BOSSDEATH
	}


	AActor *actor;

	actor = static_cast<AActor *>(const_cast<PClass *>(type)->CreateNew ());

	//GHK test scriptedmarine code

	if (actor->IsKindOf (RUNTIME_CLASS(AScriptedMarineSD)))
	{
		const PClass *type2 = PClass::FindClass ("WolfensteinSS");
		static_cast<AScriptedMarine *>(actor)->SetSprite (type2);
		//Set the sounds to be more like a monster, to distinguish from regular wolfensteinSS troopers
		actor->DeathSound=GetDefaultByType (PClass::FindClass ("ZombieMan"))->DeathSound;
		actor->PainSound=GetDefaultByType (PClass::FindClass ("ZombieMan"))->PainSound;
	}

	actor->x = actor->PrevX = ix;
	actor->y = actor->PrevY = iy;
	actor->z = actor->PrevZ = iz;
	actor->picnum = 0xffff;

	//ghk
	if (gameinfo.gametype == GAME_Doom){
		bool isMonster=false;
		actor->SDParentPClass=type->SDParentClass->TypeName;


		//if (debugfile) fprintf (debugfile, "SDPARENTCLASS foundboss: %s \n",type->SDParentClass->TypeName.GetChars());
		//if (debugfile) fprintf (debugfile, "typeinfo: %s \n",actor->GetClass()->TypeName.GetChars());


		//ghk: this code forces any custom decorate replacements to
		//adhere to the replacee's dimensions. So no need to edit DECORATE of
		//custom replacer.
		//scale factor is 65536 to convert from decorate units.

		//ensure we dont morph 'bosses' ;-)
		//also make baron, cyberdemon & spidmaster 'bosses' more agressive in scoredoom
		//if(actor->flags2 & MF2_BOSS){


		//boss rush chain spawns are given spawnid=155 in add-on pack wad.
		if(spwnid==3||spwnid==114||spwnid==7||spwnid==155){

			actor->flags3 |= MF3_DONTMORPH;
			actor->flags4 |= MF4_NOICEDEATH|MF4_BOSSDEATH;

			if(dmflags2 & DF2_AGGRESSIVE_BOSSES)
				actor->flags4 |= MF4_MISSILEMORE|MF4_MISSILEEVENMORE;

		}


		switch(spwnid){
			case 6: //arachnotron
				if(actor->height>4194304)
					actor->height=4194304;

				if(actor->radius>4194304)
					actor->radius=4194304;

				isMonster=true;
				break;
			case 111: //archvile
				if(actor->height>3670016)
					actor->height=3670016;

				if(actor->radius>1310720)
					actor->radius=1310720;

				isMonster=true;
				break;
			case 3: //baronofhell
			case 113: //hellknight
				if(actor->height>4194304)
					actor->height=4194304;

				if(actor->radius>1572864)
					actor->radius=1572864;

				isMonster=true;
				break;
			case 19: //cacodemon
			case 115: //pain elemental
				if(actor->height>3670016)
					actor->height=3670016;

				if(actor->radius>2031616)
					actor->radius=2031616;

				isMonster=true;
				break;
			case 114: //cyberdemon
				if(actor->height>7208960)
					actor->height=7208960;

				if(actor->radius>2621440)
					actor->radius=2621440;

				isMonster=true;
				break;
			case 8: //demon
			case 9: //spectre
				if(actor->height>3670016)
					actor->height=3670016;

				if(actor->radius>1966080)
					actor->radius=1966080;

				isMonster=true;
				break;
			case 2: //chaingunguy
			case 5: //doomimp
			case 1: //shotgunguy
			case 116: //wolfensteinSS
			case 4: //zombieman
			case 20: //revenant

				if(actor->height>3670016)
					actor->height=3670016;

				if(actor->radius>1310720)
					actor->radius=1310720;

				isMonster=true;
				break;

			case 112: //fatso

				if(actor->height>4194304)
					actor->height=4194304;

				if(actor->radius>3145728)
					actor->radius=3145728;

				isMonster=true;
				break;
			case 110: //lost soul

				if(actor->height>3670016)
					actor->height=3670016;

				if(actor->radius>1048576)
					actor->radius=1048576;

				isMonster=true;
				break;

			case 7: //spider mastermind

				if(actor->height>6553600)
					actor->height=6553600;

				if(actor->radius>8388608)
					actor->radius=8388608;

				isMonster=true;
				break;
			case 149: //burning barrel

				if(actor->height>2097152)
					actor->height=2097152;

				if(actor->radius>1048576)
					actor->radius=1048576;

				break;
			case 125: //exploding barrel

				if(actor->height>2228224)
					actor->height=2228224;

				if(actor->radius>655360)
					actor->radius=655360;

				break;

		}
			actor->origx=actor->x; //GHK for boss chain fix
			actor->origy=actor->y;
			actor->origz=actor->z;

			if((i_compatflags & COMPATF_FORCEBLOCKMONST) && (actor->flags3 & MF3_ISMONSTER))
				actor->flags3 &=~MF3_NOBLOCKMONST;
				//if (debugfile) fprintf (debugfile, "COMPATF_FORCEBLOCKMONST:%d",COMPATF_FORCEBLOCKMONST);
				//if (debugfile) fprintf (debugfile, "i_compatflags:%d",i_compatflags);


		//for boss chains on LEVEL_BRUISERSPECIAL|LEVEL_CYBORGSPECIAL|LEVEL_SPIDERSPECIAL levels
		//make sure these actors are -SOLID and +NOBLOCKMONST, or can get collisions that cause
		//spawn problems.
		if((level.flags & (LEVEL_BRUISERSPECIAL|LEVEL_CYBORGSPECIAL|LEVEL_SPIDERSPECIAL))&&sd_bossrush2&&PClass::FindClass("SDBossChainEnder")&&isMonster){
			//actor->flags &=~MF_SOLID; GHK, MAKE SURE THIS IS OK?
			actor->flags3 |=MF3_NOBLOCKMONST;
			//level.flags|=LEVEL_MONSTERSTELEFRAG;

		}

		if(isMonster&&sd_notarget)
			actor->flags3 |=MF3_NOTARGET;




	}


	FRandom &rng = bglobal.m_Thinking ? pr_botspawnmobj : pr_spawnmobj;

	if (actor->isFast() && actor->flags3 & MF3_ISMONSTER)
		actor->reactiontime = 0;

	if (actor->flags3 & MF3_ISMONSTER)
	{
		actor->LastLook.PlayerNumber = rng() % MAXPLAYERS;
		actor->TIDtoHate = 0;
	}

	//GHK SSHOTTY LAG FIX
    actor->lastpnumdmg = MAXPLAYERS+1;	//Initialize the playernum to something unfeasible
	actor->multidmgbuffer=0;

	// Set the state, but do not use SetState, because action
	// routines can't be called yet.  If the spawnstate has an action
	// routine, it will not be called.
	FState *st = actor->SpawnState;
	actor->state = st;
	actor->tics = st->GetTics();

	actor->sprite = st->sprite.index;
	actor->frame = st->GetFrame();
	actor->renderflags = (actor->renderflags & ~RF_FULLBRIGHT) | st->GetFullbright();
	actor->touching_sectorlist = NULL;	// NULL head of sector list // phares 3/13/98
	if (G_SkillProperty(SKILLP_FastMonsters))
		actor->Speed = actor->GetClass()->Meta.GetMetaFixed(AMETA_FastSpeed, actor->Speed);

	// set subsector and/or block links
	actor->LinkToWorld (SpawningMapThing);
	if (SpawningMapThing || !type->IsDescendantOf (RUNTIME_CLASS(APlayerPawn)))
	{
		actor->dropoffz =			// killough 11/98: for tracking dropoffs
		actor->floorz = actor->Sector->floorplane.ZatPoint (ix, iy);
		actor->ceilingz = actor->Sector->ceilingplane.ZatPoint (ix, iy);
		actor->floorsector = actor->Sector;
		actor->floorpic = actor->floorsector->floorpic;
		actor->ceilingsector = actor->Sector;
		actor->ceilingpic = actor->ceilingsector->ceilingpic;
	}
	else
	{
		P_FindFloorCeiling (actor);
		actor->floorz = tmffloorz;
		actor->dropoffz = tmfdropoffz;
		actor->ceilingz = tmfceilingz;
		actor->floorpic = tmffloorpic;
		actor->floorsector = tmffloorsector;
		actor->ceilingpic = tmfceilingpic;
		actor->ceilingsector = tmfceilingsector;
	}

	actor->SpawnPoint[0] = ix >> FRACBITS;
	actor->SpawnPoint[1] = iy >> FRACBITS;

	if (iz == ONFLOORZ)
	{
		actor->z = actor->floorz;
	}
	else if (iz == ONCEILINGZ)
	{
		actor->z = actor->ceilingz - actor->height;
	}
	else if (iz == FLOATRANDZ)
	{
		fixed_t space = actor->ceilingz - actor->height - actor->floorz;
		if (space > 48*FRACUNIT)
		{
			space -= 40*FRACUNIT;
			actor->z = MulScale8 (space, rng()) + actor->floorz + 40*FRACUNIT;
		}
		else
		{
			actor->z = actor->floorz;
		}
	}
	else
	{
		actor->SpawnPoint[2] = (actor->z - actor->floorz) >> FRACBITS;
	}

	if (actor->flags2 & MF2_FLOATBOB)
	{ // Prime the bobber
		actor->FloatBobPhase = rng();
		actor->z += FloatBobOffsets[(actor->FloatBobPhase + level.maptime - 1) & 63];
	}
	if (actor->flags2 & MF2_FLOORCLIP)
	{
		actor->AdjustFloorClip ();
	}
	else
	{
		actor->floorclip = 0;
	}
	actor->UpdateWaterLevel (actor->z, false);
	if (!SpawningMapThing)
	{
		actor->BeginPlay ();
		if (actor->ObjectFlags & OF_MassDestruction)
		{
			return NULL;
		}
	}
	if (level.flags & LEVEL_NOALLIES && !actor->player)
	{
		actor->flags &= ~MF_FRIENDLY;
	}
	//ghk, deal with no-score monsters
	//nsFlag gets set to true only by bosscube spawns and painelementals
	//if (gameinfo.gametype == GAME_Doom){
	if(nsFlag)
		actor->flags &= ~MF_COUNTKILL;

	//}

	// [RH] Count monsters whenever they are spawned.
	if (actor->CountsAsKill())
	{
		level.total_monsters++;
	}
	// [RH] Same, for items
	if (actor->flags & MF_COUNTITEM)
	{
		level.total_items++;
	}
	gl_SetActorLights(actor);
	return actor;
}

AActor *Spawn (const char *type, fixed_t x, fixed_t y, fixed_t z, replace_t allowreplacement, bool nsFlag)
{
	const PClass *cls = PClass::FindClass(type);
	if (cls == NULL)
	{
		I_Error("Attempt to spawn actor of unknown type '%s'\n", type);
	}
	return AActor::StaticSpawn (cls, x, y, z, allowreplacement, nsFlag);
}

//GHK, Spawn SD No Scores
/*AActor *SpawnNS (const char *type, fixed_t x, fixed_t y, fixed_t z, replace_t allowreplacement)
{
	const PClass *cls = PClass::FindClass(type);
	if (cls == NULL)
	{
		I_Error("Attempt to spawn actor of unknown type '%s'\n", type);
	}
	return AActor::StaticSpawn (cls, x, y, z, allowreplacement, true);
}
*/
void AActor::LevelSpawned ()
{
	if (tics > 0 && !(flags4 & MF4_SYNCHRONIZED))
		tics = 1 + (pr_spawnmapthing() % tics);
	angle_t incs = AngleIncrements ();
	angle -= angle % incs;
	flags &= ~MF_DROPPED;		// [RH] clear MF_DROPPED flag
	HandleSpawnFlags ();
}

void AActor::HandleSpawnFlags ()
{
	if (SpawnFlags & MTF_AMBUSH)
	{
		flags |= MF_AMBUSH;
	}
	if (SpawnFlags & MTF_DORMANT)
	{
		Deactivate (NULL);
	}
	if (SpawnFlags & MTF_STANDSTILL)
	{
		flags4 |= MF4_STANDSTILL;
	}
	if (SpawnFlags & MTF_FRIENDLY)
	{
		flags |= MF_FRIENDLY;
		// Friendlies don't count as kills!
		if (flags & MF_COUNTKILL)
		{
			flags &= ~MF_COUNTKILL;
			level.total_monsters--;
		}
	}
	if (SpawnFlags & MTF_SHADOW)
	{
		flags |= MF_SHADOW;
		RenderStyle = STYLE_Translucent;
		alpha = TRANSLUC25;
	}
	else if (SpawnFlags & MTF_ALTSHADOW)
	{
		RenderStyle = STYLE_None;
	}
}

void AActor::BeginPlay ()
{
}

bool AActor::isFast()
{
	if (flags5&MF5_ALWAYSFAST) return true;
	if (flags5&MF5_NEVERFAST) return false;
	return !!G_SkillProperty(SKILLP_FastMonsters);
}

void AActor::Activate (AActor *activator)
{
	if ((flags3 & MF3_ISMONSTER) && (health > 0 || (flags & MF_ICECORPSE)))
	{
		if (flags2 & MF2_DORMANT)
		{
			flags2 &= ~MF2_DORMANT;
			tics = 1;
		}
	}
}

void AActor::Deactivate (AActor *activator)
{
	if ((flags3 & MF3_ISMONSTER) && (health > 0 || (flags & MF_ICECORPSE)))
	{
		if (!(flags2 & MF2_DORMANT))
		{
			flags2 |= MF2_DORMANT;
			tics = -1;
		}
	}
}

//
// P_RemoveMobj
//

void AActor::Destroy ()
{
	// [RH] Destroy any inventory this actor is carrying
	DestroyAllInventory ();

	// [RH] Unlink from tid chain
	RemoveFromHash ();

	// unlink from sector and block lists
	UnlinkFromWorld ();
	flags |= MF_NOSECTOR|MF_NOBLOCKMAP;

	// Delete all nodes on the current sector_list			phares 3/16/98
	P_DelSector_List();

	// Transform any playing sound into positioned, non-actor sounds.
	S_RelinkSound (this, NULL);

	Super::Destroy ();
}

//===========================================================================
//
// AdjustFloorClip
//
//===========================================================================

void AActor::AdjustFloorClip ()
{
	if (flags3 & MF3_SPECIALFLOORCLIP)
	{
		return;
	}

	fixed_t oldclip = floorclip;
	fixed_t shallowestclip = FIXED_MAX;
	const msecnode_t *m;

	// possibly standing on a 3D-floor!
	if (Sector->e->ffloors.Size() && z>Sector->floorplane.ZatPoint(x,y)) floorclip=0;

	// [RH] clip based on shallowest floor player is standing on
	// If the sector has a deep water effect, then let that effect
	// do the floorclipping instead of the terrain type.
	for (m = touching_sectorlist; m; m = m->m_tnext)
	{
		if ((m->m_sector->heightsec == NULL ||
			 m->m_sector->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC) &&
			m->m_sector->floorplane.ZatPoint (x, y) == z)
		{
			fixed_t clip = Terrains[TerrainTypes[m->m_sector->floorpic]].FootClip;
			if (clip < shallowestclip)
			{
				shallowestclip = clip;
			}
		}
	}
	if (shallowestclip == FIXED_MAX)
	{
		floorclip = 0;
	}
	else
	{
		floorclip = shallowestclip;
	}
	if (player && player->mo == this && oldclip != floorclip)
	{
		player->viewheight -= oldclip - floorclip;
		player->deltaviewheight = player->GetDeltaViewHeight();
	}
}

//
// P_SpawnPlayer
// Called when a player is spawned on the level.
// Most of the player structure stays unchanged between levels.
//
EXTERN_CVAR (Bool, chasedemo)

extern bool demonew;

void P_SpawnPlayer (mapthing2_t *mthing, bool tempplayer)
{
	int		  playernum;
	player_t *p;
	APlayerPawn *mobj, *oldactor;
	BYTE	  state;
	//ghk 3 new local vars
	fixed_t		SpawnX;
	fixed_t		SpawnY;
	angle_t		SpawnAngle;

	// [RH] Things 4001-? are also multiplayer starts. Just like 1-4.
	//		To make things simpler, figure out which player is being
	//		spawned here.
	if (mthing->type <= 4 || gameinfo.gametype == GAME_Strife)		// don't forget Strife's starts 5-8 here!
	{
		playernum = mthing->type - 1;
	}
	else if (gameinfo.gametype != GAME_Hexen)
	{
		playernum = mthing->type - 4001 + 4;
	}
	else
	{
		playernum = mthing->type - 9100 + 4;
	}

	// not playing?
	if (playernum >= MAXPLAYERS || !playeringame[playernum])
		return;

	p = &players[playernum];

	if (p->cls == NULL)
	{
		// [GRB] Pick a class from player class list
		if (PlayerClasses.Size () > 1)
		{
			int type;

			if (!deathmatch || !multiplayer)
			{
				type = SinglePlayerClass[playernum];
			}
			else
			{
				type = p->userinfo.PlayerClass;
				if (type < 0)
				{
					type = pr_multiclasschoice() % PlayerClasses.Size ();
				}
			}
			p->CurrentPlayerClass = type;
		}
		else
		{
			p->CurrentPlayerClass = 0;
		}
		p->cls = PlayerClasses[p->CurrentPlayerClass].Type;
	}
	//ghk new
	if (( dmflags2 & DF2_SAME_SPAWN_SPOT ) &&
		(p->playerstate == PST_REBORN ) &&
		( deathmatch == false ) &&
		( gameaction != ga_worlddone ) &&
		( p->bSpawnOkay ))
	{
		SpawnX = p->SpawnX;
		SpawnY = p->SpawnY;
		SpawnAngle = p->SpawnAngle;
	}
	else
	{
		SpawnX = mthing->x << FRACBITS;
		SpawnY = mthing->y << FRACBITS;
		SpawnAngle = ANG45 * (mthing->angle/45);
	}

	mobj = static_cast<APlayerPawn *>
		(Spawn (p->cls, SpawnX, SpawnY, ONFLOORZ, NO_REPLACE));
	//

	//ghk old:
	//	mobj = static_cast<APlayerPawn *>
	//	(Spawn (p->cls, mthing->x << FRACBITS, mthing->y << FRACBITS, ONFLOORZ, NO_REPLACE));

	mobj->FriendPlayer = playernum + 1;	// [RH] players are their own friends
	oldactor = p->mo;
	p->mo = mobj;
	mobj->player = p;
	state = p->playerstate;
	if (state == PST_REBORN || state == PST_ENTER)
	{
		G_PlayerReborn (playernum);
	}
	else if (oldactor != NULL && oldactor->player == p && !tempplayer)
	{
		// Move the voodoo doll's inventory to the new player.
		mobj->ObtainInventory (oldactor);
		FBehavior::StaticStopMyScripts (oldactor);	// cancel all ENTER/RESPAWN scripts for the voodoo doll
	}

	// [GRB] Reset skin
	p->userinfo.skin = R_FindSkin (skins[p->userinfo.skin].name, p->CurrentPlayerClass);
	StatusBar->SetFace (&skins[p->userinfo.skin]);

	// [RH] Be sure the player has the right translation
	R_BuildPlayerTranslation (playernum);

	// [RH] set color translations for player sprites
	mobj->Translation = TRANSLATION(TRANSLATION_Players,playernum);

	mobj->angle = SpawnAngle; // ANG45 * (mthing->angle/45); //ghk
	mobj->pitch = mobj->roll = 0;
	mobj->health = p->health;

	//Added by MC: Identification (number in the players[MAXPLAYERS] array)
    mobj->id = playernum;

	// [RH] Set player sprite based on skin
	mobj->sprite = skins[p->userinfo.skin].sprite;
	mobj->scaleX = mobj->scaleY = skins[p->userinfo.skin].Scale;

	p->DesiredFOV = p->FOV = 90.f;
	p->camera = p->mo;
	p->playerstate = PST_LIVE;
	p->refire = 0;
	p->damagecount = 0;
	p->bonuscount = 0;
	p->morphTics = 0;
	p->extralight = 0;
	p->fixedcolormap = 0;
	p->viewheight = mobj->ViewHeight;
	p->inconsistant = 0;
	p->attacker = NULL;
	p->spreecount = 0;
	p->multicount = 0;
	p->lastkilltime = 0;
	p->BlendR = p->BlendG = p->BlendB = p->BlendA = 0.f;
	p->mo->ResetAirSupply();
	p->Uncrouch();

	p->momx = p->momy = 0;		// killough 10/98: initialize bobbing to 0.

	if (players[consoleplayer].camera == oldactor)
	{
		players[consoleplayer].camera = mobj;
	}

	// [RH] Allow chasecam for demo watching
	if ((demoplayback || demonew) && chasedemo)
		p->cheats = CF_CHASECAM;

	// setup gun psprite
	if (!tempplayer)
	{
		// This can also start a script so don't do it for
		// the dummy player.
		P_SetupPsprites (p);
	}

	if (deathmatch)
	{ // Give all cards in death match mode.
		p->mo->GiveDeathmatchInventory ();
	}
	else if (multiplayer && state == PST_REBORN && oldactor != NULL)
	{ // Special inventory handling for respawning in coop
		p->mo->FilterCoopRespawnInventory (oldactor);
	}
	if (oldactor != NULL)
	{ // Remove any inventory left from the old actor. Coop handles
	  // it above, but the other modes don't.
		oldactor->DestroyAllInventory();
	}

	if (StatusBar != NULL && (playernum == consoleplayer || StatusBar->GetPlayer() == playernum))
	{
		StatusBar->AttachToPlayer (p);
	}

	if (multiplayer)
	{
		unsigned an = ( ANG45 * (mthing->angle/45) ) >> ANGLETOFINESHIFT;
		Spawn ("TeleportFog", mobj->x+20*finecosine[an], mobj->y+20*finesine[an], mobj->z + TELEFOGHEIGHT, ALLOW_REPLACE);
	}

	// "Fix" for one of the starts on exec.wad MAP01: If you start inside the ceiling,
	// drop down below it, even if that means sinking into the floor.
	if (mobj->z + mobj->height > mobj->ceilingz)
	{
		mobj->z = mobj->ceilingz - mobj->height;
	}

	// [RH] If someone is in the way, kill them
	P_PlayerStartStomp (mobj);

	// [BC] Do script stuff
	if (!tempplayer)
	{
		if (state == PST_ENTER || (state == PST_LIVE && !savegamerestore))
		{
			FBehavior::StaticStartTypedScripts (SCRIPT_Enter, p->mo, true);
		}
		else if (state == PST_REBORN)
		{
			assert (oldactor != NULL);
			DObject::PointerSubstitution (oldactor, p->mo);
			// PointerSubstitution() will also affect the bodyque, so undo that now.
			for (int ii=0; ii < BODYQUESIZE; ++ii)
				if (bodyque[ii] == p->mo)
					bodyque[ii] = oldactor;
			FBehavior::StaticStartTypedScripts (SCRIPT_Respawn, p->mo, true);
		}
	}
}


//
// P_SpawnMapThing
// The fields of the mapthing should
// already be in host byte order.
//
// [RH] position is used to weed out unwanted start spots
void P_SpawnMapThing (mapthing2_t *mthing, int position)
{
	const PClass *i;
	int mask;
	AActor *mobj;
	fixed_t x, y, z;
	static unsigned int classFlags[] =
	{
		MTF_FIGHTER,
		MTF_CLERIC,
		MTF_MAGE,
	};

	T_PrepareSpawnThing();

	if (mthing->type == 0 || mthing->type == -1)
		return;

	// count deathmatch start positions
	if (mthing->type == 11)
	{
		deathmatchstarts.Push (*mthing);
		return;
	}

	// Convert Strife starts to Hexen-style starts
	if (gameinfo.gametype == GAME_Strife && mthing->type >= 118 && mthing->type <= 127)
	{
		mthing->args[0] = mthing->type - 117;
		mthing->type = 1;
	}

	// [RH] Record polyobject-related things
	if (gameinfo.gametype == GAME_Hexen)
	{
		switch (mthing->type)
		{
		case PO_HEX_ANCHOR_TYPE:
			mthing->type = PO_ANCHOR_TYPE;
			break;
		case PO_HEX_SPAWN_TYPE:
			mthing->type = PO_SPAWN_TYPE;
			break;
		case PO_HEX_SPAWNCRUSH_TYPE:
			mthing->type = PO_SPAWNCRUSH_TYPE;
			break;
		}
	}

	if (mthing->type == PO_ANCHOR_TYPE ||
		mthing->type == PO_SPAWN_TYPE ||
		mthing->type == PO_SPAWNCRUSH_TYPE ||
		mthing->type == PO_SPAWNHURT_TYPE)
	{
		polyspawns_t *polyspawn = new polyspawns_t;
		polyspawn->next = polyspawns;
		polyspawn->x = mthing->x << FRACBITS;
		polyspawn->y = mthing->y << FRACBITS;
		polyspawn->angle = mthing->angle;
		polyspawn->type = mthing->type;
		polyspawns = polyspawn;
		if (mthing->type != PO_ANCHOR_TYPE)
			po_NumPolyobjs++;
		return;
	}

	// check for players specially
	int pnum = -1;

	if (mthing->type <= 4 && mthing->type > 0)
	{
		pnum = mthing->type - 1;
	}
	else
	{
		const int base = (gameinfo.gametype == GAME_Strife) ? 5 :
						 (gameinfo.gametype == GAME_Hexen) ? 9100 : 4001;

		if (mthing->type >= base && mthing->type < base + MAXPLAYERS - 4)
		{
			pnum = mthing->type - base + 4;
		}
	}

	if (pnum == -1 || (level.flags & LEVEL_FILTERSTARTS))
	{
		// check for appropriate game type
		if (deathmatch)
		{
			mask = MTF_DEATHMATCH;
		}
		else if (multiplayer)
		{
			mask = MTF_COOPERATIVE;
		}
		else
		{
			mask = MTF_SINGLE;
		}
		if (!(mthing->flags & mask))
		{
			return;
		}

		mask = G_SkillProperty(SKILLP_SpawnFilter);
		if (!(mthing->flags & mask))
		{
			return;
		}

		// Check class spawn masks. Now with player classes available
		// this is enabled for all games.
		if (!multiplayer)
		{ // Single player
			int spawnmask = players[consoleplayer].GetSpawnClass();
			if (spawnmask != 0 && (mthing->flags & spawnmask) == 0)
			{ // Not for current class
				return;
			}
		}
		else if (!deathmatch)
		{ // Cooperative
			mask = 0;
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (playeringame[i])
				{
					int spawnmask = players[i].GetSpawnClass();
					if (spawnmask != 0)
						mask |= spawnmask;
					else
						mask = -1;
				}
			}
			if (mask != -1 && (mthing->flags & mask) == 0)
			{
				return;
			}
		}
	}

	if (pnum != -1)
	{
		// [RH] Only spawn spots that match position.
		if (mthing->args[0] != position)
			return;

		// save spots for respawning in network games
		playerstarts[pnum] = *mthing;
		if (!deathmatch)
			P_SpawnPlayer (mthing);

		return;
	}

	// [RH] sound sequence overriders
	if (mthing->type >= 1400 && mthing->type < 1410)
	{
		R_PointInSubsector (mthing->x<<FRACBITS,
			mthing->y<<FRACBITS)->sector->seqType = mthing->type - 1400;
		return;
	}
	else if (mthing->type == 1411)
	{
		int type;

		if (mthing->args[0] == 255)
			type = -1;
		else
			type = mthing->args[0];

		if (type > 63)
		{
			Printf ("Sound sequence %d out of range\n", type);
		}
		else
		{
			R_PointInSubsector (mthing->x << FRACBITS,
				mthing->y << FRACBITS)->sector->seqType = type;
		}
		return;
	}

	// [RH] Determine if it is an old ambient thing, and if so,
	//		map it to MT_AMBIENT with the proper parameter.
	if (mthing->type >= 14001 && mthing->type <= 14064)
	{
		mthing->args[0] = mthing->type - 14000;
		mthing->type = 14065;
		i = RUNTIME_CLASS(AAmbientSound);
	}
	else
	{
		// find which type to spawn
		i = DoomEdMap.FindType (mthing->type);
	}

	if (i == NULL)
	{
		// [RH] Don't die if the map tries to spawn an unknown thing
		Printf ("Unknown type %i at (%i, %i)\n",
				 mthing->type,
				 mthing->x, mthing->y);
		i = PClass::FindClass("Unknown");
	}
	// [RH] If the thing's corresponding sprite has no frames, also map
	//		it to the unknown thing.
	else
	{
		// Handle decorate replacements explicitly here
		// to check for missing frames in the replacement object.
		i = i->ActorInfo->GetReplacement()->Class;

		const AActor *defaults = GetDefaultByType (i);
		if (defaults->SpawnState == NULL ||
			sprites[defaults->SpawnState->sprite.index].numframes == 0)
		{
			Printf ("%s at (%i, %i) has no frames\n",
					i->TypeName.GetChars(), mthing->x, mthing->y);
			i = PClass::FindClass("Unknown");
		}
	}

	const AActor *info = GetDefaultByType (i);

	// don't spawn keycards and players in deathmatch
	if (deathmatch && info->flags & MF_NOTDMATCH)
		return;

	// [RH] don't spawn extra weapons in coop if so desired
	if (multiplayer && !deathmatch && (dmflags & DF_NO_COOP_WEAPON_SPAWN))
	{
		if (i->IsDescendantOf (RUNTIME_CLASS(AWeapon)))
		{
			if ((mthing->flags & (MTF_DEATHMATCH|MTF_SINGLE)) == MTF_DEATHMATCH)
				return;
		}
	}

	// don't spawn any monsters if -nomonsters
	if (((level.flags & LEVEL_NOMONSTERS) || (dmflags & DF_NO_MONSTERS)) && info->flags3 & MF3_ISMONSTER )
	{
		return;
	}

	// [RH] Other things that shouldn't be spawned depending on dmflags
	if (deathmatch || alwaysapplydmflags)
	{
		if (dmflags & DF_NO_HEALTH)
		{
			if (i->IsDescendantOf (RUNTIME_CLASS(AHealth)))
				return;
			if (i->TypeName == NAME_Berserk)
				return;
			if (i->TypeName == NAME_Soulsphere)
				return;
			if (i->TypeName == NAME_Megasphere)
				return;
		}
		if (dmflags & DF_NO_ITEMS)
		{
//			if (i->IsDescendantOf (RUNTIME_CLASS(AArtifact)))
//				return;
		}
		if (dmflags & DF_NO_ARMOR)
		{
			if (i->IsDescendantOf (RUNTIME_CLASS(AArmor)))
				return;
			if (i->TypeName == NAME_Megasphere)
				return;
		}
	}

	// spawn it
	x = mthing->x << FRACBITS;
	y = mthing->y << FRACBITS;

	if (info->flags & MF_SPAWNCEILING)
		z = ONCEILINGZ;
	else if (info->flags2 & MF2_SPAWNFLOAT)
		z = FLOATRANDZ;
	else
		z = ONFLOORZ;

	SpawningMapThing = true;
	mobj = Spawn (i, x, y, z, NO_REPLACE);
	SpawningMapThing = false;

	if (z == ONFLOORZ)
		mobj->z += mthing->z << FRACBITS;
	else if (z == ONCEILINGZ)
		mobj->z -= mthing->z << FRACBITS;

	mobj->SpawnPoint[0] = mthing->x;
	mobj->SpawnPoint[1] = mthing->y;
	mobj->SpawnPoint[2] = mthing->z;
	mobj->SpawnAngle = mthing->angle;
	mobj->SpawnFlags = mthing->flags;

	if (!(mobj->flags2 & MF2_ARGSDEFINED))
	{
		// [RH] Set the thing's special
		mobj->special = mthing->special;
		for(int j=0;j<5;j++) mobj->args[j]=mthing->args[j];
	}

	// [RH] Add ThingID to mobj and link it in with the others
	mobj->tid = mthing->thingid;
	mobj->AddToHash ();

	mobj->angle = (DWORD)((mthing->angle * UCONST64(0x100000000)) / 360);
	mobj->BeginPlay ();
	if (mobj->ObjectFlags & OF_MassDestruction)
	{
		return;
	}
	mobj->LevelSpawned ();

	T_RegisterSpawnThing(mobj);

}



//
// GAME SPAWN FUNCTIONS
//


//
// P_SpawnPuff
//

AActor *P_SpawnPuff (const PClass *pufftype, fixed_t x, fixed_t y, fixed_t z, angle_t dir, int updown, bool hitthing)
{
	AActor *puff;

	z += pr_spawnpuff.Random2 () << 10;

	puff = Spawn (pufftype, x, y, z, ALLOW_REPLACE);

	// If a puff has a crash state and an actor was not hit,
	// it will enter the crash state. This is used by the StrifeSpark
	// and BlasterPuff.
	FState *crashstate;
	if (hitthing == false && (crashstate = puff->FindState(NAME_Crash)) != NULL)
	{
		puff->SetState (crashstate);
	}
	else if (attackrange == MELEERANGE && puff->MeleeState != NULL)
	{
		// handle the hard coded state jump of Doom's bullet puff
		// in a more flexible manner.
		puff->SetState (puff->MeleeState);
	}

	if (cl_pufftype && updown != 3 && (puff->flags4 & MF4_ALLOWPARTICLES))
	{
		P_DrawSplash2 (32, x, y, z, dir, updown, 1);
		puff->renderflags |= RF_INVISIBLE;
	}

	if (hitthing && puff->SeeSound)
	{ // Hit thing sound
		S_SoundID (puff, CHAN_BODY, puff->SeeSound, 1, ATTN_NORM);
	}
	else if (puff->AttackSound)
	{
		S_SoundID (puff, CHAN_BODY, puff->AttackSound, 1, ATTN_NORM);
	}

	PuffSpawned = puff;
	return puff;
}



//---------------------------------------------------------------------------
//
// P_SpawnBlood
//
//---------------------------------------------------------------------------

void P_SpawnBlood (fixed_t x, fixed_t y, fixed_t z, angle_t dir, int damage, AActor *originator)
{
	AActor *th;
	PalEntry bloodcolor = (PalEntry)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodColor);
	const PClass *bloodcls = PClass::FindClass((ENamedName)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodType, NAME_Blood));

	if (bloodcls!=NULL && cl_bloodtype <= 1)
	{
		z += pr_spawnblood.Random2 () << 10;
		th = Spawn (bloodcls, x, y, z, ALLOW_REPLACE);
		th->momz = FRACUNIT*2;
		th->angle = dir;
		if (gameinfo.gametype == GAME_Doom)
		{
			th->tics -= pr_spawnblood() & 3;

			if (th->tics < 1)
				th->tics = 1;
		}
		// colorize the blood
		if (bloodcolor != 0 && !(th->flags2 & MF2_DONTTRANSLATE))
		{
			th->Translation = TRANSLATION(TRANSLATION_Blood, bloodcolor.a);
		}

		// Moved out of the blood actor so that replacing blood is easier
		if (gameinfo.gametype & GAME_DoomStrife)
		{
			if (gameinfo.gametype == GAME_Strife)
			{
				if (damage > 13)
				{
					FState *state = th->FindState(NAME_Spray);
					if (state != NULL) th->SetState (state);
				}
				else damage+=2;
			}
			if (damage <= 12 && damage >= 9)
			{
				th->SetState (th->SpawnState + 1);
			}
			else if (damage < 9)
			{
				th->SetState (th->SpawnState + 2);
			}
		}
	}

	if (cl_bloodtype >= 1)
		P_DrawSplash2 (40, x, y, z, dir, 2, bloodcolor);
}

//---------------------------------------------------------------------------
//
// PROC P_BloodSplatter
//
//---------------------------------------------------------------------------

void P_BloodSplatter (fixed_t x, fixed_t y, fixed_t z, AActor *originator)
{
	PalEntry bloodcolor = (PalEntry)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodColor);
	const PClass *bloodcls = PClass::FindClass((ENamedName)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodType2, NAME_BloodSplatter));

	if (bloodcls!=NULL && cl_bloodtype <= 1)
	{
		AActor *mo;

		mo = Spawn(bloodcls, x, y, z, ALLOW_REPLACE);
		mo->target = originator;
		mo->momx = pr_splatter.Random2 () << 10;
		mo->momy = pr_splatter.Random2 () << 10;
		mo->momz = 3*FRACUNIT;

		// colorize the blood!
		if (bloodcolor!=0 && !(mo->flags2 & MF2_DONTTRANSLATE))
		{
			mo->Translation = TRANSLATION(TRANSLATION_Blood, bloodcolor.a);
		}
	}
	if (cl_bloodtype >= 1)
	{
		P_DrawSplash2 (40, x, y, z, R_PointToAngle2 (x, y, originator->x, originator->y), 2, bloodcolor);
	}
}

//===========================================================================
//
//  P_BloodSplatter2
//
//===========================================================================

void P_BloodSplatter2 (fixed_t x, fixed_t y, fixed_t z, AActor *originator)
{
	PalEntry bloodcolor = (PalEntry)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodColor);
	const PClass *bloodcls = PClass::FindClass((ENamedName)originator->GetClass()->Meta.GetMetaInt(AMETA_BloodType3, NAME_AxeBlood));

	if (bloodcls!=NULL && cl_bloodtype <= 1)
	{
		AActor *mo;

		x += ((pr_splat()-128)<<11);
		y += ((pr_splat()-128)<<11);

		mo = Spawn (bloodcls, x, y, z, ALLOW_REPLACE);
		mo->target = originator;

		// colorize the blood!
		if (bloodcolor != 0 && !(mo->flags2 & MF2_DONTTRANSLATE))
		{
			mo->Translation = TRANSLATION(TRANSLATION_Blood, bloodcolor.a);
		}
	}
	if (cl_bloodtype >= 1)
	{
		P_DrawSplash2 (100, x, y, z, R_PointToAngle2 (0, 0, originator->x - x, originator->y - y), 2, bloodcolor);
	}
}

//---------------------------------------------------------------------------
//
// PROC P_RipperBlood
//
//---------------------------------------------------------------------------

void P_RipperBlood (AActor *mo, AActor *bleeder)
{
	fixed_t x, y, z;
	PalEntry bloodcolor = (PalEntry)bleeder->GetClass()->Meta.GetMetaInt(AMETA_BloodColor);
	const PClass *bloodcls = PClass::FindClass((ENamedName)bleeder->GetClass()->Meta.GetMetaInt(AMETA_BloodType, NAME_Blood));

	x = mo->x + (pr_ripperblood.Random2 () << 12);
	y = mo->y + (pr_ripperblood.Random2 () << 12);
	z = mo->z + (pr_ripperblood.Random2 () << 12);
	if (bloodcls!=NULL && cl_bloodtype <= 1)
	{
		AActor *th;
		th = Spawn (bloodcls, x, y, z, ALLOW_REPLACE);
		if (gameinfo.gametype == GAME_Heretic)
			th->flags |= MF_NOGRAVITY;
		th->momx = mo->momx >> 1;
		th->momy = mo->momy >> 1;
		th->tics += pr_ripperblood () & 3;

		// colorize the blood!
		if (bloodcolor!=0 && !(th->flags2 & MF2_DONTTRANSLATE))
		{
			th->Translation = TRANSLATION(TRANSLATION_Blood, bloodcolor.a);
		}
	}
	if (cl_bloodtype >= 1)
	{
		P_DrawSplash2 (28, x, y, z, 0, 0, bloodcolor);
	}
}

//---------------------------------------------------------------------------
//
// FUNC P_GetThingFloorType
//
//---------------------------------------------------------------------------

int P_GetThingFloorType (AActor *thing)
{
	if (thing->floorpic)
	{
		return TerrainTypes[thing->floorpic];
	}
	else
	{
		return TerrainTypes[thing->Sector->floorpic];
	}
}

//---------------------------------------------------------------------------
//
// FUNC P_HitWater
//
// Returns true if hit liquid and splashed, false if not.
//---------------------------------------------------------------------------

bool P_HitWater (AActor * thing, sector_t * sec, fixed_t z)
{
	if (thing->flags2 & MF2_FLOATBOB || thing->flags3 & MF3_DONTSPLASH)
		return false;

	if (thing->player && (thing->player->cheats & CF_PREDICTING))
		return false;

	AActor *mo = NULL;
	FSplashDef *splash;
	int terrainnum;

	if (z==FIXED_MIN) z=thing->z;
	// don't splash above the object
	else if (z>thing->z+(thing->height>>1)) return false;

	for(int i=0;i<sec->e->ffloors.Size();i++)
	{
		F3DFloor * rover = sec->e->ffloors[i];
		if (!(rover->flags & FF_EXISTS)) continue;
		if (rover->top.plane->ZatPoint(thing->x, thing->y) == z)
		{
			if (rover->flags & (FF_SOLID|FF_SWIMMABLE) )
			{
				terrainnum = TerrainTypes[*rover->top.texture];
				goto foundone;
			}
		}
	}
	if (sec->heightsec == NULL ||
		//!sec->heightsec->waterzone ||
		(sec->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC) ||
		!(sec->heightsec->MoreFlags & SECF_CLIPFAKEPLANES))
	{
		terrainnum = TerrainTypes[sec->floorpic];
	}
	else
	{
		terrainnum = TerrainTypes[sec->heightsec->floorpic];
	}
foundone:

	int splashnum = Terrains[terrainnum].Splash;
	bool smallsplash = false;
	const secplane_t *plane;

	if (splashnum == -1)
		return Terrains[terrainnum].IsLiquid;

	// don't splash when touching an underwater floor
	if (thing->waterlevel>=1 && z<=thing->floorz) return Terrains[terrainnum].IsLiquid;

	plane = (sec->heightsec != NULL &&
		//sec->heightsec->waterzone &&
		!(sec->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC))
	  ? &sec->heightsec->floorplane : &sec->floorplane;

	// Don't splash for living things with small vertical velocities.
	// There are levels where the constant splashing from the monsters gets extremely annoying
	if ((thing->flags3&MF3_ISMONSTER || thing->player) && thing->momz>=-5*FRACUNIT) return Terrains[terrainnum].IsLiquid;

	splash = &Splashes[splashnum];

	// Small splash for small masses
	if (thing->Mass < 10)
		smallsplash = true;

	if (smallsplash && splash->SmallSplash)
	{
		mo = Spawn (splash->SmallSplash, thing->x, thing->y, z, ALLOW_REPLACE);
		if (mo) mo->floorclip += splash->SmallSplashClip;
	}
	else
	{
		if (splash->SplashChunk)
		{
			mo = Spawn (splash->SplashChunk, thing->x, thing->y, z, ALLOW_REPLACE);
			mo->target = thing;
			if (splash->ChunkXVelShift != 255)
			{
				mo->momx = pr_chunk.Random2() << splash->ChunkXVelShift;
			}
			if (splash->ChunkYVelShift != 255)
			{
				mo->momy = pr_chunk.Random2() << splash->ChunkYVelShift;
			}
			mo->momz = splash->ChunkBaseZVel + (pr_chunk() << splash->ChunkZVelShift);
		}
		if (splash->SplashBase)
		{
			mo = Spawn (splash->SplashBase, thing->x, thing->y, z, ALLOW_REPLACE);
		}
		if (thing->player && !splash->NoAlert)
		{
			P_NoiseAlert (thing, thing, true);
		}
	}
	if (mo)
	{
		S_SoundID (mo, CHAN_ITEM, smallsplash ?
			splash->SmallSplashSound : splash->NormalSplashSound,
			1, ATTN_IDLE);
	}
	else
	{
		S_SoundID (thing->x, thing->y, z, CHAN_ITEM, smallsplash ?
			splash->SmallSplashSound : splash->NormalSplashSound,
			1, ATTN_IDLE);
	}

	// Don't let deep water eat missiles
	return plane == &sec->floorplane ? Terrains[terrainnum].IsLiquid : false;
}

//---------------------------------------------------------------------------
//
// FUNC P_HitFloor
//
// Returns true if hit liquid and splashed, false if not.
//---------------------------------------------------------------------------

bool P_HitFloor (AActor *thing)
{
	const msecnode_t *m;

	if (thing->flags2 & MF2_FLOATBOB || thing->flags3 & MF3_DONTSPLASH)
		return false;

	// don't splash if landing on the edge above water/lava/etc....
	for (m = thing->touching_sectorlist; m; m = m->m_tnext)
	{
		if (thing->z == m->m_sector->floorplane.ZatPoint (thing->x, thing->y))
		{
			break;
		}

		// Check 3D floors
		for(int i=0;i<m->m_sector->e->ffloors.Size();i++)
		{
			F3DFloor * rover = m->m_sector->e->ffloors[i];
			if (!(rover->flags & FF_EXISTS)) continue;
			if (rover->flags & (FF_SOLID|FF_SWIMMABLE))
			{
				if (rover->top.plane->ZatPoint(thing->x, thing->y) == thing->z)
				{
					return P_HitWater (thing, m->m_sector);
				}
			}
		}
	}
	if (m == NULL ||
		(m->m_sector->heightsec != NULL &&
		!(m->m_sector->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC)))
	{
		return false;
	}

	return P_HitWater (thing, m->m_sector);
}

//---------------------------------------------------------------------------
//
// FUNC P_CheckMissileSpawn
//
// Returns true if the missile is at a valid spawn point, otherwise
// explodes it and returns false.
//
//---------------------------------------------------------------------------

bool P_CheckMissileSpawn (AActor* th, bool isSDBossRush)
{
	// [RH] Don't decrement tics if they are already less than 1
	if ((th->flags4 & MF4_RANDOMIZE) && th->tics > 0)
	{
		th->tics -= pr_checkmissilespawn() & 3;
		if (th->tics < 1)
			th->tics = 1;
	}

	// move a little forward so an angle can be computed if it immediately explodes
	if (th->Speed >= 100*FRACUNIT)
	{ // Ultra-fast ripper spawning missile
		th->x += th->momx>>3;
		th->y += th->momy>>3;
		th->z += th->momz>>3;
	}
	else
	{ // Normal missile
		th->x += th->momx>>1;
		th->y += th->momy>>1;
		th->z += th->momz>>1;
	}

	// killough 3/15/98: no dropoff (really = don't care for missiles)

	if (!P_TryMove (th, th->x, th->y, false))
	{
		// [RH] Don't explode ripping missiles that spawn inside something
		if (BlockingMobj == NULL || !(th->flags2 & MF2_RIP))
		{
			// If this is a monster spawned by A_CustomMissile subtract it from the counter.
			if (th->CountsAsKill()&&!isSDBossRush)
			{
				th->flags&=~MF_COUNTKILL;
				level.total_monsters--;
			}
			// [RH] Don't explode missiles that spawn on top of horizon lines
			//GHK, just destroy in a boss rush, to stop spawn cycling
			if (BlockingLine != NULL && BlockingLine->special == Line_Horizon)
			{
				if(!isSDBossRush)
					th->Destroy ();
			}
			else
			{
				if(!isSDBossRush)
					P_ExplodeMissile (th, NULL, NULL);
			}
			return false;
		}
	}
	return true;
}


//---------------------------------------------------------------------------
//
// FUNC P_PlaySpawnSound
//
// Plays a missiles spawn sound. Location depends on the
// MF_SPAWNSOUNDSOURCE flag.
//
//---------------------------------------------------------------------------

void P_PlaySpawnSound(AActor *missile, AActor *spawner)
{
	if (missile->SeeSound != 0)
	{
		if (!(missile->flags & MF_SPAWNSOUNDSOURCE))
		{
			S_SoundID (missile, CHAN_VOICE, missile->SeeSound, 1, ATTN_NORM);
		}
		else if (spawner != NULL)
		{
			S_SoundID (spawner, CHAN_WEAPON, missile->SeeSound, 1, ATTN_NORM);
		}
		else
		{
			// If there is no spawner use the spawn position.
			// But not in a silenced sector.
			if (!(missile->Sector->MoreFlags & SECF_SILENT))
				S_SoundID (&missile->x, CHAN_WEAPON, missile->SeeSound, 1, ATTN_NORM);
		}
	}
}

//---------------------------------------------------------------------------
//
// FUNC P_SpawnMissile
//
// Returns NULL if the missile exploded immediately, otherwise returns
// a mobj_t pointer to the missile.
//
//---------------------------------------------------------------------------

AActor *P_SpawnMissile (AActor *source, AActor *dest, const PClass *type, bool isSDBossRush)
{
		return P_SpawnMissileXYZ (source->x, source->y, source->z + 32*FRACUNIT,
		source, dest, type, isSDBossRush);

}

AActor *P_SpawnMissileZ (AActor *source, fixed_t z, AActor *dest, const PClass *type)
{
	return P_SpawnMissileXYZ (source->x, source->y, z, source, dest, type);
}

AActor *P_SpawnMissileXYZ (fixed_t x, fixed_t y, fixed_t z,
	AActor *source, AActor *dest, const PClass *type, bool isSDBossRush)
{
	if (dest == NULL)
	{
		Printf ("P_SpawnMissilyXYZ: Tried to shoot %s from %s with no dest\n",
			type->TypeName.GetChars(), source->GetClass()->TypeName.GetChars());
		return NULL;
	}
	int defflags3 = GetDefaultByType (type)->flags3;

	if (defflags3 & MF3_FLOORHUGGER)
	{
		z = ONFLOORZ;
	}
	else if (defflags3 & MF3_CEILINGHUGGER)
	{
		z = ONCEILINGZ;
	}
	else if (z != ONFLOORZ)
	{
		z -= source->floorclip;
	}

	AActor *th = Spawn (type, x, y, z, ALLOW_REPLACE);

	P_PlaySpawnSound(th, source);
	th->target = source;		// record missile's originator

	float speed = (float)(th->Speed);

	// [RH]
	// Hexen calculates the missile velocity based on the source's location.
	// Would it be more useful to base it on the actual position of the
	// missile?
	// Answer: No, because this way, you can set up sets of parallel missiles.

	FVector3 velocity(dest->x - source->x, dest->y - source->y, dest->z - source->z);
	// Floor and ceiling huggers should never have a vertical component to their velocity
	if (defflags3 & (MF3_FLOORHUGGER|MF3_CEILINGHUGGER))
	{
		velocity.Z = 0;
	}
	// [RH] Adjust the trajectory if the missile will go over the target's head.
	else if (z - source->z >= dest->height)
	{
		velocity.Z += dest->height - z + source->z;
	}
	velocity.Resize (speed);
	th->momx = (fixed_t)(velocity.X);
	th->momy = (fixed_t)(velocity.Y);
	th->momz = (fixed_t)(velocity.Z);

	// invisible target: rotate velocity vector in 2D
	if (dest->flags & MF_SHADOW)
	{
		angle_t an = pr_spawnmissile.Random2 () << 20;
		an >>= ANGLETOFINESHIFT;

		fixed_t newx = DMulScale16 (th->momx, finecosine[an], -th->momy, finesine[an]);
		fixed_t newy = DMulScale16 (th->momx, finesine[an], th->momy, finecosine[an]);
		th->momx = newx;
		th->momy = newy;
	}

	th->angle = R_PointToAngle2 (0, 0, th->momx, th->momy);
	//ghk
	AActor * checkMisSpawn = P_CheckMissileSpawn (th, isSDBossRush) ? th : NULL;
	if(isSDBossRush&&!checkMisSpawn){
		//ok, we cannot spawn where we want, so teleport back to the original boss position
		//passed on down the chain, and telefrag anything in the way, including naughty players.
		P_TeleportMove (th, source->origx, source->origy, source->origz, true); //telefrag players etc...!
		return th;
	}else
		return checkMisSpawn;

	//return P_CheckMissileSpawn (th, isSDBossRush) ? th : NULL;
}

//---------------------------------------------------------------------------
//
// FUNC P_SpawnMissileAngle
//
// Returns NULL if the missile exploded immediately, otherwise returns
// a mobj_t pointer to the missile.
//
//---------------------------------------------------------------------------

AActor *P_SpawnMissileAngle (AActor *source, const PClass *type,
	angle_t angle, fixed_t momz)
{
	return P_SpawnMissileAngleZSpeed (source, source->z + 32*FRACUNIT,
		type, angle, momz, GetDefaultByType (type)->Speed);
}

AActor *P_SpawnMissileAngleZ (AActor *source, fixed_t z,
	const PClass *type, angle_t angle, fixed_t momz)
{
	return P_SpawnMissileAngleZSpeed (source, z, type, angle, momz,
		GetDefaultByType (type)->Speed);
}

AActor *P_SpawnMissileZAimed (AActor *source, fixed_t z, AActor *dest, const PClass *type)
{
	angle_t an;
	fixed_t dist;
	fixed_t speed;
	fixed_t momz;

	an = source->angle;

	if (dest->flags & MF_SHADOW)
	{
		an += pr_spawnmissile.Random2() << 20;
	}
	dist = P_AproxDistance (dest->x - source->x, dest->y - source->y);
	speed = GetDefaultByType (type)->Speed;
	dist /= speed;
	momz = dist != 0 ? (dest->z - source->z)/dist : speed;
	return P_SpawnMissileAngleZSpeed (source, z, type, an, momz, speed);
}

//---------------------------------------------------------------------------
//
// FUNC P_SpawnMissileAngleSpeed
//
// Returns NULL if the missile exploded immediately, otherwise returns
// a mobj_t pointer to the missile.
//
//---------------------------------------------------------------------------

AActor *P_SpawnMissileAngleSpeed (AActor *source, const PClass *type,
	angle_t angle, fixed_t momz, fixed_t speed)
{
	return P_SpawnMissileAngleZSpeed (source, source->z + 32*FRACUNIT,
		type, angle, momz, speed);
}

AActor *P_SpawnMissileAngleZSpeed (AActor *source, fixed_t z,
	const PClass *type, angle_t angle, fixed_t momz, fixed_t speed, AActor *owner)
{
	AActor *mo;
	int defflags3 = GetDefaultByType (type)->flags3;

	if (defflags3 & MF3_FLOORHUGGER)
	{
		z = ONFLOORZ;
	}
	else if (defflags3 & MF3_CEILINGHUGGER)
	{
		z = ONCEILINGZ;
	}
	if (z != ONFLOORZ)
	{
		z -= source->floorclip;
	}
	mo = Spawn (type, source->x, source->y, z, ALLOW_REPLACE);
	P_PlaySpawnSound(mo, source);
	mo->target = owner != NULL ? owner : source; // Originator
	mo->angle = angle;
	angle >>= ANGLETOFINESHIFT;
	mo->momx = FixedMul (speed, finecosine[angle]);
	mo->momy = FixedMul (speed, finesine[angle]);
	mo->momz = momz;
	return P_CheckMissileSpawn(mo) ? mo : NULL;
}

/*
================
=
= P_SpawnPlayerMissile
=
= Tries to aim at a nearby monster
================
*/

AActor *P_SpawnPlayerMissile (AActor *source, const PClass *type)
{
	return P_SpawnPlayerMissile (source, 0, 0, 0, type, source->angle);
}

AActor *P_SpawnPlayerMissile (AActor *source, const PClass *type, angle_t angle)
{
	return P_SpawnPlayerMissile (source, 0, 0, 0, type, angle);
}

AActor *P_SpawnPlayerMissile (AActor *source, fixed_t x, fixed_t y, fixed_t z,
							  const PClass *type, angle_t angle)
{
	static const int angdiff[3] = { -1<<26, 1<<26, 0 };
	int i;
	angle_t an;
	angle_t pitch;

	// Note: NOAUTOAIM is implemented only here, and not in the hitscan or rail attack functions.
	// That is because it is only justified for projectiles affected by gravity, not for other attacks.
	//GHK support for rocket launcher alt-fire only
	if (source && source->player && source->player->ReadyWeapon && source->player->ReadyWeapon->bAltFire && (source->player->ReadyWeapon->WeaponFlags & WIF_NOAUTOAIM))
	{
		// Keep exactly the same angle and pitch as the player's own aim
		pitch = source->pitch; linetarget = NULL;
	}
	else // see which target is to be aimed at
	{
	// see which target is to be aimed at
		i = 2;
		do
		{
			an = angle + angdiff[i];
			pitch = P_AimLineAttack (source, an, 16*64*FRACUNIT);

			if (source->player != NULL &&
				!(dmflags & DF_NO_FREELOOK) &&
				source->player->userinfo.aimdist <= ANGLE_1/2)
			{
				break;
			}
		} while (linetarget == NULL && --i >= 0);
	}

	if (linetarget == NULL)
	{
		an = angle;
	}

	i = GetDefaultByType (type)->flags3;

	if (i & MF3_FLOORHUGGER)
	{
		z = ONFLOORZ;
	}
	else if (i & MF3_CEILINGHUGGER)
	{
		z = ONCEILINGZ;
	}
	if (z != ONFLOORZ && z != ONCEILINGZ)
	{
		// Doom spawns missiles 4 units lower than hitscan attacks for players.
		z += source->z + (source->height>>1) - source->floorclip;
		if (source->player != NULL)	// Considering this is for player missiles, it better not be NULL.
		{
			z += FixedMul (source->player->mo->AttackZOffset - 4*FRACUNIT, source->player->crouchfactor);
		}
		else
		{
			z += 4*FRACUNIT;
		}
		// Do not fire beneath the floor.
		if (z < source->floorz)
		{
			z = source->floorz;
		}
	}
	MissileActor = Spawn (type, source->x + x, source->y + y, z, ALLOW_REPLACE);
	P_PlaySpawnSound(MissileActor, source);
	MissileActor->target = source;
	MissileActor->angle = an;

	fixed_t vx, vy, vz, speed;

	vx = FixedMul (finecosine[pitch>>ANGLETOFINESHIFT], finecosine[an>>ANGLETOFINESHIFT]);
	vy = FixedMul (finecosine[pitch>>ANGLETOFINESHIFT], finesine[an>>ANGLETOFINESHIFT]);
	vz = -finesine[pitch>>ANGLETOFINESHIFT];
	speed = MissileActor->Speed;

	MissileActor->momx = FixedMul (vx, speed);
	MissileActor->momy = FixedMul (vy, speed);
	MissileActor->momz = FixedMul (vz, speed);

	if (P_CheckMissileSpawn (MissileActor))
	{
		return MissileActor;
	}
	return NULL;
}

bool AActor::IsTeammate (AActor *other)
{
	if (!player || !other || !other->player)
		return false;
	if (!deathmatch)
		return true;
	if (teamplay && other->player->userinfo.team != TEAM_None &&
		player->userinfo.team == other->player->userinfo.team)
	{
		return true;
	}
	return false;
}

//==========================================================================
//
// AActor :: GetSpecies
//
// Species is defined as the lowest base class that is a monster
// with no non-monster class in between. This is virtualized, so special
// monsters can change this behavior if they like.
//
//==========================================================================

const PClass *AActor::GetSpecies()
{
	const PClass *thistype = GetClass();

	if (GetDefaultByType(thistype)->flags3 & MF3_ISMONSTER)
	{
		while (thistype->ParentClass)
		{
			if (GetDefaultByType(thistype->ParentClass)->flags3 & MF3_ISMONSTER)
				thistype = thistype->ParentClass;
			else
				break;
		}
	}
	return thistype;
}

//==========================================================================
//
// AActor :: IsFriend
//
// Checks if two monsters have to be considered friendly.
//
//==========================================================================

bool AActor::IsFriend (AActor *other)
{
	if (flags & other->flags & MF_FRIENDLY)
	{
		return !deathmatch ||
			FriendPlayer == other->FriendPlayer ||
			FriendPlayer == 0 ||
			other->FriendPlayer == 0;
	}
	return false;
}

//==========================================================================
//
// AActor :: IsHostile
//
// Checks if two monsters have to be considered hostile under any circumstances
//
//==========================================================================

bool AActor::IsHostile (AActor *other)
{
	// Both monsters are non-friendlies so hostilities depend on infighting settings
	if (!((flags | other->flags) & MF_FRIENDLY)) return false;

	// Both monsters are friendly and belong to the same player if applicable.
	if (flags & other->flags & MF_FRIENDLY)
	{
		return deathmatch &&
			FriendPlayer != other->FriendPlayer &&
			FriendPlayer !=0 &&
			other->FriendPlayer != 0;
	}
	return true;
}

int AActor::DoSpecialDamage (AActor *target, int damage)
{
	if (target->player && target->player->mo == target && damage < 1000 &&
		(target->player->cheats & CF_GODMODE))
	{
		return -1;
	}
	else
	{
		if (target->player)
		{
			int poisondamage = GetClass()->Meta.GetMetaInt(AMETA_PoisonDamage);
			if (poisondamage > 0)
			{
				P_PoisonPlayer (target->player, this, this->target, poisondamage);
				damage >>= 1;
			}
		}

		return damage;
	}
}

int AActor::TakeSpecialDamage (AActor *inflictor, AActor *source, int damage, FName damagetype)
{
	// If the actor does not have a corresponding death state, then it does not take damage.
	// Note that DeathState matches every kind of damagetype, so if an actor has that, it can
	// be hurt with any type of damage. Exception: Massacre damage always succeeds, because
	// it needs to work.
	FState *death;

	if (flags5 & MF5_NODAMAGE)
	{
		return 0;
	}

	// If the actor does not have a corresponding death state, then it does not take damage.
	// Note that DeathState matches every kind of damagetype, so an actor has that, it can
	// be hurt with any type of damage. Exception: Massacre damage always succeeds, because
	// it needs to work.

	// Always kill if there is a regular death state or no death states at all.
	if (FindState (NAME_Death) != NULL || !HasSpecialDeathStates())
	{
		return damage;
	}
	if (damagetype == NAME_Ice)
	{
		death = FindState (NAME_Death, NAME_Ice, true);
		if (death == NULL && !deh.NoAutofreeze && !(flags4 & MF4_NOICEDEATH) &&
			(player || (flags3 & MF3_ISMONSTER)))
		{
			death = &AActor::States[S_GENERICFREEZEDEATH];
		}
	}
	else
	{
		death = FindState (NAME_Death, damagetype);
	}
	return (death == NULL) ? -1 : damage;
}

void AActor::Crash()
{
	if ((flags & MF_CORPSE) &&
		!(flags3 & MF3_CRASHED) &&
		!(flags & MF_ICECORPSE))
	{
		FState * crashstate=NULL;

		if (DamageType != NAME_None)
		{
			crashstate = FindState(NAME_Crash, DamageType, true);
		}
		if (crashstate == NULL)
		{
			int gibhealth = -abs(GetClass()->Meta.GetMetaInt (AMETA_GibHealth,
				gameinfo.gametype == GAME_Doom ? -GetDefault()->health : -GetDefault()->health/2));

			if (health<gibhealth)
			{ // Extreme death
				crashstate = FindState (NAME_Crash, NAME_Extreme);
			}
			else
			{ // Normal death
				crashstate = FindState (NAME_Crash);
			}
		}
		if (crashstate != NULL) SetState(crashstate);
		// Set MF3_CRASHED regardless of the presence of a crash state
		// so this code doesn't have to be executed repeatedly.
		flags3 |= MF3_CRASHED;
	}
}

FArchive &operator<< (FArchive &arc, FSoundIndex &snd)
{
	if (arc.IsStoring ())
	{
		arc.WriteName (snd.Index ? S_sfx[snd.Index].name.GetChars() : NULL);
	}
	else
	{
		const char *name = arc.ReadName ();
		snd.Index = name != NULL ? S_FindSound (name) : 0;
	}
	return arc;
}

FArchive &operator<< (FArchive &arc, FSoundIndexWord &snd)
{
	FSoundIndex snd2 = { snd.Index };
	arc << snd2;
	snd.Index = snd2.Index;
	return arc;
}
